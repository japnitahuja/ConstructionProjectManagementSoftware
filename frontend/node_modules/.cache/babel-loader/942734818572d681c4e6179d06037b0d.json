{"ast":null,"code":"/**\n * interact.js v1.3.4\n *\n * Copyright (c) 2012-2018 Taye Adeyemi <dev@taye.me>\n * Released under the MIT License.\n * https://raw.github.com/taye/interact.js/master/LICENSE\n */\n(function (f) {\n  if (typeof exports === \"object\" && typeof module !== \"undefined\") {\n    module.exports = f();\n  } else if (typeof define === \"function\" && define.amd) {\n    define([], f);\n  } else {\n    var g;\n\n    if (typeof window !== \"undefined\") {\n      g = window;\n    } else if (typeof global !== \"undefined\") {\n      g = global;\n    } else if (typeof self !== \"undefined\") {\n      g = self;\n    } else {\n      g = this;\n    }\n\n    g.interact = f();\n  }\n})(function () {\n  var define, module, exports;\n  return function e(t, n, r) {\n    function s(o, u) {\n      if (!n[o]) {\n        if (!t[o]) {\n          var a = typeof require == \"function\" && require;\n          if (!u && a) return a(o, !0);\n          if (i) return i(o, !0);\n          var f = new Error(\"Cannot find module '\" + o + \"'\");\n          throw f.code = \"MODULE_NOT_FOUND\", f;\n        }\n\n        var l = n[o] = {\n          exports: {}\n        };\n        t[o][0].call(l.exports, function (e) {\n          var n = t[o][1][e];\n          return s(n ? n : e);\n        }, l, l.exports, e, t, n, r);\n      }\n\n      return n[o].exports;\n    }\n\n    var i = typeof require == \"function\" && require;\n\n    for (var o = 0; o < r.length; o++) s(r[o]);\n\n    return s;\n  }({\n    1: [function (require, module, exports) {\n      'use strict';\n      /*\n       * In a (windowless) server environment this file exports a factory function\n       * that takes the window to use.\n       *\n       *     var interact = require('interact.js')(windowObject);\n       *\n       * See https://github.com/taye/interact.js/issues/187\n       */\n\n      if (typeof window === 'undefined') {\n        module.exports = function (window) {\n          require('./src/utils/window').init(window);\n\n          return require('./src/index');\n        };\n      } else {\n        module.exports = require('./src/index');\n      }\n    }, {\n      \"./src/index\": 19,\n      \"./src/utils/window\": 52\n    }],\n    2: [function (require, module, exports) {\n      'use strict';\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      var extend = require('./utils/extend.js');\n\n      function fireUntilImmediateStopped(event, listeners) {\n        for (var _i = 0; _i < listeners.length; _i++) {\n          var _ref;\n\n          _ref = listeners[_i];\n          var listener = _ref;\n\n          if (event.immediatePropagationStopped) {\n            break;\n          }\n\n          listener(event);\n        }\n      }\n\n      var Eventable = function () {\n        function Eventable(options) {\n          _classCallCheck(this, Eventable);\n\n          this.options = extend({}, options || {});\n        }\n\n        Eventable.prototype.fire = function fire(event) {\n          var listeners = void 0;\n          var onEvent = 'on' + event.type;\n          var global = this.global; // Interactable#on() listeners\n\n          if (listeners = this[event.type]) {\n            fireUntilImmediateStopped(event, listeners);\n          } // interactable.onevent listener\n\n\n          if (this[onEvent]) {\n            this[onEvent](event);\n          } // interact.on() listeners\n\n\n          if (!event.propagationStopped && global && (listeners = global[event.type])) {\n            fireUntilImmediateStopped(event, listeners);\n          }\n        };\n\n        Eventable.prototype.on = function on(eventType, listener) {\n          // if this type of event was never bound\n          if (this[eventType]) {\n            this[eventType].push(listener);\n          } else {\n            this[eventType] = [listener];\n          }\n        };\n\n        Eventable.prototype.off = function off(eventType, listener) {\n          // if it is an action event type\n          var eventList = this[eventType];\n          var index = eventList ? eventList.indexOf(listener) : -1;\n\n          if (index !== -1) {\n            eventList.splice(index, 1);\n          }\n\n          if (eventList && eventList.length === 0 || !listener) {\n            this[eventType] = undefined;\n          }\n        };\n\n        return Eventable;\n      }();\n\n      module.exports = Eventable;\n    }, {\n      \"./utils/extend.js\": 41\n    }],\n    3: [function (require, module, exports) {\n      'use strict';\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      var extend = require('./utils/extend');\n\n      var getOriginXY = require('./utils/getOriginXY');\n\n      var defaults = require('./defaultOptions');\n\n      var signals = require('./utils/Signals').new();\n\n      var InteractEvent = function () {\n        /** */\n        function InteractEvent(interaction, event, action, phase, element, related) {\n          var preEnd = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n\n          _classCallCheck(this, InteractEvent);\n\n          var target = interaction.target;\n          var deltaSource = (target && target.options || defaults).deltaSource;\n          var origin = getOriginXY(target, element, action);\n          var starting = phase === 'start';\n          var ending = phase === 'end';\n          var coords = starting ? interaction.startCoords : interaction.curCoords;\n          var prevEvent = interaction.prevEvent;\n          element = element || interaction.element;\n          var page = extend({}, coords.page);\n          var client = extend({}, coords.client);\n          page.x -= origin.x;\n          page.y -= origin.y;\n          client.x -= origin.x;\n          client.y -= origin.y;\n          this.ctrlKey = event.ctrlKey;\n          this.altKey = event.altKey;\n          this.shiftKey = event.shiftKey;\n          this.metaKey = event.metaKey;\n          this.button = event.button;\n          this.buttons = event.buttons;\n          this.target = element;\n          this.currentTarget = element;\n          this.relatedTarget = related || null;\n          this.preEnd = preEnd;\n          this.type = action + (phase || '');\n          this.interaction = interaction;\n          this.interactable = target;\n          this.t0 = starting ? interaction.downTimes[interaction.downTimes.length - 1] : prevEvent.t0;\n          var signalArg = {\n            interaction: interaction,\n            event: event,\n            action: action,\n            phase: phase,\n            element: element,\n            related: related,\n            page: page,\n            client: client,\n            coords: coords,\n            starting: starting,\n            ending: ending,\n            deltaSource: deltaSource,\n            iEvent: this\n          };\n          signals.fire('set-xy', signalArg);\n\n          if (ending) {\n            // use previous coords when ending\n            this.pageX = prevEvent.pageX;\n            this.pageY = prevEvent.pageY;\n            this.clientX = prevEvent.clientX;\n            this.clientY = prevEvent.clientY;\n          } else {\n            this.pageX = page.x;\n            this.pageY = page.y;\n            this.clientX = client.x;\n            this.clientY = client.y;\n          }\n\n          this.x0 = interaction.startCoords.page.x - origin.x;\n          this.y0 = interaction.startCoords.page.y - origin.y;\n          this.clientX0 = interaction.startCoords.client.x - origin.x;\n          this.clientY0 = interaction.startCoords.client.y - origin.y;\n          signals.fire('set-delta', signalArg);\n          this.timeStamp = coords.timeStamp;\n          this.dt = interaction.pointerDelta.timeStamp;\n          this.duration = this.timeStamp - this.t0; // speed and velocity in pixels per second\n\n          this.speed = interaction.pointerDelta[deltaSource].speed;\n          this.velocityX = interaction.pointerDelta[deltaSource].vx;\n          this.velocityY = interaction.pointerDelta[deltaSource].vy;\n          this.swipe = ending || phase === 'inertiastart' ? this.getSwipe() : null;\n          signals.fire('new', signalArg);\n        }\n\n        InteractEvent.prototype.getSwipe = function getSwipe() {\n          var interaction = this.interaction;\n\n          if (interaction.prevEvent.speed < 600 || this.timeStamp - interaction.prevEvent.timeStamp > 150) {\n            return null;\n          }\n\n          var angle = 180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX) / Math.PI;\n          var overlap = 22.5;\n\n          if (angle < 0) {\n            angle += 360;\n          }\n\n          var left = 135 - overlap <= angle && angle < 225 + overlap;\n          var up = 225 - overlap <= angle && angle < 315 + overlap;\n          var right = !left && (315 - overlap <= angle || angle < 45 + overlap);\n          var down = !up && 45 - overlap <= angle && angle < 135 + overlap;\n          return {\n            up: up,\n            down: down,\n            left: left,\n            right: right,\n            angle: angle,\n            speed: interaction.prevEvent.speed,\n            velocity: {\n              x: interaction.prevEvent.velocityX,\n              y: interaction.prevEvent.velocityY\n            }\n          };\n        };\n\n        InteractEvent.prototype.preventDefault = function preventDefault() {};\n        /** */\n\n\n        InteractEvent.prototype.stopImmediatePropagation = function stopImmediatePropagation() {\n          this.immediatePropagationStopped = this.propagationStopped = true;\n        };\n        /** */\n\n\n        InteractEvent.prototype.stopPropagation = function stopPropagation() {\n          this.propagationStopped = true;\n        };\n\n        return InteractEvent;\n      }();\n\n      signals.on('set-delta', function (_ref) {\n        var iEvent = _ref.iEvent,\n            interaction = _ref.interaction,\n            starting = _ref.starting,\n            deltaSource = _ref.deltaSource;\n        var prevEvent = starting ? iEvent : interaction.prevEvent;\n\n        if (deltaSource === 'client') {\n          iEvent.dx = iEvent.clientX - prevEvent.clientX;\n          iEvent.dy = iEvent.clientY - prevEvent.clientY;\n        } else {\n          iEvent.dx = iEvent.pageX - prevEvent.pageX;\n          iEvent.dy = iEvent.pageY - prevEvent.pageY;\n        }\n      });\n      InteractEvent.signals = signals;\n      module.exports = InteractEvent;\n    }, {\n      \"./defaultOptions\": 18,\n      \"./utils/Signals\": 34,\n      \"./utils/extend\": 41,\n      \"./utils/getOriginXY\": 42\n    }],\n    4: [function (require, module, exports) {\n      'use strict';\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      var clone = require('./utils/clone');\n\n      var is = require('./utils/is');\n\n      var events = require('./utils/events');\n\n      var extend = require('./utils/extend');\n\n      var actions = require('./actions/base');\n\n      var scope = require('./scope');\n\n      var Eventable = require('./Eventable');\n\n      var defaults = require('./defaultOptions');\n\n      var signals = require('./utils/Signals').new();\n\n      var _require = require('./utils/domUtils'),\n          getElementRect = _require.getElementRect,\n          nodeContains = _require.nodeContains,\n          trySelector = _require.trySelector,\n          matchesSelector = _require.matchesSelector;\n\n      var _require2 = require('./utils/window'),\n          getWindow = _require2.getWindow;\n\n      var _require3 = require('./utils/arr'),\n          contains = _require3.contains;\n\n      var _require4 = require('./utils/browser'),\n          wheelEvent = _require4.wheelEvent; // all set interactables\n\n\n      scope.interactables = [];\n\n      var Interactable = function () {\n        /** */\n        function Interactable(target, options) {\n          _classCallCheck(this, Interactable);\n\n          options = options || {};\n          this.target = target;\n          this.events = new Eventable();\n          this._context = options.context || scope.document;\n          this._win = getWindow(trySelector(target) ? this._context : target);\n          this._doc = this._win.document;\n          signals.fire('new', {\n            target: target,\n            options: options,\n            interactable: this,\n            win: this._win\n          });\n          scope.addDocument(this._doc, this._win);\n          scope.interactables.push(this);\n          this.set(options);\n        }\n\n        Interactable.prototype.setOnEvents = function setOnEvents(action, phases) {\n          var onAction = 'on' + action;\n\n          if (is.function(phases.onstart)) {\n            this.events[onAction + 'start'] = phases.onstart;\n          }\n\n          if (is.function(phases.onmove)) {\n            this.events[onAction + 'move'] = phases.onmove;\n          }\n\n          if (is.function(phases.onend)) {\n            this.events[onAction + 'end'] = phases.onend;\n          }\n\n          if (is.function(phases.oninertiastart)) {\n            this.events[onAction + 'inertiastart'] = phases.oninertiastart;\n          }\n\n          return this;\n        };\n\n        Interactable.prototype.setPerAction = function setPerAction(action, options) {\n          // for all the default per-action options\n          for (var option in options) {\n            // if this option exists for this action\n            if (option in defaults[action]) {\n              // if the option in the options arg is an object value\n              if (is.object(options[option])) {\n                // duplicate the object and merge\n                this.options[action][option] = clone(this.options[action][option] || {});\n                extend(this.options[action][option], options[option]);\n\n                if (is.object(defaults.perAction[option]) && 'enabled' in defaults.perAction[option]) {\n                  this.options[action][option].enabled = options[option].enabled === false ? false : true;\n                }\n              } else if (is.bool(options[option]) && is.object(defaults.perAction[option])) {\n                this.options[action][option].enabled = options[option];\n              } else if (options[option] !== undefined) {\n                // or if it's not undefined, do a plain assignment\n                this.options[action][option] = options[option];\n              }\n            }\n          }\n        };\n        /**\n         * The default function to get an Interactables bounding rect. Can be\n         * overridden using {@link Interactable.rectChecker}.\n         *\n         * @param {Element} [element] The element to measure.\n         * @return {object} The object's bounding rectangle.\n         */\n\n\n        Interactable.prototype.getRect = function getRect(element) {\n          element = element || this.target;\n\n          if (is.string(this.target) && !is.element(element)) {\n            element = this._context.querySelector(this.target);\n          }\n\n          return getElementRect(element);\n        };\n        /**\n         * Returns or sets the function used to calculate the interactable's\n         * element's rectangle\n         *\n         * @param {function} [checker] A function which returns this Interactable's\n         * bounding rectangle. See {@link Interactable.getRect}\n         * @return {function | object} The checker function or this Interactable\n         */\n\n\n        Interactable.prototype.rectChecker = function rectChecker(checker) {\n          if (is.function(checker)) {\n            this.getRect = checker;\n            return this;\n          }\n\n          if (checker === null) {\n            delete this.options.getRect;\n            return this;\n          }\n\n          return this.getRect;\n        };\n\n        Interactable.prototype._backCompatOption = function _backCompatOption(optionName, newValue) {\n          if (trySelector(newValue) || is.object(newValue)) {\n            this.options[optionName] = newValue;\n\n            for (var _i = 0; _i < actions.names.length; _i++) {\n              var _ref;\n\n              _ref = actions.names[_i];\n              var action = _ref;\n              this.options[action][optionName] = newValue;\n            }\n\n            return this;\n          }\n\n          return this.options[optionName];\n        };\n        /**\n         * Gets or sets the origin of the Interactable's element.  The x and y\n         * of the origin will be subtracted from action event coordinates.\n         *\n         * @param {Element | object | string} [origin] An HTML or SVG Element whose\n         * rect will be used, an object eg. { x: 0, y: 0 } or string 'parent', 'self'\n         * or any CSS selector\n         *\n         * @return {object} The current origin or this Interactable\n         */\n\n\n        Interactable.prototype.origin = function origin(newValue) {\n          return this._backCompatOption('origin', newValue);\n        };\n        /**\n         * Returns or sets the mouse coordinate types used to calculate the\n         * movement of the pointer.\n         *\n         * @param {string} [newValue] Use 'client' if you will be scrolling while\n         * interacting; Use 'page' if you want autoScroll to work\n         * @return {string | object} The current deltaSource or this Interactable\n         */\n\n\n        Interactable.prototype.deltaSource = function deltaSource(newValue) {\n          if (newValue === 'page' || newValue === 'client') {\n            this.options.deltaSource = newValue;\n            return this;\n          }\n\n          return this.options.deltaSource;\n        };\n        /**\n         * Gets the selector context Node of the Interactable. The default is\n         * `window.document`.\n         *\n         * @return {Node} The context Node of this Interactable\n         */\n\n\n        Interactable.prototype.context = function context() {\n          return this._context;\n        };\n\n        Interactable.prototype.inContext = function inContext(element) {\n          return this._context === element.ownerDocument || nodeContains(this._context, element);\n        };\n        /**\n         * Calls listeners for the given InteractEvent type bound globally\n         * and directly to this Interactable\n         *\n         * @param {InteractEvent} iEvent The InteractEvent object to be fired on this\n         * Interactable\n         * @return {Interactable} this Interactable\n         */\n\n\n        Interactable.prototype.fire = function fire(iEvent) {\n          this.events.fire(iEvent);\n          return this;\n        };\n\n        Interactable.prototype._onOffMultiple = function _onOffMultiple(method, eventType, listener, options) {\n          if (is.string(eventType) && eventType.search(' ') !== -1) {\n            eventType = eventType.trim().split(/ +/);\n          }\n\n          if (is.array(eventType)) {\n            for (var _i2 = 0; _i2 < eventType.length; _i2++) {\n              var _ref2;\n\n              _ref2 = eventType[_i2];\n              var type = _ref2;\n              this[method](type, listener, options);\n            }\n\n            return true;\n          }\n\n          if (is.object(eventType)) {\n            for (var prop in eventType) {\n              this[method](prop, eventType[prop], listener);\n            }\n\n            return true;\n          }\n        };\n        /**\n         * Binds a listener for an InteractEvent, pointerEvent or DOM event.\n         *\n         * @param {string | array | object} eventType  The types of events to listen\n         * for\n         * @param {function} listener   The function event (s)\n         * @param {object | boolean} [options]    options object or useCapture flag\n         * for addEventListener\n         * @return {object} This Interactable\n         */\n\n\n        Interactable.prototype.on = function on(eventType, listener, options) {\n          if (this._onOffMultiple('on', eventType, listener, options)) {\n            return this;\n          }\n\n          if (eventType === 'wheel') {\n            eventType = wheelEvent;\n          }\n\n          if (contains(Interactable.eventTypes, eventType)) {\n            this.events.on(eventType, listener);\n          } // delegated event for selector\n          else if (is.string(this.target)) {\n              events.addDelegate(this.target, this._context, eventType, listener, options);\n            } else {\n              events.add(this.target, eventType, listener, options);\n            }\n\n          return this;\n        };\n        /**\n         * Removes an InteractEvent, pointerEvent or DOM event listener\n         *\n         * @param {string | array | object} eventType The types of events that were\n         * listened for\n         * @param {function} listener The listener function to be removed\n         * @param {object | boolean} [options] options object or useCapture flag for\n         * removeEventListener\n         * @return {object} This Interactable\n         */\n\n\n        Interactable.prototype.off = function off(eventType, listener, options) {\n          if (this._onOffMultiple('off', eventType, listener, options)) {\n            return this;\n          }\n\n          if (eventType === 'wheel') {\n            eventType = wheelEvent;\n          } // if it is an action event type\n\n\n          if (contains(Interactable.eventTypes, eventType)) {\n            this.events.off(eventType, listener);\n          } // delegated event\n          else if (is.string(this.target)) {\n              events.removeDelegate(this.target, this._context, eventType, listener, options);\n            } // remove listener from this Interatable's element\n            else {\n                events.remove(this.target, eventType, listener, options);\n              }\n\n          return this;\n        };\n        /**\n         * Reset the options of this Interactable\n         *\n         * @param {object} options The new settings to apply\n         * @return {object} This Interactable\n         */\n\n\n        Interactable.prototype.set = function set(options) {\n          if (!is.object(options)) {\n            options = {};\n          }\n\n          this.options = clone(defaults.base);\n          var perActions = clone(defaults.perAction);\n\n          for (var actionName in actions.methodDict) {\n            var methodName = actions.methodDict[actionName];\n            this.options[actionName] = clone(defaults[actionName]);\n            this.setPerAction(actionName, perActions);\n            this[methodName](options[actionName]);\n          }\n\n          for (var _i3 = 0; _i3 < Interactable.settingsMethods.length; _i3++) {\n            var _ref3;\n\n            _ref3 = Interactable.settingsMethods[_i3];\n            var setting = _ref3;\n            this.options[setting] = defaults.base[setting];\n\n            if (setting in options) {\n              this[setting](options[setting]);\n            }\n          }\n\n          signals.fire('set', {\n            options: options,\n            interactable: this\n          });\n          return this;\n        };\n        /**\n         * Remove this interactable from the list of interactables and remove it's\n         * action capabilities and event listeners\n         *\n         * @return {interact}\n         */\n\n\n        Interactable.prototype.unset = function unset() {\n          events.remove(this.target, 'all');\n\n          if (is.string(this.target)) {\n            // remove delegated events\n            for (var type in events.delegatedEvents) {\n              var delegated = events.delegatedEvents[type];\n\n              if (delegated.selectors[0] === this.target && delegated.contexts[0] === this._context) {\n                delegated.selectors.splice(0, 1);\n                delegated.contexts.splice(0, 1);\n                delegated.listeners.splice(0, 1); // remove the arrays if they are empty\n\n                if (!delegated.selectors.length) {\n                  delegated[type] = null;\n                }\n              }\n\n              events.remove(this._context, type, events.delegateListener);\n              events.remove(this._context, type, events.delegateUseCapture, true);\n            }\n          } else {\n            events.remove(this, 'all');\n          }\n\n          signals.fire('unset', {\n            interactable: this\n          });\n          scope.interactables.splice(scope.interactables.indexOf(this), 1); // Stop related interactions when an Interactable is unset\n\n          for (var _i4 = 0; _i4 < (scope.interactions || []).length; _i4++) {\n            var _ref4;\n\n            _ref4 = (scope.interactions || [])[_i4];\n            var interaction = _ref4;\n\n            if (interaction.target === this && interaction.interacting() && !interaction._ending) {\n              interaction.stop();\n            }\n          }\n\n          return scope.interact;\n        };\n\n        return Interactable;\n      }();\n\n      scope.interactables.indexOfElement = function indexOfElement(target, context) {\n        context = context || scope.document;\n\n        for (var i = 0; i < this.length; i++) {\n          var interactable = this[i];\n\n          if (interactable.target === target && interactable._context === context) {\n            return i;\n          }\n        }\n\n        return -1;\n      };\n\n      scope.interactables.get = function interactableGet(element, options, dontCheckInContext) {\n        var ret = this[this.indexOfElement(element, options && options.context)];\n        return ret && (is.string(element) || dontCheckInContext || ret.inContext(element)) ? ret : null;\n      };\n\n      scope.interactables.forEachMatch = function (element, callback) {\n        for (var _i5 = 0; _i5 < this.length; _i5++) {\n          var _ref5;\n\n          _ref5 = this[_i5];\n          var interactable = _ref5;\n          var ret = void 0;\n\n          if ((is.string(interactable.target) // target is a selector and the element matches\n          ? is.element(element) && matchesSelector(element, interactable.target) : // target is the element\n          element === interactable.target) && // the element is in context\n          interactable.inContext(element)) {\n            ret = callback(interactable);\n          }\n\n          if (ret !== undefined) {\n            return ret;\n          }\n        }\n      }; // all interact.js eventTypes\n\n\n      Interactable.eventTypes = scope.eventTypes = [];\n      Interactable.signals = signals;\n      Interactable.settingsMethods = ['deltaSource', 'origin', 'preventDefault', 'rectChecker'];\n      module.exports = Interactable;\n    }, {\n      \"./Eventable\": 2,\n      \"./actions/base\": 6,\n      \"./defaultOptions\": 18,\n      \"./scope\": 33,\n      \"./utils/Signals\": 34,\n      \"./utils/arr\": 35,\n      \"./utils/browser\": 36,\n      \"./utils/clone\": 37,\n      \"./utils/domUtils\": 39,\n      \"./utils/events\": 40,\n      \"./utils/extend\": 41,\n      \"./utils/is\": 46,\n      \"./utils/window\": 52\n    }],\n    5: [function (require, module, exports) {\n      'use strict';\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      var scope = require('./scope');\n\n      var utils = require('./utils');\n\n      var events = require('./utils/events');\n\n      var browser = require('./utils/browser');\n\n      var domObjects = require('./utils/domObjects');\n\n      var finder = require('./utils/interactionFinder');\n\n      var signals = require('./utils/Signals').new();\n\n      var listeners = {};\n      var methodNames = ['pointerDown', 'pointerMove', 'pointerUp', 'updatePointer', 'removePointer']; // for ignoring browser's simulated mouse events\n\n      var prevTouchTime = 0; // all active and idle interactions\n\n      scope.interactions = [];\n\n      var Interaction = function () {\n        /** */\n        function Interaction(_ref) {\n          var pointerType = _ref.pointerType;\n\n          _classCallCheck(this, Interaction);\n\n          this.target = null; // current interactable being interacted with\n\n          this.element = null; // the target element of the interactable\n\n          this.prepared = {\n            // action that's ready to be fired on next move event\n            name: null,\n            axis: null,\n            edges: null\n          }; // keep track of added pointers\n\n          this.pointers = [];\n          this.pointerIds = [];\n          this.downTargets = [];\n          this.downTimes = []; // Previous native pointer move event coordinates\n\n          this.prevCoords = {\n            page: {\n              x: 0,\n              y: 0\n            },\n            client: {\n              x: 0,\n              y: 0\n            },\n            timeStamp: 0\n          }; // current native pointer move event coordinates\n\n          this.curCoords = {\n            page: {\n              x: 0,\n              y: 0\n            },\n            client: {\n              x: 0,\n              y: 0\n            },\n            timeStamp: 0\n          }; // Starting InteractEvent pointer coordinates\n\n          this.startCoords = {\n            page: {\n              x: 0,\n              y: 0\n            },\n            client: {\n              x: 0,\n              y: 0\n            },\n            timeStamp: 0\n          }; // Change in coordinates and time of the pointer\n\n          this.pointerDelta = {\n            page: {\n              x: 0,\n              y: 0,\n              vx: 0,\n              vy: 0,\n              speed: 0\n            },\n            client: {\n              x: 0,\n              y: 0,\n              vx: 0,\n              vy: 0,\n              speed: 0\n            },\n            timeStamp: 0\n          };\n          this.downEvent = null; // pointerdown/mousedown/touchstart event\n\n          this.downPointer = {};\n          this._eventTarget = null;\n          this._curEventTarget = null;\n          this.prevEvent = null; // previous action event\n\n          this.pointerIsDown = false;\n          this.pointerWasMoved = false;\n          this._interacting = false;\n          this._ending = false;\n          this.pointerType = pointerType;\n          signals.fire('new', this);\n          scope.interactions.push(this);\n        }\n\n        Interaction.prototype.pointerDown = function pointerDown(pointer, event, eventTarget) {\n          var pointerIndex = this.updatePointer(pointer, event, true);\n          signals.fire('down', {\n            pointer: pointer,\n            event: event,\n            eventTarget: eventTarget,\n            pointerIndex: pointerIndex,\n            interaction: this\n          });\n        };\n        /**\n         * ```js\n         * interact(target)\n         *   .draggable({\n         *     // disable the default drag start by down->move\n         *     manualStart: true\n         *   })\n         *   // start dragging after the user holds the pointer down\n         *   .on('hold', function (event) {\n         *     var interaction = event.interaction;\n         *\n         *     if (!interaction.interacting()) {\n         *       interaction.start({ name: 'drag' },\n         *                         event.interactable,\n         *                         event.currentTarget);\n         *     }\n         * });\n         * ```\n         *\n         * Start an action with the given Interactable and Element as tartgets. The\n         * action must be enabled for the target Interactable and an appropriate\n         * number of pointers must be held down - 1 for drag/resize, 2 for gesture.\n         *\n         * Use it with `interactable.<action>able({ manualStart: false })` to always\n         * [start actions manually](https://github.com/taye/interact.js/issues/114)\n         *\n         * @param {object} action   The action to be performed - drag, resize, etc.\n         * @param {Interactable} target  The Interactable to target\n         * @param {Element} element The DOM Element to target\n         * @return {object} interact\n         */\n\n\n        Interaction.prototype.start = function start(action, target, element) {\n          if (this.interacting() || !this.pointerIsDown || this.pointerIds.length < (action.name === 'gesture' ? 2 : 1)) {\n            return;\n          } // if this interaction had been removed after stopping\n          // add it back\n\n\n          if (scope.interactions.indexOf(this) === -1) {\n            scope.interactions.push(this);\n          }\n\n          utils.copyAction(this.prepared, action);\n          this.target = target;\n          this.element = element;\n          signals.fire('action-start', {\n            interaction: this,\n            event: this.downEvent\n          });\n        };\n\n        Interaction.prototype.pointerMove = function pointerMove(pointer, event, eventTarget) {\n          if (!this.simulation) {\n            this.updatePointer(pointer);\n            utils.setCoords(this.curCoords, this.pointers);\n          }\n\n          var duplicateMove = this.curCoords.page.x === this.prevCoords.page.x && this.curCoords.page.y === this.prevCoords.page.y && this.curCoords.client.x === this.prevCoords.client.x && this.curCoords.client.y === this.prevCoords.client.y;\n          var dx = void 0;\n          var dy = void 0; // register movement greater than pointerMoveTolerance\n\n          if (this.pointerIsDown && !this.pointerWasMoved) {\n            dx = this.curCoords.client.x - this.startCoords.client.x;\n            dy = this.curCoords.client.y - this.startCoords.client.y;\n            this.pointerWasMoved = utils.hypot(dx, dy) > Interaction.pointerMoveTolerance;\n          }\n\n          var signalArg = {\n            pointer: pointer,\n            pointerIndex: this.getPointerIndex(pointer),\n            event: event,\n            eventTarget: eventTarget,\n            dx: dx,\n            dy: dy,\n            duplicate: duplicateMove,\n            interaction: this,\n            interactingBeforeMove: this.interacting()\n          };\n\n          if (!duplicateMove) {\n            // set pointer coordinate, time changes and speeds\n            utils.setCoordDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n          }\n\n          signals.fire('move', signalArg);\n\n          if (!duplicateMove) {\n            // if interacting, fire an 'action-move' signal etc\n            if (this.interacting()) {\n              this.doMove(signalArg);\n            }\n\n            if (this.pointerWasMoved) {\n              utils.copyCoords(this.prevCoords, this.curCoords);\n            }\n          }\n        };\n        /**\n         * ```js\n         * interact(target)\n         *   .draggable(true)\n         *   .on('dragmove', function (event) {\n         *     if (someCondition) {\n         *       // change the snap settings\n         *       event.interactable.draggable({ snap: { targets: [] }});\n         *       // fire another move event with re-calculated snap\n         *       event.interaction.doMove();\n         *     }\n         *   });\n         * ```\n         *\n         * Force a move of the current action at the same coordinates. Useful if\n         * snap/restrict has been changed and you want a movement with the new\n         * settings.\n         */\n\n\n        Interaction.prototype.doMove = function doMove(signalArg) {\n          signalArg = utils.extend({\n            pointer: this.pointers[0],\n            event: this.prevEvent,\n            eventTarget: this._eventTarget,\n            interaction: this\n          }, signalArg || {});\n          signals.fire('before-action-move', signalArg);\n\n          if (!this._dontFireMove) {\n            signals.fire('action-move', signalArg);\n          }\n\n          this._dontFireMove = false;\n        }; // End interact move events and stop auto-scroll unless simulation is running\n\n\n        Interaction.prototype.pointerUp = function pointerUp(pointer, event, eventTarget, curEventTarget) {\n          var pointerIndex = this.getPointerIndex(pointer);\n          signals.fire(/cancel$/i.test(event.type) ? 'cancel' : 'up', {\n            pointer: pointer,\n            pointerIndex: pointerIndex,\n            event: event,\n            eventTarget: eventTarget,\n            curEventTarget: curEventTarget,\n            interaction: this\n          });\n\n          if (!this.simulation) {\n            this.end(event);\n          }\n\n          this.pointerIsDown = false;\n          this.removePointer(pointer, event);\n        };\n        /**\n         * ```js\n         * interact(target)\n         *   .draggable(true)\n         *   .on('move', function (event) {\n         *     if (event.pageX > 1000) {\n         *       // end the current action\n         *       event.interaction.end();\n         *       // stop all further listeners from being called\n         *       event.stopImmediatePropagation();\n         *     }\n         *   });\n         * ```\n         *\n         * Stop the current action and fire an end event. Inertial movement does\n         * not happen.\n         *\n         * @param {PointerEvent} [event]\n         */\n\n\n        Interaction.prototype.end = function end(event) {\n          this._ending = true;\n          event = event || this.prevEvent;\n\n          if (this.interacting()) {\n            signals.fire('action-end', {\n              event: event,\n              interaction: this\n            });\n          }\n\n          this.stop();\n          this._ending = false;\n        };\n\n        Interaction.prototype.currentAction = function currentAction() {\n          return this._interacting ? this.prepared.name : null;\n        };\n\n        Interaction.prototype.interacting = function interacting() {\n          return this._interacting;\n        };\n        /** */\n\n\n        Interaction.prototype.stop = function stop() {\n          signals.fire('stop', {\n            interaction: this\n          });\n\n          if (this._interacting) {\n            signals.fire('stop-active', {\n              interaction: this\n            });\n            signals.fire('stop-' + this.prepared.name, {\n              interaction: this\n            });\n          }\n\n          this.target = this.element = null;\n          this._interacting = false;\n          this.prepared.name = this.prevEvent = null;\n        };\n\n        Interaction.prototype.getPointerIndex = function getPointerIndex(pointer) {\n          // mouse and pen interactions may have only one pointer\n          if (this.pointerType === 'mouse' || this.pointerType === 'pen') {\n            return 0;\n          }\n\n          return this.pointerIds.indexOf(utils.getPointerId(pointer));\n        };\n\n        Interaction.prototype.updatePointer = function updatePointer(pointer, event) {\n          var down = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : event && /(down|start)$/i.test(event.type);\n          var id = utils.getPointerId(pointer);\n          var index = this.getPointerIndex(pointer);\n\n          if (index === -1) {\n            index = this.pointerIds.length;\n            this.pointerIds[index] = id;\n          }\n\n          if (down) {\n            signals.fire('update-pointer-down', {\n              pointer: pointer,\n              event: event,\n              down: down,\n              pointerId: id,\n              pointerIndex: index,\n              interaction: this\n            });\n          }\n\n          this.pointers[index] = pointer;\n          return index;\n        };\n\n        Interaction.prototype.removePointer = function removePointer(pointer, event) {\n          var index = this.getPointerIndex(pointer);\n\n          if (index === -1) {\n            return;\n          }\n\n          signals.fire('remove-pointer', {\n            pointer: pointer,\n            event: event,\n            pointerIndex: index,\n            interaction: this\n          });\n          this.pointers.splice(index, 1);\n          this.pointerIds.splice(index, 1);\n          this.downTargets.splice(index, 1);\n          this.downTimes.splice(index, 1);\n        };\n\n        Interaction.prototype._updateEventTargets = function _updateEventTargets(target, currentTarget) {\n          this._eventTarget = target;\n          this._curEventTarget = currentTarget;\n        };\n\n        return Interaction;\n      }();\n\n      for (var _i = 0; _i < methodNames.length; _i++) {\n        var method = methodNames[_i];\n        listeners[method] = doOnInteractions(method);\n      }\n\n      function doOnInteractions(method) {\n        return function (event) {\n          var pointerType = utils.getPointerType(event);\n\n          var _utils$getEventTarget = utils.getEventTargets(event),\n              eventTarget = _utils$getEventTarget[0],\n              curEventTarget = _utils$getEventTarget[1];\n\n          var matches = []; // [ [pointer, interaction], ...]\n\n          if (browser.supportsTouch && /touch/.test(event.type)) {\n            prevTouchTime = new Date().getTime();\n\n            for (var _i2 = 0; _i2 < event.changedTouches.length; _i2++) {\n              var _ref2;\n\n              _ref2 = event.changedTouches[_i2];\n              var changedTouch = _ref2;\n              var pointer = changedTouch;\n              var interaction = finder.search(pointer, event.type, eventTarget);\n              matches.push([pointer, interaction || new Interaction({\n                pointerType: pointerType\n              })]);\n            }\n          } else {\n            var invalidPointer = false;\n\n            if (!browser.supportsPointerEvent && /mouse/.test(event.type)) {\n              // ignore mouse events while touch interactions are active\n              for (var i = 0; i < scope.interactions.length && !invalidPointer; i++) {\n                invalidPointer = scope.interactions[i].pointerType !== 'mouse' && scope.interactions[i].pointerIsDown;\n              } // try to ignore mouse events that are simulated by the browser\n              // after a touch event\n\n\n              invalidPointer = invalidPointer || new Date().getTime() - prevTouchTime < 500 // on iOS and Firefox Mobile, MouseEvent.timeStamp is zero if simulated\n              || event.timeStamp === 0;\n            }\n\n            if (!invalidPointer) {\n              var _interaction = finder.search(event, event.type, eventTarget);\n\n              if (!_interaction) {\n                _interaction = new Interaction({\n                  pointerType: pointerType\n                });\n              }\n\n              matches.push([event, _interaction]);\n            }\n          }\n\n          for (var _i3 = 0; _i3 < matches.length; _i3++) {\n            var _ref3 = matches[_i3];\n            var _pointer = _ref3[0];\n            var _interaction2 = _ref3[1];\n\n            _interaction2._updateEventTargets(eventTarget, curEventTarget);\n\n            _interaction2[method](_pointer, event, eventTarget, curEventTarget);\n          }\n        };\n      }\n\n      function endAll(event) {\n        for (var _i4 = 0; _i4 < scope.interactions.length; _i4++) {\n          var _ref4;\n\n          _ref4 = scope.interactions[_i4];\n          var interaction = _ref4;\n          interaction.end(event);\n          signals.fire('endall', {\n            event: event,\n            interaction: interaction\n          });\n        }\n      }\n\n      var docEvents = {\n        /* 'eventType': listenerFunc */\n      };\n      var pEventTypes = browser.pEventTypes;\n\n      if (domObjects.PointerEvent) {\n        docEvents[pEventTypes.down] = listeners.pointerDown;\n        docEvents[pEventTypes.move] = listeners.pointerMove;\n        docEvents[pEventTypes.up] = listeners.pointerUp;\n        docEvents[pEventTypes.cancel] = listeners.pointerUp;\n      } else {\n        docEvents.mousedown = listeners.pointerDown;\n        docEvents.mousemove = listeners.pointerMove;\n        docEvents.mouseup = listeners.pointerUp;\n        docEvents.touchstart = listeners.pointerDown;\n        docEvents.touchmove = listeners.pointerMove;\n        docEvents.touchend = listeners.pointerUp;\n        docEvents.touchcancel = listeners.pointerUp;\n      }\n\n      docEvents.blur = endAll;\n\n      function onDocSignal(_ref5, signalName) {\n        var doc = _ref5.doc;\n        var eventMethod = signalName.indexOf('add') === 0 ? events.add : events.remove; // delegate event listener\n\n        for (var eventType in scope.delegatedEvents) {\n          eventMethod(doc, eventType, events.delegateListener);\n          eventMethod(doc, eventType, events.delegateUseCapture, true);\n        }\n\n        for (var _eventType in docEvents) {\n          eventMethod(doc, _eventType, docEvents[_eventType], browser.isIOS ? {\n            passive: false\n          } : undefined);\n        }\n      }\n\n      signals.on('update-pointer-down', function (_ref6) {\n        var interaction = _ref6.interaction,\n            pointer = _ref6.pointer,\n            pointerId = _ref6.pointerId,\n            pointerIndex = _ref6.pointerIndex,\n            event = _ref6.event,\n            eventTarget = _ref6.eventTarget,\n            down = _ref6.down;\n        interaction.pointerIds[pointerIndex] = pointerId;\n        interaction.pointers[pointerIndex] = pointer;\n\n        if (down) {\n          interaction.pointerIsDown = true;\n        }\n\n        if (!interaction.interacting()) {\n          utils.setCoords(interaction.startCoords, interaction.pointers);\n          utils.copyCoords(interaction.curCoords, interaction.startCoords);\n          utils.copyCoords(interaction.prevCoords, interaction.startCoords);\n          interaction.downEvent = event;\n          interaction.downTimes[pointerIndex] = interaction.curCoords.timeStamp;\n          interaction.downTargets[pointerIndex] = eventTarget || event && utils.getEventTargets(event)[0];\n          interaction.pointerWasMoved = false;\n          utils.pointerExtend(interaction.downPointer, pointer);\n        }\n      });\n      scope.signals.on('add-document', onDocSignal);\n      scope.signals.on('remove-document', onDocSignal);\n      Interaction.pointerMoveTolerance = 1;\n      Interaction.doOnInteractions = doOnInteractions;\n      Interaction.endAll = endAll;\n      Interaction.signals = signals;\n      Interaction.docEvents = docEvents;\n      scope.endAllInteractions = endAll;\n      module.exports = Interaction;\n    }, {\n      \"./scope\": 33,\n      \"./utils\": 44,\n      \"./utils/Signals\": 34,\n      \"./utils/browser\": 36,\n      \"./utils/domObjects\": 38,\n      \"./utils/events\": 40,\n      \"./utils/interactionFinder\": 45\n    }],\n    6: [function (require, module, exports) {\n      'use strict';\n\n      var Interaction = require('../Interaction');\n\n      var InteractEvent = require('../InteractEvent');\n\n      var actions = {\n        firePrepared: firePrepared,\n        names: [],\n        methodDict: {}\n      };\n      Interaction.signals.on('action-start', function (_ref) {\n        var interaction = _ref.interaction,\n            event = _ref.event;\n        interaction._interacting = true;\n        firePrepared(interaction, event, 'start');\n      });\n      Interaction.signals.on('action-move', function (_ref2) {\n        var interaction = _ref2.interaction,\n            event = _ref2.event,\n            preEnd = _ref2.preEnd;\n        firePrepared(interaction, event, 'move', preEnd); // if the action was ended in a listener\n\n        if (!interaction.interacting()) {\n          return false;\n        }\n      });\n      Interaction.signals.on('action-end', function (_ref3) {\n        var interaction = _ref3.interaction,\n            event = _ref3.event;\n        firePrepared(interaction, event, 'end');\n      });\n\n      function firePrepared(interaction, event, phase, preEnd) {\n        var actionName = interaction.prepared.name;\n        var newEvent = new InteractEvent(interaction, event, actionName, phase, interaction.element, null, preEnd);\n        interaction.target.fire(newEvent);\n        interaction.prevEvent = newEvent;\n      }\n\n      module.exports = actions;\n    }, {\n      \"../InteractEvent\": 3,\n      \"../Interaction\": 5\n    }],\n    7: [function (require, module, exports) {\n      'use strict';\n\n      var actions = require('./base');\n\n      var utils = require('../utils');\n\n      var InteractEvent = require('../InteractEvent');\n      /** @lends Interactable */\n\n\n      var Interactable = require('../Interactable');\n\n      var Interaction = require('../Interaction');\n\n      var defaultOptions = require('../defaultOptions');\n\n      var drag = {\n        defaults: {\n          enabled: false,\n          mouseButtons: null,\n          origin: null,\n          snap: null,\n          restrict: null,\n          inertia: null,\n          autoScroll: null,\n          startAxis: 'xy',\n          lockAxis: 'xy'\n        },\n        checker: function checker(pointer, event, interactable) {\n          var dragOptions = interactable.options.drag;\n          return dragOptions.enabled ? {\n            name: 'drag',\n            axis: dragOptions.lockAxis === 'start' ? dragOptions.startAxis : dragOptions.lockAxis\n          } : null;\n        },\n        getCursor: function getCursor() {\n          return 'move';\n        }\n      };\n      Interaction.signals.on('before-action-move', function (_ref) {\n        var interaction = _ref.interaction;\n\n        if (interaction.prepared.name !== 'drag') {\n          return;\n        }\n\n        var axis = interaction.prepared.axis;\n\n        if (axis === 'x') {\n          interaction.curCoords.page.y = interaction.startCoords.page.y;\n          interaction.curCoords.client.y = interaction.startCoords.client.y;\n          interaction.pointerDelta.page.speed = Math.abs(interaction.pointerDelta.page.vx);\n          interaction.pointerDelta.client.speed = Math.abs(interaction.pointerDelta.client.vx);\n          interaction.pointerDelta.client.vy = 0;\n          interaction.pointerDelta.page.vy = 0;\n        } else if (axis === 'y') {\n          interaction.curCoords.page.x = interaction.startCoords.page.x;\n          interaction.curCoords.client.x = interaction.startCoords.client.x;\n          interaction.pointerDelta.page.speed = Math.abs(interaction.pointerDelta.page.vy);\n          interaction.pointerDelta.client.speed = Math.abs(interaction.pointerDelta.client.vy);\n          interaction.pointerDelta.client.vx = 0;\n          interaction.pointerDelta.page.vx = 0;\n        }\n      }); // dragmove\n\n      InteractEvent.signals.on('new', function (_ref2) {\n        var iEvent = _ref2.iEvent,\n            interaction = _ref2.interaction;\n\n        if (iEvent.type !== 'dragmove') {\n          return;\n        }\n\n        var axis = interaction.prepared.axis;\n\n        if (axis === 'x') {\n          iEvent.pageY = interaction.startCoords.page.y;\n          iEvent.clientY = interaction.startCoords.client.y;\n          iEvent.dy = 0;\n        } else if (axis === 'y') {\n          iEvent.pageX = interaction.startCoords.page.x;\n          iEvent.clientX = interaction.startCoords.client.x;\n          iEvent.dx = 0;\n        }\n      });\n      /**\n       * ```js\n       * interact(element).draggable({\n       *     onstart: function (event) {},\n       *     onmove : function (event) {},\n       *     onend  : function (event) {},\n       *\n       *     // the axis in which the first movement must be\n       *     // for the drag sequence to start\n       *     // 'xy' by default - any direction\n       *     startAxis: 'x' || 'y' || 'xy',\n       *\n       *     // 'xy' by default - don't restrict to one axis (move in any direction)\n       *     // 'x' or 'y' to restrict movement to either axis\n       *     // 'start' to restrict movement to the axis the drag started in\n       *     lockAxis: 'x' || 'y' || 'xy' || 'start',\n       *\n       *     // max number of drags that can happen concurrently\n       *     // with elements of this Interactable. Infinity by default\n       *     max: Infinity,\n       *\n       *     // max number of drags that can target the same element+Interactable\n       *     // 1 by default\n       *     maxPerElement: 2\n       * });\n       *\n       * var isDraggable = interact('element').draggable(); // true\n       * ```\n       *\n       * Get or set whether drag actions can be performed on the target\n       *\n       * @param {boolean | object} [options] true/false or An object with event\n       * listeners to be fired on drag events (object makes the Interactable\n       * draggable)\n       * @return {boolean | Interactable} boolean indicating if this can be the\n       * target of drag events, or this Interctable\n       */\n\n      Interactable.prototype.draggable = function (options) {\n        if (utils.is.object(options)) {\n          this.options.drag.enabled = options.enabled === false ? false : true;\n          this.setPerAction('drag', options);\n          this.setOnEvents('drag', options);\n\n          if (/^(xy|x|y|start)$/.test(options.lockAxis)) {\n            this.options.drag.lockAxis = options.lockAxis;\n          }\n\n          if (/^(xy|x|y)$/.test(options.startAxis)) {\n            this.options.drag.startAxis = options.startAxis;\n          }\n\n          return this;\n        }\n\n        if (utils.is.bool(options)) {\n          this.options.drag.enabled = options;\n\n          if (!options) {\n            this.ondragstart = this.ondragstart = this.ondragend = null;\n          }\n\n          return this;\n        }\n\n        return this.options.drag;\n      };\n\n      actions.drag = drag;\n      actions.names.push('drag');\n      utils.merge(Interactable.eventTypes, ['dragstart', 'dragmove', 'draginertiastart', 'draginertiaresume', 'dragend']);\n      actions.methodDict.drag = 'draggable';\n      defaultOptions.drag = drag.defaults;\n      module.exports = drag;\n    }, {\n      \"../InteractEvent\": 3,\n      \"../Interactable\": 4,\n      \"../Interaction\": 5,\n      \"../defaultOptions\": 18,\n      \"../utils\": 44,\n      \"./base\": 6\n    }],\n    8: [function (require, module, exports) {\n      'use strict';\n\n      var actions = require('./base');\n\n      var utils = require('../utils');\n\n      var scope = require('../scope');\n      /** @lends module:interact */\n\n\n      var interact = require('../interact');\n\n      var InteractEvent = require('../InteractEvent');\n      /** @lends Interactable */\n\n\n      var Interactable = require('../Interactable');\n\n      var Interaction = require('../Interaction');\n\n      var defaultOptions = require('../defaultOptions');\n\n      var drop = {\n        defaults: {\n          enabled: false,\n          accept: null,\n          overlap: 'pointer'\n        }\n      };\n      var dynamicDrop = false;\n      Interaction.signals.on('action-start', function (_ref) {\n        var interaction = _ref.interaction,\n            event = _ref.event;\n\n        if (interaction.prepared.name !== 'drag') {\n          return;\n        } // reset active dropzones\n\n\n        interaction.activeDrops.dropzones = [];\n        interaction.activeDrops.elements = [];\n        interaction.activeDrops.rects = [];\n        interaction.dropEvents = null;\n\n        if (!interaction.dynamicDrop) {\n          setActiveDrops(interaction.activeDrops, interaction.element);\n        }\n\n        var dragEvent = interaction.prevEvent;\n        var dropEvents = getDropEvents(interaction, event, dragEvent);\n\n        if (dropEvents.activate) {\n          fireActiveDrops(interaction.activeDrops, dropEvents.activate);\n        }\n      });\n      InteractEvent.signals.on('new', function (_ref2) {\n        var interaction = _ref2.interaction,\n            iEvent = _ref2.iEvent,\n            event = _ref2.event;\n\n        if (iEvent.type !== 'dragmove' && iEvent.type !== 'dragend') {\n          return;\n        }\n\n        var draggableElement = interaction.element;\n        var dragEvent = iEvent;\n        var dropResult = getDrop(dragEvent, event, draggableElement);\n        interaction.dropTarget = dropResult.dropzone;\n        interaction.dropElement = dropResult.element;\n        interaction.dropEvents = getDropEvents(interaction, event, dragEvent);\n      });\n      Interaction.signals.on('action-move', function (_ref3) {\n        var interaction = _ref3.interaction;\n\n        if (interaction.prepared.name !== 'drag') {\n          return;\n        }\n\n        fireDropEvents(interaction, interaction.dropEvents);\n      });\n      Interaction.signals.on('action-end', function (_ref4) {\n        var interaction = _ref4.interaction;\n\n        if (interaction.prepared.name === 'drag') {\n          fireDropEvents(interaction, interaction.dropEvents);\n        }\n      });\n      Interaction.signals.on('stop-drag', function (_ref5) {\n        var interaction = _ref5.interaction;\n        interaction.activeDrops = {\n          dropzones: null,\n          elements: null,\n          rects: null\n        };\n        interaction.dropEvents = null;\n      });\n\n      function collectDrops(activeDrops, element) {\n        var drops = [];\n        var elements = []; // collect all dropzones and their elements which qualify for a drop\n\n        for (var _i = 0; _i < scope.interactables.length; _i++) {\n          var _ref6;\n\n          _ref6 = scope.interactables[_i];\n          var current = _ref6;\n\n          if (!current.options.drop.enabled) {\n            continue;\n          }\n\n          var accept = current.options.drop.accept; // test the draggable element against the dropzone's accept setting\n\n          if (utils.is.element(accept) && accept !== element || utils.is.string(accept) && !utils.matchesSelector(element, accept)) {\n            continue;\n          } // query for new elements if necessary\n\n\n          var dropElements = utils.is.string(current.target) ? current._context.querySelectorAll(current.target) : [current.target];\n\n          for (var _i2 = 0; _i2 < dropElements.length; _i2++) {\n            var _ref7;\n\n            _ref7 = dropElements[_i2];\n            var currentElement = _ref7;\n\n            if (currentElement !== element) {\n              drops.push(current);\n              elements.push(currentElement);\n            }\n          }\n        }\n\n        return {\n          elements: elements,\n          dropzones: drops\n        };\n      }\n\n      function fireActiveDrops(activeDrops, event) {\n        var prevElement = void 0; // loop through all active dropzones and trigger event\n\n        for (var i = 0; i < activeDrops.dropzones.length; i++) {\n          var current = activeDrops.dropzones[i];\n          var currentElement = activeDrops.elements[i]; // prevent trigger of duplicate events on same element\n\n          if (currentElement !== prevElement) {\n            // set current element as event target\n            event.target = currentElement;\n            current.fire(event);\n          }\n\n          prevElement = currentElement;\n        }\n      } // Collect a new set of possible drops and save them in activeDrops.\n      // setActiveDrops should always be called when a drag has just started or a\n      // drag event happens while dynamicDrop is true\n\n\n      function setActiveDrops(activeDrops, dragElement) {\n        // get dropzones and their elements that could receive the draggable\n        var possibleDrops = collectDrops(activeDrops, dragElement);\n        activeDrops.dropzones = possibleDrops.dropzones;\n        activeDrops.elements = possibleDrops.elements;\n        activeDrops.rects = [];\n\n        for (var i = 0; i < activeDrops.dropzones.length; i++) {\n          activeDrops.rects[i] = activeDrops.dropzones[i].getRect(activeDrops.elements[i]);\n        }\n      }\n\n      function getDrop(dragEvent, event, dragElement) {\n        var interaction = dragEvent.interaction;\n        var validDrops = [];\n\n        if (dynamicDrop) {\n          setActiveDrops(interaction.activeDrops, dragElement);\n        } // collect all dropzones and their elements which qualify for a drop\n\n\n        for (var j = 0; j < interaction.activeDrops.dropzones.length; j++) {\n          var current = interaction.activeDrops.dropzones[j];\n          var currentElement = interaction.activeDrops.elements[j];\n          var rect = interaction.activeDrops.rects[j];\n          validDrops.push(current.dropCheck(dragEvent, event, interaction.target, dragElement, currentElement, rect) ? currentElement : null);\n        } // get the most appropriate dropzone based on DOM depth and order\n\n\n        var dropIndex = utils.indexOfDeepestElement(validDrops);\n        return {\n          dropzone: interaction.activeDrops.dropzones[dropIndex] || null,\n          element: interaction.activeDrops.elements[dropIndex] || null\n        };\n      }\n\n      function getDropEvents(interaction, pointerEvent, dragEvent) {\n        var dropEvents = {\n          enter: null,\n          leave: null,\n          activate: null,\n          deactivate: null,\n          move: null,\n          drop: null\n        };\n        var tmpl = {\n          dragEvent: dragEvent,\n          interaction: interaction,\n          target: interaction.dropElement,\n          dropzone: interaction.dropTarget,\n          relatedTarget: dragEvent.target,\n          draggable: dragEvent.interactable,\n          timeStamp: dragEvent.timeStamp\n        };\n\n        if (interaction.dropElement !== interaction.prevDropElement) {\n          // if there was a prevDropTarget, create a dragleave event\n          if (interaction.prevDropTarget) {\n            dropEvents.leave = utils.extend({\n              type: 'dragleave'\n            }, tmpl);\n            dragEvent.dragLeave = dropEvents.leave.target = interaction.prevDropElement;\n            dragEvent.prevDropzone = dropEvents.leave.dropzone = interaction.prevDropTarget;\n          } // if the dropTarget is not null, create a dragenter event\n\n\n          if (interaction.dropTarget) {\n            dropEvents.enter = {\n              dragEvent: dragEvent,\n              interaction: interaction,\n              target: interaction.dropElement,\n              dropzone: interaction.dropTarget,\n              relatedTarget: dragEvent.target,\n              draggable: dragEvent.interactable,\n              timeStamp: dragEvent.timeStamp,\n              type: 'dragenter'\n            };\n            dragEvent.dragEnter = interaction.dropElement;\n            dragEvent.dropzone = interaction.dropTarget;\n          }\n        }\n\n        if (dragEvent.type === 'dragend' && interaction.dropTarget) {\n          dropEvents.drop = utils.extend({\n            type: 'drop'\n          }, tmpl);\n          dragEvent.dropzone = interaction.dropTarget;\n          dragEvent.relatedTarget = interaction.dropElement;\n        }\n\n        if (dragEvent.type === 'dragstart') {\n          dropEvents.activate = utils.extend({\n            type: 'dropactivate'\n          }, tmpl);\n          dropEvents.activate.target = null;\n          dropEvents.activate.dropzone = null;\n        }\n\n        if (dragEvent.type === 'dragend') {\n          dropEvents.deactivate = utils.extend({\n            type: 'dropdeactivate'\n          }, tmpl);\n          dropEvents.deactivate.target = null;\n          dropEvents.deactivate.dropzone = null;\n        }\n\n        if (dragEvent.type === 'dragmove' && interaction.dropTarget) {\n          dropEvents.move = utils.extend({\n            dragmove: dragEvent,\n            type: 'dropmove'\n          }, tmpl);\n          dragEvent.dropzone = interaction.dropTarget;\n        }\n\n        return dropEvents;\n      }\n\n      function fireDropEvents(interaction, dropEvents) {\n        var activeDrops = interaction.activeDrops,\n            prevDropTarget = interaction.prevDropTarget,\n            dropTarget = interaction.dropTarget,\n            dropElement = interaction.dropElement;\n\n        if (dropEvents.leave) {\n          prevDropTarget.fire(dropEvents.leave);\n        }\n\n        if (dropEvents.move) {\n          dropTarget.fire(dropEvents.move);\n        }\n\n        if (dropEvents.enter) {\n          dropTarget.fire(dropEvents.enter);\n        }\n\n        if (dropEvents.drop) {\n          dropTarget.fire(dropEvents.drop);\n        }\n\n        if (dropEvents.deactivate) {\n          fireActiveDrops(activeDrops, dropEvents.deactivate);\n        }\n\n        interaction.prevDropTarget = dropTarget;\n        interaction.prevDropElement = dropElement;\n      }\n      /**\n       * ```js\n       * interact(target)\n       * .dropChecker(function(dragEvent,         // related dragmove or dragend event\n       *                       event,             // TouchEvent/PointerEvent/MouseEvent\n       *                       dropped,           // bool result of the default checker\n       *                       dropzone,          // dropzone Interactable\n       *                       dropElement,       // dropzone elemnt\n       *                       draggable,         // draggable Interactable\n       *                       draggableElement) {// draggable element\n       *\n       *   return dropped && event.target.hasAttribute('allow-drop');\n       * }\n       * ```\n       *\n       * ```js\n       * interact('.drop').dropzone({\n       *   accept: '.can-drop' || document.getElementById('single-drop'),\n       *   overlap: 'pointer' || 'center' || zeroToOne\n       * }\n       * ```\n       *\n       * Returns or sets whether draggables can be dropped onto this target to\n       * trigger drop events\n       *\n       * Dropzones can receive the following events:\n       *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends\n       *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone\n       *  - `dragmove` when a draggable that has entered the dropzone is moved\n       *  - `drop` when a draggable is dropped into this dropzone\n       *\n       * Use the `accept` option to allow only elements that match the given CSS\n       * selector or element. The value can be:\n       *\n       *  - **an Element** - only that element can be dropped into this dropzone.\n       *  - **a string**, - the element being dragged must match it as a CSS selector.\n       *  - **`null`** - accept options is cleared - it accepts any element.\n       *\n       * Use the `overlap` option to set how drops are checked for. The allowed\n       * values are:\n       *\n       *   - `'pointer'`, the pointer must be over the dropzone (default)\n       *   - `'center'`, the draggable element's center must be over the dropzone\n       *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.\n       *   e.g. `0.5` for drop to happen when half of the area of the draggable is\n       *   over the dropzone\n       *\n       * Use the `checker` option to specify a function to check if a dragged element\n       * is over this Interactable.\n       *\n       * @param {boolean | object | null} [options] The new options to be set.\n       * @return {boolean | Interactable} The current setting or this Interactable\n       */\n\n\n      Interactable.prototype.dropzone = function (options) {\n        if (utils.is.object(options)) {\n          this.options.drop.enabled = options.enabled === false ? false : true;\n\n          if (utils.is.function(options.ondrop)) {\n            this.events.ondrop = options.ondrop;\n          }\n\n          if (utils.is.function(options.ondropactivate)) {\n            this.events.ondropactivate = options.ondropactivate;\n          }\n\n          if (utils.is.function(options.ondropdeactivate)) {\n            this.events.ondropdeactivate = options.ondropdeactivate;\n          }\n\n          if (utils.is.function(options.ondragenter)) {\n            this.events.ondragenter = options.ondragenter;\n          }\n\n          if (utils.is.function(options.ondragleave)) {\n            this.events.ondragleave = options.ondragleave;\n          }\n\n          if (utils.is.function(options.ondropmove)) {\n            this.events.ondropmove = options.ondropmove;\n          }\n\n          if (/^(pointer|center)$/.test(options.overlap)) {\n            this.options.drop.overlap = options.overlap;\n          } else if (utils.is.number(options.overlap)) {\n            this.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0);\n          }\n\n          if ('accept' in options) {\n            this.options.drop.accept = options.accept;\n          }\n\n          if ('checker' in options) {\n            this.options.drop.checker = options.checker;\n          }\n\n          return this;\n        }\n\n        if (utils.is.bool(options)) {\n          this.options.drop.enabled = options;\n\n          if (!options) {\n            this.ondragenter = this.ondragleave = this.ondrop = this.ondropactivate = this.ondropdeactivate = null;\n          }\n\n          return this;\n        }\n\n        return this.options.drop;\n      };\n\n      Interactable.prototype.dropCheck = function (dragEvent, event, draggable, draggableElement, dropElement, rect) {\n        var dropped = false; // if the dropzone has no rect (eg. display: none)\n        // call the custom dropChecker or just return false\n\n        if (!(rect = rect || this.getRect(dropElement))) {\n          return this.options.drop.checker ? this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement) : false;\n        }\n\n        var dropOverlap = this.options.drop.overlap;\n\n        if (dropOverlap === 'pointer') {\n          var origin = utils.getOriginXY(draggable, draggableElement, 'drag');\n          var page = utils.getPageXY(dragEvent);\n          page.x += origin.x;\n          page.y += origin.y;\n          var horizontal = page.x > rect.left && page.x < rect.right;\n          var vertical = page.y > rect.top && page.y < rect.bottom;\n          dropped = horizontal && vertical;\n        }\n\n        var dragRect = draggable.getRect(draggableElement);\n\n        if (dragRect && dropOverlap === 'center') {\n          var cx = dragRect.left + dragRect.width / 2;\n          var cy = dragRect.top + dragRect.height / 2;\n          dropped = cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom;\n        }\n\n        if (dragRect && utils.is.number(dropOverlap)) {\n          var overlapArea = Math.max(0, Math.min(rect.right, dragRect.right) - Math.max(rect.left, dragRect.left)) * Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top, dragRect.top));\n          var overlapRatio = overlapArea / (dragRect.width * dragRect.height);\n          dropped = overlapRatio >= dropOverlap;\n        }\n\n        if (this.options.drop.checker) {\n          dropped = this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement);\n        }\n\n        return dropped;\n      };\n\n      Interactable.signals.on('unset', function (_ref8) {\n        var interactable = _ref8.interactable;\n        interactable.dropzone(false);\n      });\n      Interactable.settingsMethods.push('dropChecker');\n      Interaction.signals.on('new', function (interaction) {\n        interaction.dropTarget = null; // the dropzone a drag target might be dropped into\n\n        interaction.dropElement = null; // the element at the time of checking\n\n        interaction.prevDropTarget = null; // the dropzone that was recently dragged away from\n\n        interaction.prevDropElement = null; // the element at the time of checking\n\n        interaction.dropEvents = null; // the dropEvents related to the current drag event\n\n        interaction.activeDrops = {\n          dropzones: [],\n          // the dropzones that are mentioned below\n          elements: [],\n          // elements of dropzones that accept the target draggable\n          rects: [] // the rects of the elements mentioned above\n\n        };\n      });\n      Interaction.signals.on('stop', function (_ref9) {\n        var interaction = _ref9.interaction;\n        interaction.dropTarget = interaction.dropElement = interaction.prevDropTarget = interaction.prevDropElement = null;\n      });\n      /**\n       * Returns or sets whether the dimensions of dropzone elements are calculated\n       * on every dragmove or only on dragstart for the default dropChecker\n       *\n       * @param {boolean} [newValue] True to check on each move. False to check only\n       * before start\n       * @return {boolean | interact} The current setting or interact\n       */\n\n      interact.dynamicDrop = function (newValue) {\n        if (utils.is.bool(newValue)) {\n          //if (dragging && dynamicDrop !== newValue && !newValue) {\n          //calcRects(dropzones);\n          //}\n          dynamicDrop = newValue;\n          return interact;\n        }\n\n        return dynamicDrop;\n      };\n\n      utils.merge(Interactable.eventTypes, ['dragenter', 'dragleave', 'dropactivate', 'dropdeactivate', 'dropmove', 'drop']);\n      actions.methodDict.drop = 'dropzone';\n      defaultOptions.drop = drop.defaults;\n      module.exports = drop;\n    }, {\n      \"../InteractEvent\": 3,\n      \"../Interactable\": 4,\n      \"../Interaction\": 5,\n      \"../defaultOptions\": 18,\n      \"../interact\": 21,\n      \"../scope\": 33,\n      \"../utils\": 44,\n      \"./base\": 6\n    }],\n    9: [function (require, module, exports) {\n      'use strict';\n\n      var actions = require('./base');\n\n      var utils = require('../utils');\n\n      var InteractEvent = require('../InteractEvent');\n\n      var Interactable = require('../Interactable');\n\n      var Interaction = require('../Interaction');\n\n      var defaultOptions = require('../defaultOptions');\n\n      var gesture = {\n        defaults: {\n          enabled: false,\n          origin: null,\n          restrict: null\n        },\n        checker: function checker(pointer, event, interactable, element, interaction) {\n          if (interaction.pointerIds.length >= 2) {\n            return {\n              name: 'gesture'\n            };\n          }\n\n          return null;\n        },\n        getCursor: function getCursor() {\n          return '';\n        }\n      };\n      InteractEvent.signals.on('new', function (_ref) {\n        var iEvent = _ref.iEvent,\n            interaction = _ref.interaction;\n\n        if (iEvent.type !== 'gesturestart') {\n          return;\n        }\n\n        iEvent.ds = 0;\n        interaction.gesture.startDistance = interaction.gesture.prevDistance = iEvent.distance;\n        interaction.gesture.startAngle = interaction.gesture.prevAngle = iEvent.angle;\n        interaction.gesture.scale = 1;\n      });\n      InteractEvent.signals.on('new', function (_ref2) {\n        var iEvent = _ref2.iEvent,\n            interaction = _ref2.interaction;\n\n        if (iEvent.type !== 'gesturemove') {\n          return;\n        }\n\n        iEvent.ds = iEvent.scale - interaction.gesture.scale;\n        interaction.target.fire(iEvent);\n        interaction.gesture.prevAngle = iEvent.angle;\n        interaction.gesture.prevDistance = iEvent.distance;\n\n        if (iEvent.scale !== Infinity && iEvent.scale !== null && iEvent.scale !== undefined && !isNaN(iEvent.scale)) {\n          interaction.gesture.scale = iEvent.scale;\n        }\n      });\n      /**\n       * ```js\n       * interact(element).gesturable({\n       *     onstart: function (event) {},\n       *     onmove : function (event) {},\n       *     onend  : function (event) {},\n       *\n       *     // limit multiple gestures.\n       *     // See the explanation in {@link Interactable.draggable} example\n       *     max: Infinity,\n       *     maxPerElement: 1,\n       * });\n       *\n       * var isGestureable = interact(element).gesturable();\n       * ```\n       *\n       * Gets or sets whether multitouch gestures can be performed on the target\n       *\n       * @param {boolean | object} [options] true/false or An object with event\n       * listeners to be fired on gesture events (makes the Interactable gesturable)\n       * @return {boolean | Interactable} A boolean indicating if this can be the\n       * target of gesture events, or this Interactable\n       */\n\n      Interactable.prototype.gesturable = function (options) {\n        if (utils.is.object(options)) {\n          this.options.gesture.enabled = options.enabled === false ? false : true;\n          this.setPerAction('gesture', options);\n          this.setOnEvents('gesture', options);\n          return this;\n        }\n\n        if (utils.is.bool(options)) {\n          this.options.gesture.enabled = options;\n\n          if (!options) {\n            this.ongesturestart = this.ongesturestart = this.ongestureend = null;\n          }\n\n          return this;\n        }\n\n        return this.options.gesture;\n      };\n\n      InteractEvent.signals.on('set-delta', function (_ref3) {\n        var interaction = _ref3.interaction,\n            iEvent = _ref3.iEvent,\n            action = _ref3.action,\n            event = _ref3.event,\n            starting = _ref3.starting,\n            ending = _ref3.ending,\n            deltaSource = _ref3.deltaSource;\n\n        if (action !== 'gesture') {\n          return;\n        }\n\n        var pointers = interaction.pointers;\n        iEvent.touches = [pointers[0], pointers[1]];\n\n        if (starting) {\n          iEvent.distance = utils.touchDistance(pointers, deltaSource);\n          iEvent.box = utils.touchBBox(pointers);\n          iEvent.scale = 1;\n          iEvent.ds = 0;\n          iEvent.angle = utils.touchAngle(pointers, undefined, deltaSource);\n          iEvent.da = 0;\n        } else if (ending || event instanceof InteractEvent) {\n          iEvent.distance = interaction.prevEvent.distance;\n          iEvent.box = interaction.prevEvent.box;\n          iEvent.scale = interaction.prevEvent.scale;\n          iEvent.ds = iEvent.scale - 1;\n          iEvent.angle = interaction.prevEvent.angle;\n          iEvent.da = iEvent.angle - interaction.gesture.startAngle;\n        } else {\n          iEvent.distance = utils.touchDistance(pointers, deltaSource);\n          iEvent.box = utils.touchBBox(pointers);\n          iEvent.scale = iEvent.distance / interaction.gesture.startDistance;\n          iEvent.angle = utils.touchAngle(pointers, interaction.gesture.prevAngle, deltaSource);\n          iEvent.ds = iEvent.scale - interaction.gesture.prevScale;\n          iEvent.da = iEvent.angle - interaction.gesture.prevAngle;\n        }\n      });\n      Interaction.signals.on('new', function (interaction) {\n        interaction.gesture = {\n          start: {\n            x: 0,\n            y: 0\n          },\n          startDistance: 0,\n          // distance between two touches of touchStart\n          prevDistance: 0,\n          distance: 0,\n          scale: 1,\n          // gesture.distance / gesture.startDistance\n          startAngle: 0,\n          // angle of line joining two touches\n          prevAngle: 0 // angle of the previous gesture event\n\n        };\n      });\n      actions.gesture = gesture;\n      actions.names.push('gesture');\n      utils.merge(Interactable.eventTypes, ['gesturestart', 'gesturemove', 'gestureend']);\n      actions.methodDict.gesture = 'gesturable';\n      defaultOptions.gesture = gesture.defaults;\n      module.exports = gesture;\n    }, {\n      \"../InteractEvent\": 3,\n      \"../Interactable\": 4,\n      \"../Interaction\": 5,\n      \"../defaultOptions\": 18,\n      \"../utils\": 44,\n      \"./base\": 6\n    }],\n    10: [function (require, module, exports) {\n      'use strict';\n\n      var actions = require('./base');\n\n      var utils = require('../utils');\n\n      var browser = require('../utils/browser');\n\n      var InteractEvent = require('../InteractEvent');\n      /** @lends Interactable */\n\n\n      var Interactable = require('../Interactable');\n\n      var Interaction = require('../Interaction');\n\n      var defaultOptions = require('../defaultOptions'); // Less Precision with touch input\n\n\n      var defaultMargin = browser.supportsTouch || browser.supportsPointerEvent ? 20 : 10;\n      var resize = {\n        defaults: {\n          enabled: false,\n          mouseButtons: null,\n          origin: null,\n          snap: null,\n          restrict: null,\n          inertia: null,\n          autoScroll: null,\n          square: false,\n          preserveAspectRatio: false,\n          axis: 'xy',\n          // use default margin\n          margin: NaN,\n          // object with props left, right, top, bottom which are\n          // true/false values to resize when the pointer is over that edge,\n          // CSS selectors to match the handles for each direction\n          // or the Elements for each handle\n          edges: null,\n          // a value of 'none' will limit the resize rect to a minimum of 0x0\n          // 'negate' will alow the rect to have negative width/height\n          // 'reposition' will keep the width/height positive by swapping\n          // the top and bottom edges and/or swapping the left and right edges\n          invert: 'none'\n        },\n        checker: function checker(pointer, event, interactable, element, interaction, rect) {\n          if (!rect) {\n            return null;\n          }\n\n          var page = utils.extend({}, interaction.curCoords.page);\n          var options = interactable.options;\n\n          if (options.resize.enabled) {\n            var resizeOptions = options.resize;\n            var resizeEdges = {\n              left: false,\n              right: false,\n              top: false,\n              bottom: false\n            }; // if using resize.edges\n\n            if (utils.is.object(resizeOptions.edges)) {\n              for (var edge in resizeEdges) {\n                resizeEdges[edge] = checkResizeEdge(edge, resizeOptions.edges[edge], page, interaction._eventTarget, element, rect, resizeOptions.margin || defaultMargin);\n              }\n\n              resizeEdges.left = resizeEdges.left && !resizeEdges.right;\n              resizeEdges.top = resizeEdges.top && !resizeEdges.bottom;\n\n              if (resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom) {\n                return {\n                  name: 'resize',\n                  edges: resizeEdges\n                };\n              }\n            } else {\n              var right = options.resize.axis !== 'y' && page.x > rect.right - defaultMargin;\n              var bottom = options.resize.axis !== 'x' && page.y > rect.bottom - defaultMargin;\n\n              if (right || bottom) {\n                return {\n                  name: 'resize',\n                  axes: (right ? 'x' : '') + (bottom ? 'y' : '')\n                };\n              }\n            }\n          }\n\n          return null;\n        },\n        cursors: browser.isIe9 ? {\n          x: 'e-resize',\n          y: 's-resize',\n          xy: 'se-resize',\n          top: 'n-resize',\n          left: 'w-resize',\n          bottom: 's-resize',\n          right: 'e-resize',\n          topleft: 'se-resize',\n          bottomright: 'se-resize',\n          topright: 'ne-resize',\n          bottomleft: 'ne-resize'\n        } : {\n          x: 'ew-resize',\n          y: 'ns-resize',\n          xy: 'nwse-resize',\n          top: 'ns-resize',\n          left: 'ew-resize',\n          bottom: 'ns-resize',\n          right: 'ew-resize',\n          topleft: 'nwse-resize',\n          bottomright: 'nwse-resize',\n          topright: 'nesw-resize',\n          bottomleft: 'nesw-resize'\n        },\n        getCursor: function getCursor(action) {\n          if (action.axis) {\n            return resize.cursors[action.name + action.axis];\n          } else if (action.edges) {\n            var cursorKey = '';\n            var edgeNames = ['top', 'bottom', 'left', 'right'];\n\n            for (var i = 0; i < 4; i++) {\n              if (action.edges[edgeNames[i]]) {\n                cursorKey += edgeNames[i];\n              }\n            }\n\n            return resize.cursors[cursorKey];\n          }\n        }\n      }; // resizestart\n\n      InteractEvent.signals.on('new', function (_ref) {\n        var iEvent = _ref.iEvent,\n            interaction = _ref.interaction;\n\n        if (iEvent.type !== 'resizestart' || !interaction.prepared.edges) {\n          return;\n        }\n\n        var startRect = interaction.target.getRect(interaction.element);\n        var resizeOptions = interaction.target.options.resize;\n        /*\n         * When using the `resizable.square` or `resizable.preserveAspectRatio` options, resizing from one edge\n         * will affect another. E.g. with `resizable.square`, resizing to make the right edge larger will make\n         * the bottom edge larger by the same amount. We call these 'linked' edges. Any linked edges will depend\n         * on the active edges and the edge being interacted with.\n         */\n\n        if (resizeOptions.square || resizeOptions.preserveAspectRatio) {\n          var linkedEdges = utils.extend({}, interaction.prepared.edges);\n          linkedEdges.top = linkedEdges.top || linkedEdges.left && !linkedEdges.bottom;\n          linkedEdges.left = linkedEdges.left || linkedEdges.top && !linkedEdges.right;\n          linkedEdges.bottom = linkedEdges.bottom || linkedEdges.right && !linkedEdges.top;\n          linkedEdges.right = linkedEdges.right || linkedEdges.bottom && !linkedEdges.left;\n          interaction.prepared._linkedEdges = linkedEdges;\n        } else {\n          interaction.prepared._linkedEdges = null;\n        } // if using `resizable.preserveAspectRatio` option, record aspect ratio at the start of the resize\n\n\n        if (resizeOptions.preserveAspectRatio) {\n          interaction.resizeStartAspectRatio = startRect.width / startRect.height;\n        }\n\n        interaction.resizeRects = {\n          start: startRect,\n          current: utils.extend({}, startRect),\n          inverted: utils.extend({}, startRect),\n          previous: utils.extend({}, startRect),\n          delta: {\n            left: 0,\n            right: 0,\n            width: 0,\n            top: 0,\n            bottom: 0,\n            height: 0\n          }\n        };\n        iEvent.rect = interaction.resizeRects.inverted;\n        iEvent.deltaRect = interaction.resizeRects.delta;\n      }); // resizemove\n\n      InteractEvent.signals.on('new', function (_ref2) {\n        var iEvent = _ref2.iEvent,\n            phase = _ref2.phase,\n            interaction = _ref2.interaction;\n\n        if (phase !== 'move' || !interaction.prepared.edges) {\n          return;\n        }\n\n        var resizeOptions = interaction.target.options.resize;\n        var invert = resizeOptions.invert;\n        var invertible = invert === 'reposition' || invert === 'negate';\n        var edges = interaction.prepared.edges;\n        var start = interaction.resizeRects.start;\n        var current = interaction.resizeRects.current;\n        var inverted = interaction.resizeRects.inverted;\n        var delta = interaction.resizeRects.delta;\n        var previous = utils.extend(interaction.resizeRects.previous, inverted);\n        var originalEdges = edges;\n        var dx = iEvent.dx;\n        var dy = iEvent.dy;\n\n        if (resizeOptions.preserveAspectRatio || resizeOptions.square) {\n          // `resize.preserveAspectRatio` takes precedence over `resize.square`\n          var startAspectRatio = resizeOptions.preserveAspectRatio ? interaction.resizeStartAspectRatio : 1;\n          edges = interaction.prepared._linkedEdges;\n\n          if (originalEdges.left && originalEdges.bottom || originalEdges.right && originalEdges.top) {\n            dy = -dx / startAspectRatio;\n          } else if (originalEdges.left || originalEdges.right) {\n            dy = dx / startAspectRatio;\n          } else if (originalEdges.top || originalEdges.bottom) {\n            dx = dy * startAspectRatio;\n          }\n        } // update the 'current' rect without modifications\n\n\n        if (edges.top) {\n          current.top += dy;\n        }\n\n        if (edges.bottom) {\n          current.bottom += dy;\n        }\n\n        if (edges.left) {\n          current.left += dx;\n        }\n\n        if (edges.right) {\n          current.right += dx;\n        }\n\n        if (invertible) {\n          // if invertible, copy the current rect\n          utils.extend(inverted, current);\n\n          if (invert === 'reposition') {\n            // swap edge values if necessary to keep width/height positive\n            var swap = void 0;\n\n            if (inverted.top > inverted.bottom) {\n              swap = inverted.top;\n              inverted.top = inverted.bottom;\n              inverted.bottom = swap;\n            }\n\n            if (inverted.left > inverted.right) {\n              swap = inverted.left;\n              inverted.left = inverted.right;\n              inverted.right = swap;\n            }\n          }\n        } else {\n          // if not invertible, restrict to minimum of 0x0 rect\n          inverted.top = Math.min(current.top, start.bottom);\n          inverted.bottom = Math.max(current.bottom, start.top);\n          inverted.left = Math.min(current.left, start.right);\n          inverted.right = Math.max(current.right, start.left);\n        }\n\n        inverted.width = inverted.right - inverted.left;\n        inverted.height = inverted.bottom - inverted.top;\n\n        for (var edge in inverted) {\n          delta[edge] = inverted[edge] - previous[edge];\n        }\n\n        iEvent.edges = interaction.prepared.edges;\n        iEvent.rect = inverted;\n        iEvent.deltaRect = delta;\n      });\n      /**\n       * ```js\n       * interact(element).resizable({\n       *   onstart: function (event) {},\n       *   onmove : function (event) {},\n       *   onend  : function (event) {},\n       *\n       *   edges: {\n       *     top   : true,       // Use pointer coords to check for resize.\n       *     left  : false,      // Disable resizing from left edge.\n       *     bottom: '.resize-s',// Resize if pointer target matches selector\n       *     right : handleEl    // Resize if pointer target is the given Element\n       *   },\n       *\n       *     // Width and height can be adjusted independently. When `true`, width and\n       *     // height are adjusted at a 1:1 ratio.\n       *     square: false,\n       *\n       *     // Width and height can be adjusted independently. When `true`, width and\n       *     // height maintain the aspect ratio they had when resizing started.\n       *     preserveAspectRatio: false,\n       *\n       *   // a value of 'none' will limit the resize rect to a minimum of 0x0\n       *   // 'negate' will allow the rect to have negative width/height\n       *   // 'reposition' will keep the width/height positive by swapping\n       *   // the top and bottom edges and/or swapping the left and right edges\n       *   invert: 'none' || 'negate' || 'reposition'\n       *\n       *   // limit multiple resizes.\n       *   // See the explanation in the {@link Interactable.draggable} example\n       *   max: Infinity,\n       *   maxPerElement: 1,\n       * });\n       *\n       * var isResizeable = interact(element).resizable();\n       * ```\n       *\n       * Gets or sets whether resize actions can be performed on the target\n       *\n       * @param {boolean | object} [options] true/false or An object with event\n       * listeners to be fired on resize events (object makes the Interactable\n       * resizable)\n       * @return {boolean | Interactable} A boolean indicating if this can be the\n       * target of resize elements, or this Interactable\n       */\n\n      Interactable.prototype.resizable = function (options) {\n        if (utils.is.object(options)) {\n          this.options.resize.enabled = options.enabled === false ? false : true;\n          this.setPerAction('resize', options);\n          this.setOnEvents('resize', options);\n\n          if (/^x$|^y$|^xy$/.test(options.axis)) {\n            this.options.resize.axis = options.axis;\n          } else if (options.axis === null) {\n            this.options.resize.axis = defaultOptions.resize.axis;\n          }\n\n          if (utils.is.bool(options.preserveAspectRatio)) {\n            this.options.resize.preserveAspectRatio = options.preserveAspectRatio;\n          } else if (utils.is.bool(options.square)) {\n            this.options.resize.square = options.square;\n          }\n\n          return this;\n        }\n\n        if (utils.is.bool(options)) {\n          this.options.resize.enabled = options;\n\n          if (!options) {\n            this.onresizestart = this.onresizestart = this.onresizeend = null;\n          }\n\n          return this;\n        }\n\n        return this.options.resize;\n      };\n\n      function checkResizeEdge(name, value, page, element, interactableElement, rect, margin) {\n        // false, '', undefined, null\n        if (!value) {\n          return false;\n        } // true value, use pointer coords and element rect\n\n\n        if (value === true) {\n          // if dimensions are negative, \"switch\" edges\n          var width = utils.is.number(rect.width) ? rect.width : rect.right - rect.left;\n          var height = utils.is.number(rect.height) ? rect.height : rect.bottom - rect.top;\n\n          if (width < 0) {\n            if (name === 'left') {\n              name = 'right';\n            } else if (name === 'right') {\n              name = 'left';\n            }\n          }\n\n          if (height < 0) {\n            if (name === 'top') {\n              name = 'bottom';\n            } else if (name === 'bottom') {\n              name = 'top';\n            }\n          }\n\n          if (name === 'left') {\n            return page.x < (width >= 0 ? rect.left : rect.right) + margin;\n          }\n\n          if (name === 'top') {\n            return page.y < (height >= 0 ? rect.top : rect.bottom) + margin;\n          }\n\n          if (name === 'right') {\n            return page.x > (width >= 0 ? rect.right : rect.left) - margin;\n          }\n\n          if (name === 'bottom') {\n            return page.y > (height >= 0 ? rect.bottom : rect.top) - margin;\n          }\n        } // the remaining checks require an element\n\n\n        if (!utils.is.element(element)) {\n          return false;\n        }\n\n        return utils.is.element(value) // the value is an element to use as a resize handle\n        ? value === element // otherwise check if element matches value as selector\n        : utils.matchesUpTo(element, value, interactableElement);\n      }\n\n      Interaction.signals.on('new', function (interaction) {\n        interaction.resizeAxes = 'xy';\n      });\n      InteractEvent.signals.on('set-delta', function (_ref3) {\n        var interaction = _ref3.interaction,\n            iEvent = _ref3.iEvent,\n            action = _ref3.action;\n\n        if (action !== 'resize' || !interaction.resizeAxes) {\n          return;\n        }\n\n        var options = interaction.target.options;\n\n        if (options.resize.square) {\n          if (interaction.resizeAxes === 'y') {\n            iEvent.dx = iEvent.dy;\n          } else {\n            iEvent.dy = iEvent.dx;\n          }\n\n          iEvent.axes = 'xy';\n        } else {\n          iEvent.axes = interaction.resizeAxes;\n\n          if (interaction.resizeAxes === 'x') {\n            iEvent.dy = 0;\n          } else if (interaction.resizeAxes === 'y') {\n            iEvent.dx = 0;\n          }\n        }\n      });\n      actions.resize = resize;\n      actions.names.push('resize');\n      utils.merge(Interactable.eventTypes, ['resizestart', 'resizemove', 'resizeinertiastart', 'resizeinertiaresume', 'resizeend']);\n      actions.methodDict.resize = 'resizable';\n      defaultOptions.resize = resize.defaults;\n      module.exports = resize;\n    }, {\n      \"../InteractEvent\": 3,\n      \"../Interactable\": 4,\n      \"../Interaction\": 5,\n      \"../defaultOptions\": 18,\n      \"../utils\": 44,\n      \"../utils/browser\": 36,\n      \"./base\": 6\n    }],\n    11: [function (require, module, exports) {\n      'use strict';\n\n      var raf = require('./utils/raf');\n\n      var getWindow = require('./utils/window').getWindow;\n\n      var is = require('./utils/is');\n\n      var domUtils = require('./utils/domUtils');\n\n      var Interaction = require('./Interaction');\n\n      var defaultOptions = require('./defaultOptions');\n\n      var autoScroll = {\n        defaults: {\n          enabled: false,\n          container: null,\n          // the item that is scrolled (Window or HTMLElement)\n          margin: 60,\n          speed: 300 // the scroll speed in pixels per second\n\n        },\n        interaction: null,\n        i: null,\n        // the handle returned by window.setInterval\n        x: 0,\n        y: 0,\n        // Direction each pulse is to scroll in\n        isScrolling: false,\n        prevTime: 0,\n        start: function start(interaction) {\n          autoScroll.isScrolling = true;\n          raf.cancel(autoScroll.i);\n          autoScroll.interaction = interaction;\n          autoScroll.prevTime = new Date().getTime();\n          autoScroll.i = raf.request(autoScroll.scroll);\n        },\n        stop: function stop() {\n          autoScroll.isScrolling = false;\n          raf.cancel(autoScroll.i);\n        },\n        // scroll the window by the values in scroll.x/y\n        scroll: function scroll() {\n          var options = autoScroll.interaction.target.options[autoScroll.interaction.prepared.name].autoScroll;\n          var container = options.container || getWindow(autoScroll.interaction.element);\n          var now = new Date().getTime(); // change in time in seconds\n\n          var dt = (now - autoScroll.prevTime) / 1000; // displacement\n\n          var s = options.speed * dt;\n\n          if (s >= 1) {\n            if (is.window(container)) {\n              container.scrollBy(autoScroll.x * s, autoScroll.y * s);\n            } else if (container) {\n              container.scrollLeft += autoScroll.x * s;\n              container.scrollTop += autoScroll.y * s;\n            }\n\n            autoScroll.prevTime = now;\n          }\n\n          if (autoScroll.isScrolling) {\n            raf.cancel(autoScroll.i);\n            autoScroll.i = raf.request(autoScroll.scroll);\n          }\n        },\n        check: function check(interactable, actionName) {\n          var options = interactable.options;\n          return options[actionName].autoScroll && options[actionName].autoScroll.enabled;\n        },\n        onInteractionMove: function onInteractionMove(_ref) {\n          var interaction = _ref.interaction,\n              pointer = _ref.pointer;\n\n          if (!(interaction.interacting() && autoScroll.check(interaction.target, interaction.prepared.name))) {\n            return;\n          }\n\n          if (interaction.simulation) {\n            autoScroll.x = autoScroll.y = 0;\n            return;\n          }\n\n          var top = void 0;\n          var right = void 0;\n          var bottom = void 0;\n          var left = void 0;\n          var options = interaction.target.options[interaction.prepared.name].autoScroll;\n          var container = options.container || getWindow(interaction.element);\n\n          if (is.window(container)) {\n            left = pointer.clientX < autoScroll.margin;\n            top = pointer.clientY < autoScroll.margin;\n            right = pointer.clientX > container.innerWidth - autoScroll.margin;\n            bottom = pointer.clientY > container.innerHeight - autoScroll.margin;\n          } else {\n            var rect = domUtils.getElementClientRect(container);\n            left = pointer.clientX < rect.left + autoScroll.margin;\n            top = pointer.clientY < rect.top + autoScroll.margin;\n            right = pointer.clientX > rect.right - autoScroll.margin;\n            bottom = pointer.clientY > rect.bottom - autoScroll.margin;\n          }\n\n          autoScroll.x = right ? 1 : left ? -1 : 0;\n          autoScroll.y = bottom ? 1 : top ? -1 : 0;\n\n          if (!autoScroll.isScrolling) {\n            // set the autoScroll properties to those of the target\n            autoScroll.margin = options.margin;\n            autoScroll.speed = options.speed;\n            autoScroll.start(interaction);\n          }\n        }\n      };\n      Interaction.signals.on('stop-active', function () {\n        autoScroll.stop();\n      });\n      Interaction.signals.on('action-move', autoScroll.onInteractionMove);\n      defaultOptions.perAction.autoScroll = autoScroll.defaults;\n      module.exports = autoScroll;\n    }, {\n      \"./Interaction\": 5,\n      \"./defaultOptions\": 18,\n      \"./utils/domUtils\": 39,\n      \"./utils/is\": 46,\n      \"./utils/raf\": 50,\n      \"./utils/window\": 52\n    }],\n    12: [function (require, module, exports) {\n      'use strict';\n      /** @lends Interactable */\n\n      var Interactable = require('../Interactable');\n\n      var actions = require('../actions/base');\n\n      var is = require('../utils/is');\n\n      var domUtils = require('../utils/domUtils');\n\n      var _require = require('../utils'),\n          warnOnce = _require.warnOnce;\n\n      Interactable.prototype.getAction = function (pointer, event, interaction, element) {\n        var action = this.defaultActionChecker(pointer, event, interaction, element);\n\n        if (this.options.actionChecker) {\n          return this.options.actionChecker(pointer, event, action, this, element, interaction);\n        }\n\n        return action;\n      };\n      /**\n       * ```js\n       * interact(element, { ignoreFrom: document.getElementById('no-action') });\n       * // or\n       * interact(element).ignoreFrom('input, textarea, a');\n       * ```\n       * @deprecated\n       * If the target of the `mousedown`, `pointerdown` or `touchstart` event or any\n       * of it's parents match the given CSS selector or Element, no\n       * drag/resize/gesture is started.\n       *\n       * Don't use this method. Instead set the `ignoreFrom` option for each action\n       * or for `pointerEvents`\n       *\n       * @example\n       * interact(targett)\n       *   .draggable({\n       *     ignoreFrom: 'input, textarea, a[href]'',\n       *   })\n       *   .pointerEvents({\n       *     ignoreFrom: '[no-pointer]',\n       *   });\n       *\n       * @param {string | Element | null} [newValue] a CSS selector string, an\n       * Element or `null` to not ignore any elements\n       * @return {string | Element | object} The current ignoreFrom value or this\n       * Interactable\n       */\n\n\n      Interactable.prototype.ignoreFrom = warnOnce(function (newValue) {\n        return this._backCompatOption('ignoreFrom', newValue);\n      }, 'Interactable.ignoreForm() has been deprecated. Use Interactble.draggable({ignoreFrom: newValue}).');\n      /**\n       * ```js\n       *\n       * @deprecated\n       * A drag/resize/gesture is started only If the target of the `mousedown`,\n       * `pointerdown` or `touchstart` event or any of it's parents match the given\n       * CSS selector or Element.\n       *\n       * Don't use this method. Instead set the `allowFrom` option for each action\n       * or for `pointerEvents`\n       *\n       * @example\n       * interact(targett)\n       *   .resizable({\n       *     allowFrom: '.resize-handle',\n       *   .pointerEvents({\n       *     allowFrom: '.handle',,\n       *   });\n       *\n       * @param {string | Element | null} [newValue] a CSS selector string, an\n       * Element or `null` to allow from any element\n       * @return {string | Element | object} The current allowFrom value or this\n       * Interactable\n       */\n\n      Interactable.prototype.allowFrom = warnOnce(function (newValue) {\n        return this._backCompatOption('allowFrom', newValue);\n      }, 'Interactable.allowForm() has been deprecated. Use Interactble.draggable({allowFrom: newValue}).');\n\n      Interactable.prototype.testIgnore = function (ignoreFrom, interactableElement, element) {\n        if (!ignoreFrom || !is.element(element)) {\n          return false;\n        }\n\n        if (is.string(ignoreFrom)) {\n          return domUtils.matchesUpTo(element, ignoreFrom, interactableElement);\n        } else if (is.element(ignoreFrom)) {\n          return domUtils.nodeContains(ignoreFrom, element);\n        }\n\n        return false;\n      };\n\n      Interactable.prototype.testAllow = function (allowFrom, interactableElement, element) {\n        if (!allowFrom) {\n          return true;\n        }\n\n        if (!is.element(element)) {\n          return false;\n        }\n\n        if (is.string(allowFrom)) {\n          return domUtils.matchesUpTo(element, allowFrom, interactableElement);\n        } else if (is.element(allowFrom)) {\n          return domUtils.nodeContains(allowFrom, element);\n        }\n\n        return false;\n      };\n\n      Interactable.prototype.testIgnoreAllow = function (options, interactableElement, eventTarget) {\n        return !this.testIgnore(options.ignoreFrom, interactableElement, eventTarget) && this.testAllow(options.allowFrom, interactableElement, eventTarget);\n      };\n      /**\n       * ```js\n       * interact('.resize-drag')\n       *   .resizable(true)\n       *   .draggable(true)\n       *   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\n       *\n       *   if (interact.matchesSelector(event.target, '.drag-handle') {\n       *     // force drag with handle target\n       *     action.name = drag;\n       *   }\n       *   else {\n       *     // resize from the top and right edges\n       *     action.name  = 'resize';\n       *     action.edges = { top: true, right: true };\n       *   }\n       *\n       *   return action;\n       * });\n       * ```\n       *\n       * Gets or sets the function used to check action to be performed on\n       * pointerDown\n       *\n       * @param {function | null} [checker] A function which takes a pointer event,\n       * defaultAction string, interactable, element and interaction as parameters\n       * and returns an object with name property 'drag' 'resize' or 'gesture' and\n       * optionally an `edges` object with boolean 'top', 'left', 'bottom' and right\n       * props.\n       * @return {Function | Interactable} The checker function or this Interactable\n       */\n\n\n      Interactable.prototype.actionChecker = function (checker) {\n        if (is.function(checker)) {\n          this.options.actionChecker = checker;\n          return this;\n        }\n\n        if (checker === null) {\n          delete this.options.actionChecker;\n          return this;\n        }\n\n        return this.options.actionChecker;\n      };\n      /**\n       * Returns or sets whether the the cursor should be changed depending on the\n       * action that would be performed if the mouse were pressed and dragged.\n       *\n       * @param {boolean} [newValue]\n       * @return {boolean | Interactable} The current setting or this Interactable\n       */\n\n\n      Interactable.prototype.styleCursor = function (newValue) {\n        if (is.bool(newValue)) {\n          this.options.styleCursor = newValue;\n          return this;\n        }\n\n        if (newValue === null) {\n          delete this.options.styleCursor;\n          return this;\n        }\n\n        return this.options.styleCursor;\n      };\n\n      Interactable.prototype.defaultActionChecker = function (pointer, event, interaction, element) {\n        var rect = this.getRect(element);\n        var buttons = event.buttons || {\n          0: 1,\n          1: 4,\n          3: 8,\n          4: 16\n        }[event.button];\n        var action = null;\n\n        for (var _i = 0; _i < actions.names.length; _i++) {\n          var _ref;\n\n          _ref = actions.names[_i];\n          var actionName = _ref; // check mouseButton setting if the pointer is down\n\n          if (interaction.pointerIsDown && /mouse|pointer/.test(interaction.pointerType) && (buttons & this.options[actionName].mouseButtons) === 0) {\n            continue;\n          }\n\n          action = actions[actionName].checker(pointer, event, this, element, interaction, rect);\n\n          if (action) {\n            return action;\n          }\n        }\n      };\n    }, {\n      \"../Interactable\": 4,\n      \"../actions/base\": 6,\n      \"../utils\": 44,\n      \"../utils/domUtils\": 39,\n      \"../utils/is\": 46\n    }],\n    13: [function (require, module, exports) {\n      'use strict';\n\n      var interact = require('../interact');\n\n      var Interactable = require('../Interactable');\n\n      var Interaction = require('../Interaction');\n\n      var actions = require('../actions/base');\n\n      var defaultOptions = require('../defaultOptions');\n\n      var scope = require('../scope');\n\n      var utils = require('../utils');\n\n      var signals = require('../utils/Signals').new();\n\n      require('./InteractableMethods');\n\n      var autoStart = {\n        signals: signals,\n        withinInteractionLimit: withinInteractionLimit,\n        // Allow this many interactions to happen simultaneously\n        maxInteractions: Infinity,\n        defaults: {\n          perAction: {\n            manualStart: false,\n            max: Infinity,\n            maxPerElement: 1,\n            allowFrom: null,\n            ignoreFrom: null,\n            // only allow left button by default\n            // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value\n            mouseButtons: 1\n          }\n        },\n        setActionDefaults: function setActionDefaults(action) {\n          utils.extend(action.defaults, autoStart.defaults.perAction);\n        },\n        validateAction: validateAction\n      }; // set cursor style on mousedown\n\n      Interaction.signals.on('down', function (_ref) {\n        var interaction = _ref.interaction,\n            pointer = _ref.pointer,\n            event = _ref.event,\n            eventTarget = _ref.eventTarget;\n\n        if (interaction.interacting()) {\n          return;\n        }\n\n        var actionInfo = getActionInfo(interaction, pointer, event, eventTarget);\n        prepare(interaction, actionInfo);\n      }); // set cursor style on mousemove\n\n      Interaction.signals.on('move', function (_ref2) {\n        var interaction = _ref2.interaction,\n            pointer = _ref2.pointer,\n            event = _ref2.event,\n            eventTarget = _ref2.eventTarget;\n\n        if (interaction.pointerType !== 'mouse' || interaction.pointerIsDown || interaction.interacting()) {\n          return;\n        }\n\n        var actionInfo = getActionInfo(interaction, pointer, event, eventTarget);\n        prepare(interaction, actionInfo);\n      });\n      Interaction.signals.on('move', function (arg) {\n        var interaction = arg.interaction,\n            event = arg.event;\n\n        if (!interaction.pointerIsDown || interaction.interacting() || !interaction.pointerWasMoved || !interaction.prepared.name) {\n          return;\n        }\n\n        signals.fire('before-start', arg);\n        var target = interaction.target;\n\n        if (interaction.prepared.name && target) {\n          // check manualStart and interaction limit\n          if (target.options[interaction.prepared.name].manualStart || !withinInteractionLimit(target, interaction.element, interaction.prepared)) {\n            interaction.stop(event);\n          } else {\n            interaction.start(interaction.prepared, target, interaction.element);\n          }\n        }\n      }); // Check if the current target supports the action.\n      // If so, return the validated action. Otherwise, return null\n\n      function validateAction(action, interactable, element, eventTarget) {\n        if (utils.is.object(action) && interactable.testIgnoreAllow(interactable.options[action.name], element, eventTarget) && interactable.options[action.name].enabled && withinInteractionLimit(interactable, element, action)) {\n          return action;\n        }\n\n        return null;\n      }\n\n      function validateSelector(interaction, pointer, event, matches, matchElements, eventTarget) {\n        for (var i = 0, len = matches.length; i < len; i++) {\n          var match = matches[i];\n          var matchElement = matchElements[i];\n          var action = validateAction(match.getAction(pointer, event, interaction, matchElement), match, matchElement, eventTarget);\n\n          if (action) {\n            return {\n              action: action,\n              target: match,\n              element: matchElement\n            };\n          }\n        }\n\n        return {};\n      }\n\n      function getActionInfo(interaction, pointer, event, eventTarget) {\n        var matches = [];\n        var matchElements = [];\n        var element = eventTarget;\n\n        function pushMatches(interactable) {\n          matches.push(interactable);\n          matchElements.push(element);\n        }\n\n        while (utils.is.element(element)) {\n          matches = [];\n          matchElements = [];\n          scope.interactables.forEachMatch(element, pushMatches);\n          var actionInfo = validateSelector(interaction, pointer, event, matches, matchElements, eventTarget);\n\n          if (actionInfo.action && !actionInfo.target.options[actionInfo.action.name].manualStart) {\n            return actionInfo;\n          }\n\n          element = utils.parentNode(element);\n        }\n\n        return {};\n      }\n\n      function prepare(interaction, _ref3) {\n        var action = _ref3.action,\n            target = _ref3.target,\n            element = _ref3.element;\n        action = action || {};\n\n        if (interaction.target && interaction.target.options.styleCursor) {\n          interaction.target._doc.documentElement.style.cursor = '';\n        }\n\n        interaction.target = target;\n        interaction.element = element;\n        utils.copyAction(interaction.prepared, action);\n\n        if (target && target.options.styleCursor) {\n          var cursor = action ? actions[action.name].getCursor(action) : '';\n          interaction.target._doc.documentElement.style.cursor = cursor;\n        }\n\n        signals.fire('prepared', {\n          interaction: interaction\n        });\n      }\n\n      Interaction.signals.on('stop', function (_ref4) {\n        var interaction = _ref4.interaction;\n        var target = interaction.target;\n\n        if (target && target.options.styleCursor) {\n          target._doc.documentElement.style.cursor = '';\n        }\n      });\n\n      function withinInteractionLimit(interactable, element, action) {\n        var options = interactable.options;\n        var maxActions = options[action.name].max;\n        var maxPerElement = options[action.name].maxPerElement;\n        var activeInteractions = 0;\n        var targetCount = 0;\n        var targetElementCount = 0; // no actions if any of these values == 0\n\n        if (!(maxActions && maxPerElement && autoStart.maxInteractions)) {\n          return;\n        }\n\n        for (var _i = 0; _i < scope.interactions.length; _i++) {\n          var _ref5;\n\n          _ref5 = scope.interactions[_i];\n          var interaction = _ref5;\n          var otherAction = interaction.prepared.name;\n\n          if (!interaction.interacting()) {\n            continue;\n          }\n\n          activeInteractions++;\n\n          if (activeInteractions >= autoStart.maxInteractions) {\n            return false;\n          }\n\n          if (interaction.target !== interactable) {\n            continue;\n          }\n\n          targetCount += otherAction === action.name | 0;\n\n          if (targetCount >= maxActions) {\n            return false;\n          }\n\n          if (interaction.element === element) {\n            targetElementCount++;\n\n            if (otherAction !== action.name || targetElementCount >= maxPerElement) {\n              return false;\n            }\n          }\n        }\n\n        return autoStart.maxInteractions > 0;\n      }\n      /**\n       * Returns or sets the maximum number of concurrent interactions allowed.  By\n       * default only 1 interaction is allowed at a time (for backwards\n       * compatibility). To allow multiple interactions on the same Interactables and\n       * elements, you need to enable it in the draggable, resizable and gesturable\n       * `'max'` and `'maxPerElement'` options.\n       *\n       * @alias module:interact.maxInteractions\n       *\n       * @param {number} [newValue] Any number. newValue <= 0 means no interactions.\n       */\n\n\n      interact.maxInteractions = function (newValue) {\n        if (utils.is.number(newValue)) {\n          autoStart.maxInteractions = newValue;\n          return interact;\n        }\n\n        return autoStart.maxInteractions;\n      };\n\n      Interactable.settingsMethods.push('styleCursor');\n      Interactable.settingsMethods.push('actionChecker');\n      Interactable.settingsMethods.push('ignoreFrom');\n      Interactable.settingsMethods.push('allowFrom');\n      defaultOptions.base.actionChecker = null;\n      defaultOptions.base.styleCursor = true;\n      utils.extend(defaultOptions.perAction, autoStart.defaults.perAction);\n      module.exports = autoStart;\n    }, {\n      \"../Interactable\": 4,\n      \"../Interaction\": 5,\n      \"../actions/base\": 6,\n      \"../defaultOptions\": 18,\n      \"../interact\": 21,\n      \"../scope\": 33,\n      \"../utils\": 44,\n      \"../utils/Signals\": 34,\n      \"./InteractableMethods\": 12\n    }],\n    14: [function (require, module, exports) {\n      'use strict';\n\n      var autoStart = require('./base');\n\n      var scope = require('../scope');\n\n      var is = require('../utils/is');\n\n      var _require = require('../utils/domUtils'),\n          parentNode = _require.parentNode;\n\n      autoStart.setActionDefaults(require('../actions/drag'));\n      autoStart.signals.on('before-start', function (_ref) {\n        var interaction = _ref.interaction,\n            eventTarget = _ref.eventTarget,\n            dx = _ref.dx,\n            dy = _ref.dy;\n\n        if (interaction.prepared.name !== 'drag') {\n          return;\n        } // check if a drag is in the correct axis\n\n\n        var absX = Math.abs(dx);\n        var absY = Math.abs(dy);\n        var targetOptions = interaction.target.options.drag;\n        var startAxis = targetOptions.startAxis;\n        var currentAxis = absX > absY ? 'x' : absX < absY ? 'y' : 'xy';\n        interaction.prepared.axis = targetOptions.lockAxis === 'start' ? currentAxis[0] // always lock to one axis even if currentAxis === 'xy'\n        : targetOptions.lockAxis; // if the movement isn't in the startAxis of the interactable\n\n        if (currentAxis !== 'xy' && startAxis !== 'xy' && startAxis !== currentAxis) {\n          // cancel the prepared action\n          interaction.prepared.name = null; // then try to get a drag from another ineractable\n\n          var element = eventTarget;\n\n          var getDraggable = function getDraggable(interactable) {\n            if (interactable === interaction.target) {\n              return;\n            }\n\n            var options = interaction.target.options.drag;\n\n            if (!options.manualStart && interactable.testIgnoreAllow(options, element, eventTarget)) {\n              var action = interactable.getAction(interaction.downPointer, interaction.downEvent, interaction, element);\n\n              if (action && action.name === 'drag' && checkStartAxis(currentAxis, interactable) && autoStart.validateAction(action, interactable, element, eventTarget)) {\n                return interactable;\n              }\n            }\n          }; // check all interactables\n\n\n          while (is.element(element)) {\n            var interactable = scope.interactables.forEachMatch(element, getDraggable);\n\n            if (interactable) {\n              interaction.prepared.name = 'drag';\n              interaction.target = interactable;\n              interaction.element = element;\n              break;\n            }\n\n            element = parentNode(element);\n          }\n        }\n      });\n\n      function checkStartAxis(startAxis, interactable) {\n        if (!interactable) {\n          return false;\n        }\n\n        var thisAxis = interactable.options.drag.startAxis;\n        return startAxis === 'xy' || thisAxis === 'xy' || thisAxis === startAxis;\n      }\n    }, {\n      \"../actions/drag\": 7,\n      \"../scope\": 33,\n      \"../utils/domUtils\": 39,\n      \"../utils/is\": 46,\n      \"./base\": 13\n    }],\n    15: [function (require, module, exports) {\n      'use strict';\n\n      require('./base').setActionDefaults(require('../actions/gesture'));\n    }, {\n      \"../actions/gesture\": 9,\n      \"./base\": 13\n    }],\n    16: [function (require, module, exports) {\n      'use strict';\n\n      var autoStart = require('./base');\n\n      var Interaction = require('../Interaction');\n\n      autoStart.defaults.perAction.hold = 0;\n      autoStart.defaults.perAction.delay = 0;\n      Interaction.signals.on('new', function (interaction) {\n        interaction.autoStartHoldTimer = null;\n      });\n      autoStart.signals.on('prepared', function (_ref) {\n        var interaction = _ref.interaction;\n        var hold = getHoldDuration(interaction);\n\n        if (hold > 0) {\n          interaction.autoStartHoldTimer = setTimeout(function () {\n            interaction.start(interaction.prepared, interaction.target, interaction.element);\n          }, hold);\n        }\n      });\n      Interaction.signals.on('move', function (_ref2) {\n        var interaction = _ref2.interaction,\n            duplicate = _ref2.duplicate;\n\n        if (interaction.pointerWasMoved && !duplicate) {\n          clearTimeout(interaction.autoStartHoldTimer);\n        }\n      }); // prevent regular down->move autoStart\n\n      autoStart.signals.on('before-start', function (_ref3) {\n        var interaction = _ref3.interaction;\n        var hold = getHoldDuration(interaction);\n\n        if (hold > 0) {\n          interaction.prepared.name = null;\n        }\n      });\n\n      function getHoldDuration(interaction) {\n        var actionName = interaction.prepared && interaction.prepared.name;\n\n        if (!actionName) {\n          return null;\n        }\n\n        var options = interaction.target.options;\n        return options[actionName].hold || options[actionName].delay;\n      }\n\n      module.exports = {\n        getHoldDuration: getHoldDuration\n      };\n    }, {\n      \"../Interaction\": 5,\n      \"./base\": 13\n    }],\n    17: [function (require, module, exports) {\n      'use strict';\n\n      require('./base').setActionDefaults(require('../actions/resize'));\n    }, {\n      \"../actions/resize\": 10,\n      \"./base\": 13\n    }],\n    18: [function (require, module, exports) {\n      'use strict';\n\n      module.exports = {\n        base: {\n          accept: null,\n          preventDefault: 'auto',\n          deltaSource: 'page'\n        },\n        perAction: {\n          origin: {\n            x: 0,\n            y: 0\n          },\n          inertia: {\n            enabled: false,\n            resistance: 10,\n            // the lambda in exponential decay\n            minSpeed: 100,\n            // target speed must be above this for inertia to start\n            endSpeed: 10,\n            // the speed at which inertia is slow enough to stop\n            allowResume: true,\n            // allow resuming an action in inertia phase\n            smoothEndDuration: 300 // animate to snap/restrict endOnly if there's no inertia\n\n          }\n        }\n      };\n    }, {}],\n    19: [function (require, module, exports) {\n      'use strict';\n      /* browser entry point */\n      // inertia\n\n      require('./inertia'); // modifiers\n\n\n      require('./modifiers/snap');\n\n      require('./modifiers/restrict'); // pointerEvents\n\n\n      require('./pointerEvents/base');\n\n      require('./pointerEvents/holdRepeat');\n\n      require('./pointerEvents/interactableTargets'); // autoStart hold\n\n\n      require('./autoStart/hold'); // actions\n\n\n      require('./actions/gesture');\n\n      require('./actions/resize');\n\n      require('./actions/drag');\n\n      require('./actions/drop'); // load these modifiers after resize is loaded\n\n\n      require('./modifiers/snapSize');\n\n      require('./modifiers/restrictEdges');\n\n      require('./modifiers/restrictSize'); // autoStart actions\n\n\n      require('./autoStart/gesture');\n\n      require('./autoStart/resize');\n\n      require('./autoStart/drag'); // Interactable preventDefault setting\n\n\n      require('./interactablePreventDefault.js'); // autoScroll\n\n\n      require('./autoScroll'); // export interact\n\n\n      module.exports = require('./interact');\n    }, {\n      \"./actions/drag\": 7,\n      \"./actions/drop\": 8,\n      \"./actions/gesture\": 9,\n      \"./actions/resize\": 10,\n      \"./autoScroll\": 11,\n      \"./autoStart/drag\": 14,\n      \"./autoStart/gesture\": 15,\n      \"./autoStart/hold\": 16,\n      \"./autoStart/resize\": 17,\n      \"./inertia\": 20,\n      \"./interact\": 21,\n      \"./interactablePreventDefault.js\": 22,\n      \"./modifiers/restrict\": 24,\n      \"./modifiers/restrictEdges\": 25,\n      \"./modifiers/restrictSize\": 26,\n      \"./modifiers/snap\": 27,\n      \"./modifiers/snapSize\": 28,\n      \"./pointerEvents/base\": 30,\n      \"./pointerEvents/holdRepeat\": 31,\n      \"./pointerEvents/interactableTargets\": 32\n    }],\n    20: [function (require, module, exports) {\n      'use strict';\n\n      var InteractEvent = require('./InteractEvent');\n\n      var Interaction = require('./Interaction');\n\n      var modifiers = require('./modifiers/base');\n\n      var utils = require('./utils');\n\n      var animationFrame = require('./utils/raf');\n\n      Interaction.signals.on('new', function (interaction) {\n        interaction.inertiaStatus = {\n          active: false,\n          smoothEnd: false,\n          allowResume: false,\n          startEvent: null,\n          upCoords: {},\n          xe: 0,\n          ye: 0,\n          sx: 0,\n          sy: 0,\n          t0: 0,\n          vx0: 0,\n          vys: 0,\n          duration: 0,\n          lambda_v0: 0,\n          one_ve_v0: 0,\n          i: null\n        };\n\n        interaction.boundInertiaFrame = function () {\n          return inertiaFrame.apply(interaction);\n        };\n\n        interaction.boundSmoothEndFrame = function () {\n          return smoothEndFrame.apply(interaction);\n        };\n      });\n      Interaction.signals.on('down', function (_ref) {\n        var interaction = _ref.interaction,\n            event = _ref.event,\n            pointer = _ref.pointer,\n            eventTarget = _ref.eventTarget;\n        var status = interaction.inertiaStatus; // Check if the down event hits the current inertia target\n\n        if (status.active) {\n          var element = eventTarget; // climb up the DOM tree from the event target\n\n          while (utils.is.element(element)) {\n            // if interaction element is the current inertia target element\n            if (element === interaction.element) {\n              // stop inertia\n              animationFrame.cancel(status.i);\n              status.active = false;\n              interaction.simulation = null; // update pointers to the down event's coordinates\n\n              interaction.updatePointer(pointer);\n              utils.setCoords(interaction.curCoords, interaction.pointers); // fire appropriate signals\n\n              var signalArg = {\n                interaction: interaction\n              };\n              Interaction.signals.fire('before-action-move', signalArg);\n              Interaction.signals.fire('action-resume', signalArg); // fire a reume event\n\n              var resumeEvent = new InteractEvent(interaction, event, interaction.prepared.name, 'inertiaresume', interaction.element);\n              interaction.target.fire(resumeEvent);\n              interaction.prevEvent = resumeEvent;\n              modifiers.resetStatuses(interaction.modifierStatuses);\n              utils.copyCoords(interaction.prevCoords, interaction.curCoords);\n              break;\n            }\n\n            element = utils.parentNode(element);\n          }\n        }\n      });\n      Interaction.signals.on('up', function (_ref2) {\n        var interaction = _ref2.interaction,\n            event = _ref2.event;\n        var status = interaction.inertiaStatus;\n\n        if (!interaction.interacting() || status.active) {\n          return;\n        }\n\n        var target = interaction.target;\n        var options = target && target.options;\n        var inertiaOptions = options && interaction.prepared.name && options[interaction.prepared.name].inertia;\n        var now = new Date().getTime();\n        var statuses = {};\n        var page = utils.extend({}, interaction.curCoords.page);\n        var pointerSpeed = interaction.pointerDelta.client.speed;\n        var smoothEnd = false;\n        var modifierResult = void 0; // check if inertia should be started\n\n        var inertiaPossible = inertiaOptions && inertiaOptions.enabled && interaction.prepared.name !== 'gesture' && event !== status.startEvent;\n        var inertia = inertiaPossible && now - interaction.curCoords.timeStamp < 50 && pointerSpeed > inertiaOptions.minSpeed && pointerSpeed > inertiaOptions.endSpeed;\n        var modifierArg = {\n          interaction: interaction,\n          pageCoords: page,\n          statuses: statuses,\n          preEnd: true,\n          requireEndOnly: true\n        }; // smoothEnd\n\n        if (inertiaPossible && !inertia) {\n          modifiers.resetStatuses(statuses);\n          modifierResult = modifiers.setAll(modifierArg);\n\n          if (modifierResult.shouldMove && modifierResult.locked) {\n            smoothEnd = true;\n          }\n        }\n\n        if (!(inertia || smoothEnd)) {\n          return;\n        }\n\n        utils.copyCoords(status.upCoords, interaction.curCoords);\n        interaction.pointers[0] = status.startEvent = new InteractEvent(interaction, event, interaction.prepared.name, 'inertiastart', interaction.element);\n        status.t0 = now;\n        status.active = true;\n        status.allowResume = inertiaOptions.allowResume;\n        interaction.simulation = status;\n        target.fire(status.startEvent);\n\n        if (inertia) {\n          status.vx0 = interaction.pointerDelta.client.vx;\n          status.vy0 = interaction.pointerDelta.client.vy;\n          status.v0 = pointerSpeed;\n          calcInertia(interaction, status);\n          utils.extend(page, interaction.curCoords.page);\n          page.x += status.xe;\n          page.y += status.ye;\n          modifiers.resetStatuses(statuses);\n          modifierResult = modifiers.setAll(modifierArg);\n          status.modifiedXe += modifierResult.dx;\n          status.modifiedYe += modifierResult.dy;\n          status.i = animationFrame.request(interaction.boundInertiaFrame);\n        } else {\n          status.smoothEnd = true;\n          status.xe = modifierResult.dx;\n          status.ye = modifierResult.dy;\n          status.sx = status.sy = 0;\n          status.i = animationFrame.request(interaction.boundSmoothEndFrame);\n        }\n      });\n      Interaction.signals.on('stop-active', function (_ref3) {\n        var interaction = _ref3.interaction;\n        var status = interaction.inertiaStatus;\n\n        if (status.active) {\n          animationFrame.cancel(status.i);\n          status.active = false;\n          interaction.simulation = null;\n        }\n      });\n\n      function calcInertia(interaction, status) {\n        var inertiaOptions = interaction.target.options[interaction.prepared.name].inertia;\n        var lambda = inertiaOptions.resistance;\n        var inertiaDur = -Math.log(inertiaOptions.endSpeed / status.v0) / lambda;\n        status.x0 = interaction.prevEvent.pageX;\n        status.y0 = interaction.prevEvent.pageY;\n        status.t0 = status.startEvent.timeStamp / 1000;\n        status.sx = status.sy = 0;\n        status.modifiedXe = status.xe = (status.vx0 - inertiaDur) / lambda;\n        status.modifiedYe = status.ye = (status.vy0 - inertiaDur) / lambda;\n        status.te = inertiaDur;\n        status.lambda_v0 = lambda / status.v0;\n        status.one_ve_v0 = 1 - inertiaOptions.endSpeed / status.v0;\n      }\n\n      function inertiaFrame() {\n        updateInertiaCoords(this);\n        utils.setCoordDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n        var status = this.inertiaStatus;\n        var options = this.target.options[this.prepared.name].inertia;\n        var lambda = options.resistance;\n        var t = new Date().getTime() / 1000 - status.t0;\n\n        if (t < status.te) {\n          var progress = 1 - (Math.exp(-lambda * t) - status.lambda_v0) / status.one_ve_v0;\n\n          if (status.modifiedXe === status.xe && status.modifiedYe === status.ye) {\n            status.sx = status.xe * progress;\n            status.sy = status.ye * progress;\n          } else {\n            var quadPoint = utils.getQuadraticCurvePoint(0, 0, status.xe, status.ye, status.modifiedXe, status.modifiedYe, progress);\n            status.sx = quadPoint.x;\n            status.sy = quadPoint.y;\n          }\n\n          this.doMove();\n          status.i = animationFrame.request(this.boundInertiaFrame);\n        } else {\n          status.sx = status.modifiedXe;\n          status.sy = status.modifiedYe;\n          this.doMove();\n          this.end(status.startEvent);\n          status.active = false;\n          this.simulation = null;\n        }\n\n        utils.copyCoords(this.prevCoords, this.curCoords);\n      }\n\n      function smoothEndFrame() {\n        updateInertiaCoords(this);\n        var status = this.inertiaStatus;\n        var t = new Date().getTime() - status.t0;\n        var duration = this.target.options[this.prepared.name].inertia.smoothEndDuration;\n\n        if (t < duration) {\n          status.sx = utils.easeOutQuad(t, 0, status.xe, duration);\n          status.sy = utils.easeOutQuad(t, 0, status.ye, duration);\n          this.pointerMove(status.startEvent, status.startEvent);\n          status.i = animationFrame.request(this.boundSmoothEndFrame);\n        } else {\n          status.sx = status.xe;\n          status.sy = status.ye;\n          this.pointerMove(status.startEvent, status.startEvent);\n          this.end(status.startEvent);\n          status.smoothEnd = status.active = false;\n          this.simulation = null;\n        }\n      }\n\n      function updateInertiaCoords(interaction) {\n        var status = interaction.inertiaStatus; // return if inertia isn't running\n\n        if (!status.active) {\n          return;\n        }\n\n        var pageUp = status.upCoords.page;\n        var clientUp = status.upCoords.client;\n        utils.setCoords(interaction.curCoords, [{\n          pageX: pageUp.x + status.sx,\n          pageY: pageUp.y + status.sy,\n          clientX: clientUp.x + status.sx,\n          clientY: clientUp.y + status.sy\n        }]);\n      }\n    }, {\n      \"./InteractEvent\": 3,\n      \"./Interaction\": 5,\n      \"./modifiers/base\": 23,\n      \"./utils\": 44,\n      \"./utils/raf\": 50\n    }],\n    21: [function (require, module, exports) {\n      'use strict';\n      /** @module interact */\n\n      var browser = require('./utils/browser');\n\n      var events = require('./utils/events');\n\n      var utils = require('./utils');\n\n      var scope = require('./scope');\n\n      var Interactable = require('./Interactable');\n\n      var Interaction = require('./Interaction');\n\n      var globalEvents = {};\n      /**\n       * ```js\n       * interact('#draggable').draggable(true);\n       *\n       * var rectables = interact('rect');\n       * rectables\n       *   .gesturable(true)\n       *   .on('gesturemove', function (event) {\n       *       // ...\n       *   });\n       * ```\n       *\n       * The methods of this variable can be used to set elements as interactables\n       * and also to change various default settings.\n       *\n       * Calling it as a function and passing an element or a valid CSS selector\n       * string returns an Interactable object which has various methods to configure\n       * it.\n       *\n       * @global\n       *\n       * @param {Element | string} element The HTML or SVG Element to interact with\n       * or CSS selector\n       * @return {Interactable}\n       */\n\n      function interact(element, options) {\n        var interactable = scope.interactables.get(element, options);\n\n        if (!interactable) {\n          interactable = new Interactable(element, options);\n          interactable.events.global = globalEvents;\n        }\n\n        return interactable;\n      }\n      /**\n       * Check if an element or selector has been set with the {@link interact}\n       * function\n       *\n       * @alias module:interact.isSet\n       *\n       * @param {Element} element The Element being searched for\n       * @return {boolean} Indicates if the element or CSS selector was previously\n       * passed to interact\n      */\n\n\n      interact.isSet = function (element, options) {\n        return scope.interactables.indexOfElement(element, options && options.context) !== -1;\n      };\n      /**\n       * Add a global listener for an InteractEvent or adds a DOM event to `document`\n       *\n       * @alias module:interact.on\n       *\n       * @param {string | array | object} type The types of events to listen for\n       * @param {function} listener The function event (s)\n       * @param {object | boolean} [options] object or useCapture flag for\n       * addEventListener\n       * @return {object} interact\n       */\n\n\n      interact.on = function (type, listener, options) {\n        if (utils.is.string(type) && type.search(' ') !== -1) {\n          type = type.trim().split(/ +/);\n        }\n\n        if (utils.is.array(type)) {\n          for (var _i = 0; _i < type.length; _i++) {\n            var _ref;\n\n            _ref = type[_i];\n            var eventType = _ref;\n            interact.on(eventType, listener, options);\n          }\n\n          return interact;\n        }\n\n        if (utils.is.object(type)) {\n          for (var prop in type) {\n            interact.on(prop, type[prop], listener);\n          }\n\n          return interact;\n        } // if it is an InteractEvent type, add listener to globalEvents\n\n\n        if (utils.contains(Interactable.eventTypes, type)) {\n          // if this type of event was never bound\n          if (!globalEvents[type]) {\n            globalEvents[type] = [listener];\n          } else {\n            globalEvents[type].push(listener);\n          }\n        } // If non InteractEvent type, addEventListener to document\n        else {\n            events.add(scope.document, type, listener, {\n              options: options\n            });\n          }\n\n        return interact;\n      };\n      /**\n       * Removes a global InteractEvent listener or DOM event from `document`\n       *\n       * @alias module:interact.off\n       *\n       * @param {string | array | object} type The types of events that were listened\n       * for\n       * @param {function} listener The listener function to be removed\n       * @param {object | boolean} options [options] object or useCapture flag for\n       * removeEventListener\n       * @return {object} interact\n       */\n\n\n      interact.off = function (type, listener, options) {\n        if (utils.is.string(type) && type.search(' ') !== -1) {\n          type = type.trim().split(/ +/);\n        }\n\n        if (utils.is.array(type)) {\n          for (var _i2 = 0; _i2 < type.length; _i2++) {\n            var _ref2;\n\n            _ref2 = type[_i2];\n            var eventType = _ref2;\n            interact.off(eventType, listener, options);\n          }\n\n          return interact;\n        }\n\n        if (utils.is.object(type)) {\n          for (var prop in type) {\n            interact.off(prop, type[prop], listener);\n          }\n\n          return interact;\n        }\n\n        if (!utils.contains(Interactable.eventTypes, type)) {\n          events.remove(scope.document, type, listener, options);\n        } else {\n          var index = void 0;\n\n          if (type in globalEvents && (index = globalEvents[type].indexOf(listener)) !== -1) {\n            globalEvents[type].splice(index, 1);\n          }\n        }\n\n        return interact;\n      };\n      /**\n       * Returns an object which exposes internal data\n      \n       * @alias module:interact.debug\n       *\n       * @return {object} An object with properties that outline the current state\n       * and expose internal functions and variables\n       */\n\n\n      interact.debug = function () {\n        return scope;\n      }; // expose the functions used to calculate multi-touch properties\n\n\n      interact.getPointerAverage = utils.pointerAverage;\n      interact.getTouchBBox = utils.touchBBox;\n      interact.getTouchDistance = utils.touchDistance;\n      interact.getTouchAngle = utils.touchAngle;\n      interact.getElementRect = utils.getElementRect;\n      interact.getElementClientRect = utils.getElementClientRect;\n      interact.matchesSelector = utils.matchesSelector;\n      interact.closest = utils.closest;\n      /**\n       * @alias module:interact.supportsTouch\n       *\n       * @return {boolean} Whether or not the browser supports touch input\n       */\n\n      interact.supportsTouch = function () {\n        return browser.supportsTouch;\n      };\n      /**\n       * @alias module:interact.supportsPointerEvent\n       *\n       * @return {boolean} Whether or not the browser supports PointerEvents\n       */\n\n\n      interact.supportsPointerEvent = function () {\n        return browser.supportsPointerEvent;\n      };\n      /**\n       * Cancels all interactions (end events are not fired)\n       *\n       * @alias module:interact.stop\n       *\n       * @param {Event} event An event on which to call preventDefault()\n       * @return {object} interact\n       */\n\n\n      interact.stop = function (event) {\n        for (var i = scope.interactions.length - 1; i >= 0; i--) {\n          scope.interactions[i].stop(event);\n        }\n\n        return interact;\n      };\n      /**\n       * Returns or sets the distance the pointer must be moved before an action\n       * sequence occurs. This also affects tolerance for tap events.\n       *\n       * @alias module:interact.pointerMoveTolerance\n       *\n       * @param {number} [newValue] The movement from the start position must be greater than this value\n       * @return {interact | number}\n       */\n\n\n      interact.pointerMoveTolerance = function (newValue) {\n        if (utils.is.number(newValue)) {\n          Interaction.pointerMoveTolerance = newValue;\n          return interact;\n        }\n\n        return Interaction.pointerMoveTolerance;\n      };\n\n      interact.addDocument = scope.addDocument;\n      interact.removeDocument = scope.removeDocument;\n      scope.interact = interact;\n      module.exports = interact;\n    }, {\n      \"./Interactable\": 4,\n      \"./Interaction\": 5,\n      \"./scope\": 33,\n      \"./utils\": 44,\n      \"./utils/browser\": 36,\n      \"./utils/events\": 40\n    }],\n    22: [function (require, module, exports) {\n      'use strict';\n\n      var Interactable = require('./Interactable');\n\n      var Interaction = require('./Interaction');\n\n      var scope = require('./scope');\n\n      var is = require('./utils/is');\n\n      var events = require('./utils/events');\n\n      var browser = require('./utils/browser');\n\n      var _require = require('./utils/domUtils'),\n          nodeContains = _require.nodeContains,\n          matchesSelector = _require.matchesSelector;\n      /**\n       * Returns or sets whether to prevent the browser's default behaviour in\n       * response to pointer events. Can be set to:\n       *  - `'always'` to always prevent\n       *  - `'never'` to never prevent\n       *  - `'auto'` to let interact.js try to determine what would be best\n       *\n       * @param {string} [newValue] `true`, `false` or `'auto'`\n       * @return {string | Interactable} The current setting or this Interactable\n       */\n\n\n      Interactable.prototype.preventDefault = function (newValue) {\n        if (/^(always|never|auto)$/.test(newValue)) {\n          this.options.preventDefault = newValue;\n          return this;\n        }\n\n        if (is.bool(newValue)) {\n          this.options.preventDefault = newValue ? 'always' : 'never';\n          return this;\n        }\n\n        return this.options.preventDefault;\n      };\n\n      Interactable.prototype.checkAndPreventDefault = function (event) {\n        var setting = this.options.preventDefault;\n\n        if (setting === 'never') {\n          return;\n        }\n\n        if (setting === 'always') {\n          event.preventDefault();\n          return;\n        } // setting === 'auto'\n        // don't preventDefault of touch{start,move} events if the browser supports passive\n        // events listeners. CSS touch-action and user-selecct should be used instead\n\n\n        if (events.supportsPassive && /^touch(start|move)$/.test(event.type) && !browser.isIOS) {\n          return;\n        } // don't preventDefault of pointerdown events\n\n\n        if (/^(mouse|pointer|touch)*(down|start)/i.test(event.type)) {\n          return;\n        } // don't preventDefault on editable elements\n\n\n        if (is.element(event.target) && matchesSelector(event.target, 'input,select,textarea,[contenteditable=true],[contenteditable=true] *')) {\n          return;\n        }\n\n        event.preventDefault();\n      };\n\n      function onInteractionEvent(_ref) {\n        var interaction = _ref.interaction,\n            event = _ref.event;\n\n        if (interaction.target) {\n          interaction.target.checkAndPreventDefault(event);\n        }\n      }\n\n      var _arr = ['down', 'move', 'up', 'cancel'];\n\n      for (var _i = 0; _i < _arr.length; _i++) {\n        var eventSignal = _arr[_i];\n        Interaction.signals.on(eventSignal, onInteractionEvent);\n      } // prevent native HTML5 drag on interact.js target elements\n\n\n      Interaction.docEvents.dragstart = function preventNativeDrag(event) {\n        for (var _i2 = 0; _i2 < scope.interactions.length; _i2++) {\n          var _ref2;\n\n          _ref2 = scope.interactions[_i2];\n          var interaction = _ref2;\n\n          if (interaction.element && (interaction.element === event.target || nodeContains(interaction.element, event.target))) {\n            interaction.target.checkAndPreventDefault(event);\n            return;\n          }\n        }\n      };\n    }, {\n      \"./Interactable\": 4,\n      \"./Interaction\": 5,\n      \"./scope\": 33,\n      \"./utils/browser\": 36,\n      \"./utils/domUtils\": 39,\n      \"./utils/events\": 40,\n      \"./utils/is\": 46\n    }],\n    23: [function (require, module, exports) {\n      'use strict';\n\n      var InteractEvent = require('../InteractEvent');\n\n      var Interaction = require('../Interaction');\n\n      var extend = require('../utils/extend');\n\n      var modifiers = {\n        names: [],\n        setOffsets: function setOffsets(arg) {\n          var interaction = arg.interaction,\n              page = arg.pageCoords;\n          var target = interaction.target,\n              element = interaction.element,\n              startOffset = interaction.startOffset;\n          var rect = target.getRect(element);\n\n          if (rect) {\n            startOffset.left = page.x - rect.left;\n            startOffset.top = page.y - rect.top;\n            startOffset.right = rect.right - page.x;\n            startOffset.bottom = rect.bottom - page.y;\n\n            if (!('width' in rect)) {\n              rect.width = rect.right - rect.left;\n            }\n\n            if (!('height' in rect)) {\n              rect.height = rect.bottom - rect.top;\n            }\n          } else {\n            startOffset.left = startOffset.top = startOffset.right = startOffset.bottom = 0;\n          }\n\n          arg.rect = rect;\n          arg.interactable = target;\n          arg.element = element;\n\n          for (var _i = 0; _i < modifiers.names.length; _i++) {\n            var _ref;\n\n            _ref = modifiers.names[_i];\n            var modifierName = _ref;\n            arg.options = target.options[interaction.prepared.name][modifierName];\n\n            if (!arg.options) {\n              continue;\n            }\n\n            interaction.modifierOffsets[modifierName] = modifiers[modifierName].setOffset(arg);\n          }\n        },\n        setAll: function setAll(arg) {\n          var interaction = arg.interaction,\n              statuses = arg.statuses,\n              preEnd = arg.preEnd,\n              requireEndOnly = arg.requireEndOnly;\n          var result = {\n            dx: 0,\n            dy: 0,\n            changed: false,\n            locked: false,\n            shouldMove: true\n          };\n          arg.modifiedCoords = extend({}, arg.pageCoords);\n\n          for (var _i2 = 0; _i2 < modifiers.names.length; _i2++) {\n            var _ref2;\n\n            _ref2 = modifiers.names[_i2];\n            var modifierName = _ref2;\n            var modifier = modifiers[modifierName];\n            var options = interaction.target.options[interaction.prepared.name][modifierName];\n\n            if (!shouldDo(options, preEnd, requireEndOnly)) {\n              continue;\n            }\n\n            arg.status = arg.status = statuses[modifierName];\n            arg.options = options;\n            arg.offset = arg.interaction.modifierOffsets[modifierName];\n            modifier.set(arg);\n\n            if (arg.status.locked) {\n              arg.modifiedCoords.x += arg.status.dx;\n              arg.modifiedCoords.y += arg.status.dy;\n              result.dx += arg.status.dx;\n              result.dy += arg.status.dy;\n              result.locked = true;\n            }\n          } // a move should be fired if:\n          //  - there are no modifiers enabled,\n          //  - no modifiers are \"locked\" i.e. have changed the pointer's coordinates, or\n          //  - the locked coords have changed since the last pointer move\n\n\n          result.shouldMove = !arg.status || !result.locked || arg.status.changed;\n          return result;\n        },\n        resetStatuses: function resetStatuses(statuses) {\n          for (var _i3 = 0; _i3 < modifiers.names.length; _i3++) {\n            var _ref3;\n\n            _ref3 = modifiers.names[_i3];\n            var modifierName = _ref3;\n            var status = statuses[modifierName] || {};\n            status.dx = status.dy = 0;\n            status.modifiedX = status.modifiedY = NaN;\n            status.locked = false;\n            status.changed = true;\n            statuses[modifierName] = status;\n          }\n\n          return statuses;\n        },\n        start: function start(_ref4, signalName) {\n          var interaction = _ref4.interaction;\n          var arg = {\n            interaction: interaction,\n            pageCoords: (signalName === 'action-resume' ? interaction.curCoords : interaction.startCoords).page,\n            startOffset: interaction.startOffset,\n            statuses: interaction.modifierStatuses,\n            preEnd: false,\n            requireEndOnly: false\n          };\n          modifiers.setOffsets(arg);\n          modifiers.resetStatuses(arg.statuses);\n          arg.pageCoords = extend({}, interaction.startCoords.page);\n          interaction.modifierResult = modifiers.setAll(arg);\n        },\n        beforeMove: function beforeMove(_ref5) {\n          var interaction = _ref5.interaction,\n              preEnd = _ref5.preEnd,\n              interactingBeforeMove = _ref5.interactingBeforeMove;\n          var modifierResult = modifiers.setAll({\n            interaction: interaction,\n            preEnd: preEnd,\n            pageCoords: interaction.curCoords.page,\n            statuses: interaction.modifierStatuses,\n            requireEndOnly: false\n          }); // don't fire an action move if a modifier would keep the event in the same\n          // cordinates as before\n\n          if (!modifierResult.shouldMove && interactingBeforeMove) {\n            interaction._dontFireMove = true;\n          }\n\n          interaction.modifierResult = modifierResult;\n        },\n        end: function end(_ref6) {\n          var interaction = _ref6.interaction,\n              event = _ref6.event;\n\n          for (var _i4 = 0; _i4 < modifiers.names.length; _i4++) {\n            var _ref7;\n\n            _ref7 = modifiers.names[_i4];\n            var modifierName = _ref7;\n            var options = interaction.target.options[interaction.prepared.name][modifierName]; // if the endOnly option is true for any modifier\n\n            if (shouldDo(options, true, true)) {\n              // fire a move event at the modified coordinates\n              interaction.doMove({\n                event: event,\n                preEnd: true\n              });\n              break;\n            }\n          }\n        },\n        setXY: function setXY(arg) {\n          var iEvent = arg.iEvent,\n              interaction = arg.interaction;\n          var modifierArg = extend({}, arg);\n\n          for (var i = 0; i < modifiers.names.length; i++) {\n            var modifierName = modifiers.names[i];\n            modifierArg.options = interaction.target.options[interaction.prepared.name][modifierName];\n\n            if (!modifierArg.options) {\n              continue;\n            }\n\n            var modifier = modifiers[modifierName];\n            modifierArg.status = interaction.modifierStatuses[modifierName];\n            iEvent[modifierName] = modifier.modifyCoords(modifierArg);\n          }\n        }\n      };\n      Interaction.signals.on('new', function (interaction) {\n        interaction.startOffset = {\n          left: 0,\n          right: 0,\n          top: 0,\n          bottom: 0\n        };\n        interaction.modifierOffsets = {};\n        interaction.modifierStatuses = modifiers.resetStatuses({});\n        interaction.modifierResult = null;\n      });\n      Interaction.signals.on('action-start', modifiers.start);\n      Interaction.signals.on('action-resume', modifiers.start);\n      Interaction.signals.on('before-action-move', modifiers.beforeMove);\n      Interaction.signals.on('action-end', modifiers.end);\n      InteractEvent.signals.on('set-xy', modifiers.setXY);\n\n      function shouldDo(options, preEnd, requireEndOnly) {\n        return options && options.enabled && (preEnd || !options.endOnly) && (!requireEndOnly || options.endOnly);\n      }\n\n      module.exports = modifiers;\n    }, {\n      \"../InteractEvent\": 3,\n      \"../Interaction\": 5,\n      \"../utils/extend\": 41\n    }],\n    24: [function (require, module, exports) {\n      'use strict';\n\n      var modifiers = require('./base');\n\n      var utils = require('../utils');\n\n      var defaultOptions = require('../defaultOptions');\n\n      var restrict = {\n        defaults: {\n          enabled: false,\n          endOnly: false,\n          restriction: null,\n          elementRect: null\n        },\n        setOffset: function setOffset(_ref) {\n          var rect = _ref.rect,\n              startOffset = _ref.startOffset,\n              options = _ref.options;\n          var elementRect = options && options.elementRect;\n          var offset = {};\n\n          if (rect && elementRect) {\n            offset.left = startOffset.left - rect.width * elementRect.left;\n            offset.top = startOffset.top - rect.height * elementRect.top;\n            offset.right = startOffset.right - rect.width * (1 - elementRect.right);\n            offset.bottom = startOffset.bottom - rect.height * (1 - elementRect.bottom);\n          } else {\n            offset.left = offset.top = offset.right = offset.bottom = 0;\n          }\n\n          return offset;\n        },\n        set: function set(_ref2) {\n          var modifiedCoords = _ref2.modifiedCoords,\n              interaction = _ref2.interaction,\n              status = _ref2.status,\n              options = _ref2.options;\n\n          if (!options) {\n            return status;\n          }\n\n          var page = status.useStatusXY ? {\n            x: status.x,\n            y: status.y\n          } : utils.extend({}, modifiedCoords);\n          var restriction = getRestrictionRect(options.restriction, interaction, page);\n\n          if (!restriction) {\n            return status;\n          }\n\n          status.dx = 0;\n          status.dy = 0;\n          status.locked = false;\n          var rect = restriction;\n          var modifiedX = page.x;\n          var modifiedY = page.y;\n          var offset = interaction.modifierOffsets.restrict; // object is assumed to have\n          // x, y, width, height or\n          // left, top, right, bottom\n\n          if ('x' in restriction && 'y' in restriction) {\n            modifiedX = Math.max(Math.min(rect.x + rect.width - offset.right, page.x), rect.x + offset.left);\n            modifiedY = Math.max(Math.min(rect.y + rect.height - offset.bottom, page.y), rect.y + offset.top);\n          } else {\n            modifiedX = Math.max(Math.min(rect.right - offset.right, page.x), rect.left + offset.left);\n            modifiedY = Math.max(Math.min(rect.bottom - offset.bottom, page.y), rect.top + offset.top);\n          }\n\n          status.dx = modifiedX - page.x;\n          status.dy = modifiedY - page.y;\n          status.changed = status.modifiedX !== modifiedX || status.modifiedY !== modifiedY;\n          status.locked = !!(status.dx || status.dy);\n          status.modifiedX = modifiedX;\n          status.modifiedY = modifiedY;\n        },\n        modifyCoords: function modifyCoords(_ref3) {\n          var page = _ref3.page,\n              client = _ref3.client,\n              status = _ref3.status,\n              phase = _ref3.phase,\n              options = _ref3.options;\n          var elementRect = options && options.elementRect;\n\n          if (options && options.enabled && !(phase === 'start' && elementRect && status.locked)) {\n            if (status.locked) {\n              page.x += status.dx;\n              page.y += status.dy;\n              client.x += status.dx;\n              client.y += status.dy;\n              return {\n                dx: status.dx,\n                dy: status.dy\n              };\n            }\n          }\n        },\n        getRestrictionRect: getRestrictionRect\n      };\n\n      function getRestrictionRect(value, interaction, page) {\n        if (utils.is.function(value)) {\n          return utils.resolveRectLike(value, interaction.target, interaction.element, [page.x, page.y, interaction]);\n        } else {\n          return utils.resolveRectLike(value, interaction.target, interaction.element);\n        }\n      }\n\n      modifiers.restrict = restrict;\n      modifiers.names.push('restrict');\n      defaultOptions.perAction.restrict = restrict.defaults;\n      module.exports = restrict;\n    }, {\n      \"../defaultOptions\": 18,\n      \"../utils\": 44,\n      \"./base\": 23\n    }],\n    25: [function (require, module, exports) {\n      'use strict'; // This module adds the options.resize.restrictEdges setting which sets min and\n      // max for the top, left, bottom and right edges of the target being resized.\n      //\n      // interact(target).resize({\n      //   edges: { top: true, left: true },\n      //   restrictEdges: {\n      //     inner: { top: 200, left: 200, right: 400, bottom: 400 },\n      //     outer: { top:   0, left:   0, right: 600, bottom: 600 },\n      //   },\n      // });\n\n      var modifiers = require('./base');\n\n      var utils = require('../utils');\n\n      var rectUtils = require('../utils/rect');\n\n      var defaultOptions = require('../defaultOptions');\n\n      var resize = require('../actions/resize');\n\n      var _require = require('./restrict'),\n          getRestrictionRect = _require.getRestrictionRect;\n\n      var noInner = {\n        top: +Infinity,\n        left: +Infinity,\n        bottom: -Infinity,\n        right: -Infinity\n      };\n      var noOuter = {\n        top: -Infinity,\n        left: -Infinity,\n        bottom: +Infinity,\n        right: +Infinity\n      };\n      var restrictEdges = {\n        defaults: {\n          enabled: false,\n          endOnly: false,\n          min: null,\n          max: null,\n          offset: null\n        },\n        setOffset: function setOffset(_ref) {\n          var interaction = _ref.interaction,\n              startOffset = _ref.startOffset,\n              options = _ref.options;\n\n          if (!options) {\n            return utils.extend({}, startOffset);\n          }\n\n          var offset = getRestrictionRect(options.offset, interaction, interaction.startCoords.page);\n\n          if (offset) {\n            return {\n              top: startOffset.top + offset.y,\n              left: startOffset.left + offset.x,\n              bottom: startOffset.bottom + offset.y,\n              right: startOffset.right + offset.x\n            };\n          }\n\n          return startOffset;\n        },\n        set: function set(_ref2) {\n          var modifiedCoords = _ref2.modifiedCoords,\n              interaction = _ref2.interaction,\n              status = _ref2.status,\n              offset = _ref2.offset,\n              options = _ref2.options;\n          var edges = interaction.prepared.linkedEdges || interaction.prepared.edges;\n\n          if (!interaction.interacting() || !edges) {\n            return;\n          }\n\n          var page = status.useStatusXY ? {\n            x: status.x,\n            y: status.y\n          } : utils.extend({}, modifiedCoords);\n          var inner = rectUtils.xywhToTlbr(getRestrictionRect(options.inner, interaction, page)) || noInner;\n          var outer = rectUtils.xywhToTlbr(getRestrictionRect(options.outer, interaction, page)) || noOuter;\n          var modifiedX = page.x;\n          var modifiedY = page.y;\n          status.dx = 0;\n          status.dy = 0;\n          status.locked = false;\n\n          if (edges.top) {\n            modifiedY = Math.min(Math.max(outer.top + offset.top, page.y), inner.top + offset.top);\n          } else if (edges.bottom) {\n            modifiedY = Math.max(Math.min(outer.bottom - offset.bottom, page.y), inner.bottom - offset.bottom);\n          }\n\n          if (edges.left) {\n            modifiedX = Math.min(Math.max(outer.left + offset.left, page.x), inner.left + offset.left);\n          } else if (edges.right) {\n            modifiedX = Math.max(Math.min(outer.right - offset.right, page.x), inner.right - offset.right);\n          }\n\n          status.dx = modifiedX - page.x;\n          status.dy = modifiedY - page.y;\n          status.changed = status.modifiedX !== modifiedX || status.modifiedY !== modifiedY;\n          status.locked = !!(status.dx || status.dy);\n          status.modifiedX = modifiedX;\n          status.modifiedY = modifiedY;\n        },\n        modifyCoords: function modifyCoords(_ref3) {\n          var page = _ref3.page,\n              client = _ref3.client,\n              status = _ref3.status,\n              phase = _ref3.phase,\n              options = _ref3.options;\n\n          if (options && options.enabled && !(phase === 'start' && status.locked)) {\n            if (status.locked) {\n              page.x += status.dx;\n              page.y += status.dy;\n              client.x += status.dx;\n              client.y += status.dy;\n              return {\n                dx: status.dx,\n                dy: status.dy\n              };\n            }\n          }\n        },\n        noInner: noInner,\n        noOuter: noOuter,\n        getRestrictionRect: getRestrictionRect\n      };\n      modifiers.restrictEdges = restrictEdges;\n      modifiers.names.push('restrictEdges');\n      defaultOptions.perAction.restrictEdges = restrictEdges.defaults;\n      resize.defaults.restrictEdges = restrictEdges.defaults;\n      module.exports = restrictEdges;\n    }, {\n      \"../actions/resize\": 10,\n      \"../defaultOptions\": 18,\n      \"../utils\": 44,\n      \"../utils/rect\": 51,\n      \"./base\": 23,\n      \"./restrict\": 24\n    }],\n    26: [function (require, module, exports) {\n      'use strict'; // This module adds the options.resize.restrictSize setting which sets min and\n      // max width and height for the target being resized.\n      //\n      // interact(target).resize({\n      //   edges: { top: true, left: true },\n      //   restrictSize: {\n      //     min: { width: -600, height: -600 },\n      //     max: { width:  600, height:  600 },\n      //   },\n      // });\n\n      var modifiers = require('./base');\n\n      var restrictEdges = require('./restrictEdges');\n\n      var utils = require('../utils');\n\n      var rectUtils = require('../utils/rect');\n\n      var defaultOptions = require('../defaultOptions');\n\n      var resize = require('../actions/resize');\n\n      var noMin = {\n        width: -Infinity,\n        height: -Infinity\n      };\n      var noMax = {\n        width: +Infinity,\n        height: +Infinity\n      };\n      var restrictSize = {\n        defaults: {\n          enabled: false,\n          endOnly: false,\n          min: null,\n          max: null\n        },\n        setOffset: function setOffset(_ref) {\n          var interaction = _ref.interaction;\n          return interaction.startOffset;\n        },\n        set: function set(arg) {\n          var interaction = arg.interaction,\n              options = arg.options;\n          var edges = interaction.prepared.linkedEdges || interaction.prepared.edges;\n\n          if (!interaction.interacting() || !edges) {\n            return;\n          }\n\n          var rect = rectUtils.xywhToTlbr(interaction.resizeRects.inverted);\n          var minSize = rectUtils.tlbrToXywh(restrictEdges.getRestrictionRect(options.min, interaction)) || noMin;\n          var maxSize = rectUtils.tlbrToXywh(restrictEdges.getRestrictionRect(options.max, interaction)) || noMax;\n          arg.options = {\n            enabled: options.enabled,\n            endOnly: options.endOnly,\n            inner: utils.extend({}, restrictEdges.noInner),\n            outer: utils.extend({}, restrictEdges.noOuter)\n          };\n\n          if (edges.top) {\n            arg.options.inner.top = rect.bottom - minSize.height;\n            arg.options.outer.top = rect.bottom - maxSize.height;\n          } else if (edges.bottom) {\n            arg.options.inner.bottom = rect.top + minSize.height;\n            arg.options.outer.bottom = rect.top + maxSize.height;\n          }\n\n          if (edges.left) {\n            arg.options.inner.left = rect.right - minSize.width;\n            arg.options.outer.left = rect.right - maxSize.width;\n          } else if (edges.right) {\n            arg.options.inner.right = rect.left + minSize.width;\n            arg.options.outer.right = rect.left + maxSize.width;\n          }\n\n          restrictEdges.set(arg);\n        },\n        modifyCoords: restrictEdges.modifyCoords\n      };\n      modifiers.restrictSize = restrictSize;\n      modifiers.names.push('restrictSize');\n      defaultOptions.perAction.restrictSize = restrictSize.defaults;\n      resize.defaults.restrictSize = restrictSize.defaults;\n      module.exports = restrictSize;\n    }, {\n      \"../actions/resize\": 10,\n      \"../defaultOptions\": 18,\n      \"../utils\": 44,\n      \"../utils/rect\": 51,\n      \"./base\": 23,\n      \"./restrictEdges\": 25\n    }],\n    27: [function (require, module, exports) {\n      'use strict';\n\n      var modifiers = require('./base');\n\n      var interact = require('../interact');\n\n      var utils = require('../utils');\n\n      var defaultOptions = require('../defaultOptions');\n\n      var snap = {\n        defaults: {\n          enabled: false,\n          endOnly: false,\n          range: Infinity,\n          targets: null,\n          offsets: null,\n          relativePoints: null\n        },\n        setOffset: function setOffset(_ref) {\n          var interaction = _ref.interaction,\n              interactable = _ref.interactable,\n              element = _ref.element,\n              rect = _ref.rect,\n              startOffset = _ref.startOffset,\n              options = _ref.options;\n          var offsets = [];\n          var optionsOrigin = utils.rectToXY(utils.resolveRectLike(options.origin));\n          var origin = optionsOrigin || utils.getOriginXY(interactable, element, interaction.prepared.name);\n          options = options || interactable.options[interaction.prepared.name].snap || {};\n          var snapOffset = void 0;\n\n          if (options.offset === 'startCoords') {\n            snapOffset = {\n              x: interaction.startCoords.page.x - origin.x,\n              y: interaction.startCoords.page.y - origin.y\n            };\n          } else {\n            var offsetRect = utils.resolveRectLike(options.offset, interactable, element, [interaction]);\n            snapOffset = utils.rectToXY(offsetRect) || {\n              x: 0,\n              y: 0\n            };\n          }\n\n          if (rect && options.relativePoints && options.relativePoints.length) {\n            for (var _i = 0; _i < options.relativePoints.length; _i++) {\n              var _ref3;\n\n              _ref3 = options.relativePoints[_i];\n              var _ref2 = _ref3;\n              var relativeX = _ref2.x;\n              var relativeY = _ref2.y;\n              offsets.push({\n                x: startOffset.left - rect.width * relativeX + snapOffset.x,\n                y: startOffset.top - rect.height * relativeY + snapOffset.y\n              });\n            }\n          } else {\n            offsets.push(snapOffset);\n          }\n\n          return offsets;\n        },\n        set: function set(_ref4) {\n          var interaction = _ref4.interaction,\n              modifiedCoords = _ref4.modifiedCoords,\n              status = _ref4.status,\n              options = _ref4.options,\n              offsets = _ref4.offset;\n          var targets = [];\n          var target = void 0;\n          var page = void 0;\n          var i = void 0;\n\n          if (status.useStatusXY) {\n            page = {\n              x: status.x,\n              y: status.y\n            };\n          } else {\n            var origin = utils.getOriginXY(interaction.target, interaction.element, interaction.prepared.name);\n            page = utils.extend({}, modifiedCoords);\n            page.x -= origin.x;\n            page.y -= origin.y;\n          }\n\n          status.realX = page.x;\n          status.realY = page.y;\n          var len = options.targets ? options.targets.length : 0;\n\n          for (var _i2 = 0; _i2 < offsets.length; _i2++) {\n            var _ref6;\n\n            _ref6 = offsets[_i2];\n            var _ref5 = _ref6;\n            var offsetX = _ref5.x;\n            var offsetY = _ref5.y;\n            var relativeX = page.x - offsetX;\n            var relativeY = page.y - offsetY;\n\n            for (var _i3 = 0; _i3 < (options.targets || []).length; _i3++) {\n              var _ref7;\n\n              _ref7 = (options.targets || [])[_i3];\n              var snapTarget = _ref7;\n\n              if (utils.is.function(snapTarget)) {\n                target = snapTarget(relativeX, relativeY, interaction);\n              } else {\n                target = snapTarget;\n              }\n\n              if (!target) {\n                continue;\n              }\n\n              targets.push({\n                x: utils.is.number(target.x) ? target.x + offsetX : relativeX,\n                y: utils.is.number(target.y) ? target.y + offsetY : relativeY,\n                range: utils.is.number(target.range) ? target.range : options.range\n              });\n            }\n          }\n\n          var closest = {\n            target: null,\n            inRange: false,\n            distance: 0,\n            range: 0,\n            dx: 0,\n            dy: 0\n          };\n\n          for (i = 0, len = targets.length; i < len; i++) {\n            target = targets[i];\n            var range = target.range;\n            var dx = target.x - page.x;\n            var dy = target.y - page.y;\n            var distance = utils.hypot(dx, dy);\n            var inRange = distance <= range; // Infinite targets count as being out of range\n            // compared to non infinite ones that are in range\n\n            if (range === Infinity && closest.inRange && closest.range !== Infinity) {\n              inRange = false;\n            }\n\n            if (!closest.target || (inRange // is the closest target in range?\n            ? closest.inRange && range !== Infinity // the pointer is relatively deeper in this target\n            ? distance / range < closest.distance / closest.range // this target has Infinite range and the closest doesn't\n            : range === Infinity && closest.range !== Infinity || // OR this target is closer that the previous closest\n            distance < closest.distance : // The other is not in range and the pointer is closer to this target\n            !closest.inRange && distance < closest.distance)) {\n              closest.target = target;\n              closest.distance = distance;\n              closest.range = range;\n              closest.inRange = inRange;\n              closest.dx = dx;\n              closest.dy = dy;\n              status.range = range;\n            }\n          }\n\n          var snapChanged = void 0;\n\n          if (closest.target) {\n            snapChanged = status.modifiedX !== closest.target.x || status.modifiedY !== closest.target.y;\n            status.modifiedX = closest.target.x;\n            status.modifiedY = closest.target.y;\n          } else {\n            snapChanged = true;\n            status.modifiedX = NaN;\n            status.modifiedY = NaN;\n          }\n\n          status.dx = closest.dx;\n          status.dy = closest.dy;\n          status.changed = snapChanged || closest.inRange && !status.locked;\n          status.locked = closest.inRange;\n        },\n        modifyCoords: function modifyCoords(_ref8) {\n          var page = _ref8.page,\n              client = _ref8.client,\n              status = _ref8.status,\n              phase = _ref8.phase,\n              options = _ref8.options;\n          var relativePoints = options && options.relativePoints;\n\n          if (options && options.enabled && !(phase === 'start' && relativePoints && relativePoints.length)) {\n            if (status.locked) {\n              page.x += status.dx;\n              page.y += status.dy;\n              client.x += status.dx;\n              client.y += status.dy;\n            }\n\n            return {\n              range: status.range,\n              locked: status.locked,\n              x: status.modifiedX,\n              y: status.modifiedY,\n              realX: status.realX,\n              realY: status.realY,\n              dx: status.dx,\n              dy: status.dy\n            };\n          }\n        }\n      };\n\n      interact.createSnapGrid = function (grid) {\n        return function (x, y) {\n          var limits = grid.limits || {\n            left: -Infinity,\n            right: Infinity,\n            top: -Infinity,\n            bottom: Infinity\n          };\n          var offsetX = 0;\n          var offsetY = 0;\n\n          if (utils.is.object(grid.offset)) {\n            offsetX = grid.offset.x;\n            offsetY = grid.offset.y;\n          }\n\n          var gridx = Math.round((x - offsetX) / grid.x);\n          var gridy = Math.round((y - offsetY) / grid.y);\n          var newX = Math.max(limits.left, Math.min(limits.right, gridx * grid.x + offsetX));\n          var newY = Math.max(limits.top, Math.min(limits.bottom, gridy * grid.y + offsetY));\n          return {\n            x: newX,\n            y: newY,\n            range: grid.range\n          };\n        };\n      };\n\n      modifiers.snap = snap;\n      modifiers.names.push('snap');\n      defaultOptions.perAction.snap = snap.defaults;\n      module.exports = snap;\n    }, {\n      \"../defaultOptions\": 18,\n      \"../interact\": 21,\n      \"../utils\": 44,\n      \"./base\": 23\n    }],\n    28: [function (require, module, exports) {\n      'use strict'; // This module allows snapping of the size of targets during resize\n      // interactions.\n\n      var modifiers = require('./base');\n\n      var snap = require('./snap');\n\n      var defaultOptions = require('../defaultOptions');\n\n      var resize = require('../actions/resize');\n\n      var utils = require('../utils/');\n\n      var snapSize = {\n        defaults: {\n          enabled: false,\n          endOnly: false,\n          range: Infinity,\n          targets: null,\n          offsets: null\n        },\n        setOffset: function setOffset(arg) {\n          var interaction = arg.interaction,\n              options = arg.options;\n          var edges = interaction.prepared.edges;\n\n          if (!edges) {\n            return;\n          }\n\n          arg.options = {\n            relativePoints: [{\n              x: edges.left ? 0 : 1,\n              y: edges.top ? 0 : 1\n            }],\n            origin: {\n              x: 0,\n              y: 0\n            },\n            offset: 'self',\n            range: options.range\n          };\n          var offsets = snap.setOffset(arg);\n          arg.options = options;\n          return offsets;\n        },\n        set: function set(arg) {\n          var interaction = arg.interaction,\n              options = arg.options,\n              offset = arg.offset,\n              modifiedCoords = arg.modifiedCoords;\n          var page = utils.extend({}, modifiedCoords);\n          var relativeX = page.x - offset[0].x;\n          var relativeY = page.y - offset[0].y;\n          arg.options = utils.extend({}, options);\n          arg.options.targets = [];\n\n          for (var _i = 0; _i < (options.targets || []).length; _i++) {\n            var _ref;\n\n            _ref = (options.targets || [])[_i];\n            var snapTarget = _ref;\n            var target = void 0;\n\n            if (utils.is.function(snapTarget)) {\n              target = snapTarget(relativeX, relativeY, interaction);\n            } else {\n              target = snapTarget;\n            }\n\n            if (!target) {\n              continue;\n            }\n\n            if ('width' in target && 'height' in target) {\n              target.x = target.width;\n              target.y = target.height;\n            }\n\n            arg.options.targets.push(target);\n          }\n\n          snap.set(arg);\n        },\n        modifyCoords: function modifyCoords(arg) {\n          var options = arg.options;\n          arg.options = utils.extend({}, options);\n          arg.options.enabled = options.enabled;\n          arg.options.relativePoints = [null];\n          snap.modifyCoords(arg);\n        }\n      };\n      modifiers.snapSize = snapSize;\n      modifiers.names.push('snapSize');\n      defaultOptions.perAction.snapSize = snapSize.defaults;\n      resize.defaults.snapSize = snapSize.defaults;\n      module.exports = snapSize;\n    }, {\n      \"../actions/resize\": 10,\n      \"../defaultOptions\": 18,\n      \"../utils/\": 44,\n      \"./base\": 23,\n      \"./snap\": 27\n    }],\n    29: [function (require, module, exports) {\n      'use strict';\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      var pointerUtils = require('../utils/pointerUtils');\n\n      module.exports = function () {\n        /** */\n        function PointerEvent(type, pointer, event, eventTarget, interaction) {\n          _classCallCheck(this, PointerEvent);\n\n          pointerUtils.pointerExtend(this, event);\n\n          if (event !== pointer) {\n            pointerUtils.pointerExtend(this, pointer);\n          }\n\n          this.interaction = interaction;\n          this.timeStamp = new Date().getTime();\n          this.originalEvent = event;\n          this.type = type;\n          this.pointerId = pointerUtils.getPointerId(pointer);\n          this.pointerType = pointerUtils.getPointerType(pointer);\n          this.target = eventTarget;\n          this.currentTarget = null;\n\n          if (type === 'tap') {\n            var pointerIndex = interaction.getPointerIndex(pointer);\n            this.dt = this.timeStamp - interaction.downTimes[pointerIndex];\n            var interval = this.timeStamp - interaction.tapTime;\n            this.double = !!(interaction.prevTap && interaction.prevTap.type !== 'doubletap' && interaction.prevTap.target === this.target && interval < 500);\n          } else if (type === 'doubletap') {\n            this.dt = pointer.timeStamp - interaction.tapTime;\n          }\n        }\n\n        PointerEvent.prototype.subtractOrigin = function subtractOrigin(_ref) {\n          var originX = _ref.x,\n              originY = _ref.y;\n          this.pageX -= originX;\n          this.pageY -= originY;\n          this.clientX -= originX;\n          this.clientY -= originY;\n          return this;\n        };\n\n        PointerEvent.prototype.addOrigin = function addOrigin(_ref2) {\n          var originX = _ref2.x,\n              originY = _ref2.y;\n          this.pageX += originX;\n          this.pageY += originY;\n          this.clientX += originX;\n          this.clientY += originY;\n          return this;\n        };\n        /** */\n\n\n        PointerEvent.prototype.preventDefault = function preventDefault() {\n          this.originalEvent.preventDefault();\n        };\n        /** */\n\n\n        PointerEvent.prototype.stopPropagation = function stopPropagation() {\n          this.propagationStopped = true;\n        };\n        /** */\n\n\n        PointerEvent.prototype.stopImmediatePropagation = function stopImmediatePropagation() {\n          this.immediatePropagationStopped = this.propagationStopped = true;\n        };\n\n        return PointerEvent;\n      }();\n    }, {\n      \"../utils/pointerUtils\": 49\n    }],\n    30: [function (require, module, exports) {\n      'use strict';\n\n      var PointerEvent = require('./PointerEvent');\n\n      var Interaction = require('../Interaction');\n\n      var utils = require('../utils');\n\n      var defaults = require('../defaultOptions');\n\n      var signals = require('../utils/Signals').new();\n\n      var simpleSignals = ['down', 'up', 'cancel'];\n      var simpleEvents = ['down', 'up', 'cancel'];\n      var pointerEvents = {\n        PointerEvent: PointerEvent,\n        fire: fire,\n        collectEventTargets: collectEventTargets,\n        signals: signals,\n        defaults: {\n          holdDuration: 600,\n          ignoreFrom: null,\n          allowFrom: null,\n          origin: {\n            x: 0,\n            y: 0\n          }\n        },\n        types: ['down', 'move', 'up', 'cancel', 'tap', 'doubletap', 'hold']\n      };\n\n      function fire(arg) {\n        var interaction = arg.interaction,\n            pointer = arg.pointer,\n            event = arg.event,\n            eventTarget = arg.eventTarget,\n            _arg$type = arg.type,\n            type = _arg$type === undefined ? arg.pointerEvent.type : _arg$type,\n            _arg$targets = arg.targets,\n            targets = _arg$targets === undefined ? collectEventTargets(arg) : _arg$targets,\n            _arg$pointerEvent = arg.pointerEvent,\n            pointerEvent = _arg$pointerEvent === undefined ? new PointerEvent(type, pointer, event, eventTarget, interaction) : _arg$pointerEvent;\n        var signalArg = {\n          interaction: interaction,\n          pointer: pointer,\n          event: event,\n          eventTarget: eventTarget,\n          targets: targets,\n          type: type,\n          pointerEvent: pointerEvent\n        };\n\n        for (var i = 0; i < targets.length; i++) {\n          var target = targets[i];\n\n          for (var prop in target.props || {}) {\n            pointerEvent[prop] = target.props[prop];\n          }\n\n          var origin = utils.getOriginXY(target.eventable, target.element);\n          pointerEvent.subtractOrigin(origin);\n          pointerEvent.eventable = target.eventable;\n          pointerEvent.currentTarget = target.element;\n          target.eventable.fire(pointerEvent);\n          pointerEvent.addOrigin(origin);\n\n          if (pointerEvent.immediatePropagationStopped || pointerEvent.propagationStopped && i + 1 < targets.length && targets[i + 1].element !== pointerEvent.currentTarget) {\n            break;\n          }\n        }\n\n        signals.fire('fired', signalArg);\n\n        if (type === 'tap') {\n          // if pointerEvent should make a double tap, create and fire a doubletap\n          // PointerEvent and use that as the prevTap\n          var prevTap = pointerEvent.double ? fire({\n            interaction: interaction,\n            pointer: pointer,\n            event: event,\n            eventTarget: eventTarget,\n            type: 'doubletap'\n          }) : pointerEvent;\n          interaction.prevTap = prevTap;\n          interaction.tapTime = prevTap.timeStamp;\n        }\n\n        return pointerEvent;\n      }\n\n      function collectEventTargets(_ref) {\n        var interaction = _ref.interaction,\n            pointer = _ref.pointer,\n            event = _ref.event,\n            eventTarget = _ref.eventTarget,\n            type = _ref.type;\n        var pointerIndex = interaction.getPointerIndex(pointer); // do not fire a tap event if the pointer was moved before being lifted\n\n        if (type === 'tap' && (interaction.pointerWasMoved // or if the pointerup target is different to the pointerdown target\n        || !(interaction.downTargets[pointerIndex] && interaction.downTargets[pointerIndex] === eventTarget))) {\n          return [];\n        }\n\n        var path = utils.getPath(eventTarget);\n        var signalArg = {\n          interaction: interaction,\n          pointer: pointer,\n          event: event,\n          eventTarget: eventTarget,\n          type: type,\n          path: path,\n          targets: [],\n          element: null\n        };\n\n        for (var _i = 0; _i < path.length; _i++) {\n          var _ref2;\n\n          _ref2 = path[_i];\n          var element = _ref2;\n          signalArg.element = element;\n          signals.fire('collect-targets', signalArg);\n        }\n\n        if (type === 'hold') {\n          signalArg.targets = signalArg.targets.filter(function (target) {\n            return target.eventable.options.holdDuration === interaction.holdTimers[pointerIndex].duration;\n          });\n        }\n\n        return signalArg.targets;\n      }\n\n      Interaction.signals.on('update-pointer-down', function (_ref3) {\n        var interaction = _ref3.interaction,\n            pointerIndex = _ref3.pointerIndex;\n        interaction.holdTimers[pointerIndex] = {\n          duration: Infinity,\n          timeout: null\n        };\n      });\n      Interaction.signals.on('remove-pointer', function (_ref4) {\n        var interaction = _ref4.interaction,\n            pointerIndex = _ref4.pointerIndex;\n        interaction.holdTimers.splice(pointerIndex, 1);\n      });\n      Interaction.signals.on('move', function (_ref5) {\n        var interaction = _ref5.interaction,\n            pointer = _ref5.pointer,\n            event = _ref5.event,\n            eventTarget = _ref5.eventTarget,\n            duplicateMove = _ref5.duplicateMove;\n        var pointerIndex = interaction.getPointerIndex(pointer);\n\n        if (!duplicateMove && (!interaction.pointerIsDown || interaction.pointerWasMoved)) {\n          if (interaction.pointerIsDown) {\n            clearTimeout(interaction.holdTimers[pointerIndex].timeout);\n          }\n\n          fire({\n            interaction: interaction,\n            pointer: pointer,\n            event: event,\n            eventTarget: eventTarget,\n            type: 'move'\n          });\n        }\n      });\n      Interaction.signals.on('down', function (_ref6) {\n        var interaction = _ref6.interaction,\n            pointer = _ref6.pointer,\n            event = _ref6.event,\n            eventTarget = _ref6.eventTarget,\n            pointerIndex = _ref6.pointerIndex;\n        var timer = interaction.holdTimers[pointerIndex];\n        var path = utils.getPath(eventTarget);\n        var signalArg = {\n          interaction: interaction,\n          pointer: pointer,\n          event: event,\n          eventTarget: eventTarget,\n          type: 'hold',\n          targets: [],\n          path: path,\n          element: null\n        };\n\n        for (var _i2 = 0; _i2 < path.length; _i2++) {\n          var _ref7;\n\n          _ref7 = path[_i2];\n          var element = _ref7;\n          signalArg.element = element;\n          signals.fire('collect-targets', signalArg);\n        }\n\n        if (!signalArg.targets.length) {\n          return;\n        }\n\n        var minDuration = Infinity;\n\n        for (var _i3 = 0; _i3 < signalArg.targets.length; _i3++) {\n          var _ref8;\n\n          _ref8 = signalArg.targets[_i3];\n          var target = _ref8;\n          var holdDuration = target.eventable.options.holdDuration;\n\n          if (holdDuration < minDuration) {\n            minDuration = holdDuration;\n          }\n        }\n\n        timer.duration = minDuration;\n        timer.timeout = setTimeout(function () {\n          fire({\n            interaction: interaction,\n            eventTarget: eventTarget,\n            pointer: pointer,\n            event: event,\n            type: 'hold'\n          });\n        }, minDuration);\n      });\n      Interaction.signals.on('up', function (_ref9) {\n        var interaction = _ref9.interaction,\n            pointer = _ref9.pointer,\n            event = _ref9.event,\n            eventTarget = _ref9.eventTarget;\n\n        if (!interaction.pointerWasMoved) {\n          fire({\n            interaction: interaction,\n            eventTarget: eventTarget,\n            pointer: pointer,\n            event: event,\n            type: 'tap'\n          });\n        }\n      });\n      var _arr = ['up', 'cancel'];\n\n      for (var _i4 = 0; _i4 < _arr.length; _i4++) {\n        var signalName = _arr[_i4];\n        Interaction.signals.on(signalName, function (_ref11) {\n          var interaction = _ref11.interaction,\n              pointerIndex = _ref11.pointerIndex;\n\n          if (interaction.holdTimers[pointerIndex]) {\n            clearTimeout(interaction.holdTimers[pointerIndex].timeout);\n          }\n        });\n      }\n\n      function createSignalListener(type) {\n        return function (_ref10) {\n          var interaction = _ref10.interaction,\n              pointer = _ref10.pointer,\n              event = _ref10.event,\n              eventTarget = _ref10.eventTarget;\n          fire({\n            interaction: interaction,\n            eventTarget: eventTarget,\n            pointer: pointer,\n            event: event,\n            type: type\n          });\n        };\n      }\n\n      for (var i = 0; i < simpleSignals.length; i++) {\n        Interaction.signals.on(simpleSignals[i], createSignalListener(simpleEvents[i]));\n      }\n\n      Interaction.signals.on('new', function (interaction) {\n        interaction.prevTap = null; // the most recent tap event on this interaction\n\n        interaction.tapTime = 0; // time of the most recent tap event\n\n        interaction.holdTimers = []; // [{ duration, timeout }]\n      });\n      defaults.pointerEvents = pointerEvents.defaults;\n      module.exports = pointerEvents;\n    }, {\n      \"../Interaction\": 5,\n      \"../defaultOptions\": 18,\n      \"../utils\": 44,\n      \"../utils/Signals\": 34,\n      \"./PointerEvent\": 29\n    }],\n    31: [function (require, module, exports) {\n      'use strict';\n\n      var pointerEvents = require('./base');\n\n      var Interaction = require('../Interaction');\n\n      pointerEvents.signals.on('new', onNew);\n      pointerEvents.signals.on('fired', onFired);\n      var _arr = ['move', 'up', 'cancel', 'endall'];\n\n      for (var _i = 0; _i < _arr.length; _i++) {\n        var signal = _arr[_i];\n        Interaction.signals.on(signal, endHoldRepeat);\n      }\n\n      function onNew(_ref) {\n        var pointerEvent = _ref.pointerEvent;\n\n        if (pointerEvent.type !== 'hold') {\n          return;\n        }\n\n        pointerEvent.count = (pointerEvent.count || 0) + 1;\n      }\n\n      function onFired(_ref2) {\n        var interaction = _ref2.interaction,\n            pointerEvent = _ref2.pointerEvent,\n            eventTarget = _ref2.eventTarget,\n            targets = _ref2.targets;\n\n        if (pointerEvent.type !== 'hold' || !targets.length) {\n          return;\n        } // get the repeat interval from the first eventable\n\n\n        var interval = targets[0].eventable.options.holdRepeatInterval; // don't repeat if the interval is 0 or less\n\n        if (interval <= 0) {\n          return;\n        } // set a timeout to fire the holdrepeat event\n\n\n        interaction.holdIntervalHandle = setTimeout(function () {\n          pointerEvents.fire({\n            interaction: interaction,\n            eventTarget: eventTarget,\n            type: 'hold',\n            pointer: pointerEvent,\n            event: pointerEvent\n          });\n        }, interval);\n      }\n\n      function endHoldRepeat(_ref3) {\n        var interaction = _ref3.interaction; // set the interaction's holdStopTime property\n        // to stop further holdRepeat events\n\n        if (interaction.holdIntervalHandle) {\n          clearInterval(interaction.holdIntervalHandle);\n          interaction.holdIntervalHandle = null;\n        }\n      } // don't repeat by default\n\n\n      pointerEvents.defaults.holdRepeatInterval = 0;\n      pointerEvents.types.push('holdrepeat');\n      module.exports = {\n        onNew: onNew,\n        onFired: onFired,\n        endHoldRepeat: endHoldRepeat\n      };\n    }, {\n      \"../Interaction\": 5,\n      \"./base\": 30\n    }],\n    32: [function (require, module, exports) {\n      'use strict';\n\n      var pointerEvents = require('./base');\n\n      var Interactable = require('../Interactable');\n\n      var is = require('../utils/is');\n\n      var scope = require('../scope');\n\n      var extend = require('../utils/extend');\n\n      var _require = require('../utils/arr'),\n          merge = _require.merge;\n\n      pointerEvents.signals.on('collect-targets', function (_ref) {\n        var targets = _ref.targets,\n            element = _ref.element,\n            type = _ref.type,\n            eventTarget = _ref.eventTarget;\n        scope.interactables.forEachMatch(element, function (interactable) {\n          var eventable = interactable.events;\n          var options = eventable.options;\n\n          if (eventable[type] && is.element(element) && interactable.testIgnoreAllow(options, element, eventTarget)) {\n            targets.push({\n              element: element,\n              eventable: eventable,\n              props: {\n                interactable: interactable\n              }\n            });\n          }\n        });\n      });\n      Interactable.signals.on('new', function (_ref2) {\n        var interactable = _ref2.interactable;\n\n        interactable.events.getRect = function (element) {\n          return interactable.getRect(element);\n        };\n      });\n      Interactable.signals.on('set', function (_ref3) {\n        var interactable = _ref3.interactable,\n            options = _ref3.options;\n        extend(interactable.events.options, pointerEvents.defaults);\n        extend(interactable.events.options, options);\n      });\n      merge(Interactable.eventTypes, pointerEvents.types);\n\n      Interactable.prototype.pointerEvents = function (options) {\n        extend(this.events.options, options);\n        return this;\n      };\n\n      var __backCompatOption = Interactable.prototype._backCompatOption;\n\n      Interactable.prototype._backCompatOption = function (optionName, newValue) {\n        var ret = __backCompatOption.call(this, optionName, newValue);\n\n        if (ret === this) {\n          this.events.options[optionName] = newValue;\n        }\n\n        return ret;\n      };\n\n      Interactable.settingsMethods.push('pointerEvents');\n    }, {\n      \"../Interactable\": 4,\n      \"../scope\": 33,\n      \"../utils/arr\": 35,\n      \"../utils/extend\": 41,\n      \"../utils/is\": 46,\n      \"./base\": 30\n    }],\n    33: [function (require, module, exports) {\n      'use strict';\n\n      var utils = require('./utils');\n\n      var events = require('./utils/events');\n\n      var signals = require('./utils/Signals').new();\n\n      var _require = require('./utils/window'),\n          getWindow = _require.getWindow;\n\n      var scope = {\n        signals: signals,\n        events: events,\n        utils: utils,\n        // main document\n        document: require('./utils/domObjects').document,\n        // all documents being listened to\n        documents: [],\n        addDocument: function addDocument(doc, win) {\n          // do nothing if document is already known\n          if (utils.contains(scope.documents, doc)) {\n            return false;\n          }\n\n          win = win || getWindow(doc);\n          scope.documents.push(doc);\n          events.documents.push(doc); // don't add an unload event for the main document\n          // so that the page may be cached in browser history\n\n          if (doc !== scope.document) {\n            events.add(win, 'unload', scope.onWindowUnload);\n          }\n\n          signals.fire('add-document', {\n            doc: doc,\n            win: win\n          });\n        },\n        removeDocument: function removeDocument(doc, win) {\n          var index = scope.documents.indexOf(doc);\n          win = win || getWindow(doc);\n          events.remove(win, 'unload', scope.onWindowUnload);\n          scope.documents.splice(index, 1);\n          events.documents.splice(index, 1);\n          signals.fire('remove-document', {\n            win: win,\n            doc: doc\n          });\n        },\n        onWindowUnload: function onWindowUnload() {\n          scope.removeDocument(this.document, this);\n        }\n      };\n      module.exports = scope;\n    }, {\n      \"./utils\": 44,\n      \"./utils/Signals\": 34,\n      \"./utils/domObjects\": 38,\n      \"./utils/events\": 40,\n      \"./utils/window\": 52\n    }],\n    34: [function (require, module, exports) {\n      \"use strict\";\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      var Signals = function () {\n        function Signals() {\n          _classCallCheck(this, Signals);\n\n          this.listeners = {// signalName: [listeners],\n          };\n        }\n\n        Signals.prototype.on = function on(name, listener) {\n          if (!this.listeners[name]) {\n            this.listeners[name] = [listener];\n            return;\n          }\n\n          this.listeners[name].push(listener);\n        };\n\n        Signals.prototype.off = function off(name, listener) {\n          if (!this.listeners[name]) {\n            return;\n          }\n\n          var index = this.listeners[name].indexOf(listener);\n\n          if (index !== -1) {\n            this.listeners[name].splice(index, 1);\n          }\n        };\n\n        Signals.prototype.fire = function fire(name, arg) {\n          var targetListeners = this.listeners[name];\n\n          if (!targetListeners) {\n            return;\n          }\n\n          for (var _i = 0; _i < targetListeners.length; _i++) {\n            var _ref;\n\n            _ref = targetListeners[_i];\n            var listener = _ref;\n\n            if (listener(arg, name) === false) {\n              return;\n            }\n          }\n        };\n\n        return Signals;\n      }();\n\n      Signals.new = function () {\n        return new Signals();\n      };\n\n      module.exports = Signals;\n    }, {}],\n    35: [function (require, module, exports) {\n      \"use strict\";\n\n      function contains(array, target) {\n        return array.indexOf(target) !== -1;\n      }\n\n      function merge(target, source) {\n        for (var _i = 0; _i < source.length; _i++) {\n          var _ref;\n\n          _ref = source[_i];\n          var item = _ref;\n          target.push(item);\n        }\n\n        return target;\n      }\n\n      module.exports = {\n        contains: contains,\n        merge: merge\n      };\n    }, {}],\n    36: [function (require, module, exports) {\n      'use strict';\n\n      var _require = require('./window'),\n          window = _require.window;\n\n      var is = require('./is');\n\n      var domObjects = require('./domObjects');\n\n      var Element = domObjects.Element;\n      var navigator = window.navigator;\n      var browser = {\n        // Does the browser support touch input?\n        supportsTouch: !!('ontouchstart' in window || is.function(window.DocumentTouch) && domObjects.document instanceof window.DocumentTouch),\n        // Does the browser support PointerEvents\n        supportsPointerEvent: !!domObjects.PointerEvent,\n        isIOS: /iP(hone|od|ad)/.test(navigator.platform),\n        // scrolling doesn't change the result of getClientRects on iOS 7\n        isIOS7: /iP(hone|od|ad)/.test(navigator.platform) && /OS 7[^\\d]/.test(navigator.appVersion),\n        isIe9: /MSIE 9/.test(navigator.userAgent),\n        // prefix matchesSelector\n        prefixedMatchesSelector: 'matches' in Element.prototype ? 'matches' : 'webkitMatchesSelector' in Element.prototype ? 'webkitMatchesSelector' : 'mozMatchesSelector' in Element.prototype ? 'mozMatchesSelector' : 'oMatchesSelector' in Element.prototype ? 'oMatchesSelector' : 'msMatchesSelector',\n        pEventTypes: domObjects.PointerEvent ? domObjects.PointerEvent === window.MSPointerEvent ? {\n          up: 'MSPointerUp',\n          down: 'MSPointerDown',\n          over: 'mouseover',\n          out: 'mouseout',\n          move: 'MSPointerMove',\n          cancel: 'MSPointerCancel'\n        } : {\n          up: 'pointerup',\n          down: 'pointerdown',\n          over: 'pointerover',\n          out: 'pointerout',\n          move: 'pointermove',\n          cancel: 'pointercancel'\n        } : null,\n        // because Webkit and Opera still use 'mousewheel' event type\n        wheelEvent: 'onmousewheel' in domObjects.document ? 'mousewheel' : 'wheel'\n      }; // Opera Mobile must be handled differently\n\n      browser.isOperaMobile = navigator.appName === 'Opera' && browser.supportsTouch && navigator.userAgent.match('Presto');\n      module.exports = browser;\n    }, {\n      \"./domObjects\": 38,\n      \"./is\": 46,\n      \"./window\": 52\n    }],\n    37: [function (require, module, exports) {\n      'use strict';\n\n      var is = require('./is');\n\n      module.exports = function clone(source) {\n        var dest = {};\n\n        for (var prop in source) {\n          if (is.plainObject(source[prop])) {\n            dest[prop] = clone(source[prop]);\n          } else {\n            dest[prop] = source[prop];\n          }\n        }\n\n        return dest;\n      };\n    }, {\n      \"./is\": 46\n    }],\n    38: [function (require, module, exports) {\n      'use strict';\n\n      var domObjects = {};\n\n      var win = require('./window').window;\n\n      function blank() {}\n\n      domObjects.document = win.document;\n      domObjects.DocumentFragment = win.DocumentFragment || blank;\n      domObjects.SVGElement = win.SVGElement || blank;\n      domObjects.SVGSVGElement = win.SVGSVGElement || blank;\n      domObjects.SVGElementInstance = win.SVGElementInstance || blank;\n      domObjects.Element = win.Element || blank;\n      domObjects.HTMLElement = win.HTMLElement || domObjects.Element;\n      domObjects.Event = win.Event;\n      domObjects.Touch = win.Touch || blank;\n      domObjects.PointerEvent = win.PointerEvent || win.MSPointerEvent;\n      module.exports = domObjects;\n    }, {\n      \"./window\": 52\n    }],\n    39: [function (require, module, exports) {\n      'use strict';\n\n      var win = require('./window');\n\n      var browser = require('./browser');\n\n      var is = require('./is');\n\n      var domObjects = require('./domObjects');\n\n      var domUtils = {\n        nodeContains: function nodeContains(parent, child) {\n          while (child) {\n            if (child === parent) {\n              return true;\n            }\n\n            child = child.parentNode;\n          }\n\n          return false;\n        },\n        closest: function closest(element, selector) {\n          while (is.element(element)) {\n            if (domUtils.matchesSelector(element, selector)) {\n              return element;\n            }\n\n            element = domUtils.parentNode(element);\n          }\n\n          return null;\n        },\n        parentNode: function parentNode(node) {\n          var parent = node.parentNode;\n\n          if (is.docFrag(parent)) {\n            // skip past #shado-root fragments\n            while ((parent = parent.host) && is.docFrag(parent)) {\n              continue;\n            }\n\n            return parent;\n          }\n\n          return parent;\n        },\n        matchesSelector: function matchesSelector(element, selector) {\n          // remove /deep/ from selectors if shadowDOM polyfill is used\n          if (win.window !== win.realWindow) {\n            selector = selector.replace(/\\/deep\\//g, ' ');\n          }\n\n          return element[browser.prefixedMatchesSelector](selector);\n        },\n        // Test for the element that's \"above\" all other qualifiers\n        indexOfDeepestElement: function indexOfDeepestElement(elements) {\n          var deepestZoneParents = [];\n          var dropzoneParents = [];\n          var dropzone = void 0;\n          var deepestZone = elements[0];\n          var index = deepestZone ? 0 : -1;\n          var parent = void 0;\n          var child = void 0;\n          var i = void 0;\n          var n = void 0;\n\n          for (i = 1; i < elements.length; i++) {\n            dropzone = elements[i]; // an element might belong to multiple selector dropzones\n\n            if (!dropzone || dropzone === deepestZone) {\n              continue;\n            }\n\n            if (!deepestZone) {\n              deepestZone = dropzone;\n              index = i;\n              continue;\n            } // check if the deepest or current are document.documentElement or document.rootElement\n            // - if the current dropzone is, do nothing and continue\n\n\n            if (dropzone.parentNode === dropzone.ownerDocument) {\n              continue;\n            } // - if deepest is, update with the current dropzone and continue to next\n            else if (deepestZone.parentNode === dropzone.ownerDocument) {\n                deepestZone = dropzone;\n                index = i;\n                continue;\n              }\n\n            if (!deepestZoneParents.length) {\n              parent = deepestZone;\n\n              while (parent.parentNode && parent.parentNode !== parent.ownerDocument) {\n                deepestZoneParents.unshift(parent);\n                parent = parent.parentNode;\n              }\n            } // if this element is an svg element and the current deepest is\n            // an HTMLElement\n\n\n            if (deepestZone instanceof domObjects.HTMLElement && dropzone instanceof domObjects.SVGElement && !(dropzone instanceof domObjects.SVGSVGElement)) {\n              if (dropzone === deepestZone.parentNode) {\n                continue;\n              }\n\n              parent = dropzone.ownerSVGElement;\n            } else {\n              parent = dropzone;\n            }\n\n            dropzoneParents = [];\n\n            while (parent.parentNode !== parent.ownerDocument) {\n              dropzoneParents.unshift(parent);\n              parent = parent.parentNode;\n            }\n\n            n = 0; // get (position of last common ancestor) + 1\n\n            while (dropzoneParents[n] && dropzoneParents[n] === deepestZoneParents[n]) {\n              n++;\n            }\n\n            var parents = [dropzoneParents[n - 1], dropzoneParents[n], deepestZoneParents[n]];\n            child = parents[0].lastChild;\n\n            while (child) {\n              if (child === parents[1]) {\n                deepestZone = dropzone;\n                index = i;\n                deepestZoneParents = [];\n                break;\n              } else if (child === parents[2]) {\n                break;\n              }\n\n              child = child.previousSibling;\n            }\n          }\n\n          return index;\n        },\n        matchesUpTo: function matchesUpTo(element, selector, limit) {\n          while (is.element(element)) {\n            if (domUtils.matchesSelector(element, selector)) {\n              return true;\n            }\n\n            element = domUtils.parentNode(element);\n\n            if (element === limit) {\n              return domUtils.matchesSelector(element, selector);\n            }\n          }\n\n          return false;\n        },\n        getActualElement: function getActualElement(element) {\n          return element instanceof domObjects.SVGElementInstance ? element.correspondingUseElement : element;\n        },\n        getScrollXY: function getScrollXY(relevantWindow) {\n          relevantWindow = relevantWindow || win.window;\n          return {\n            x: relevantWindow.scrollX || relevantWindow.document.documentElement.scrollLeft,\n            y: relevantWindow.scrollY || relevantWindow.document.documentElement.scrollTop\n          };\n        },\n        getElementClientRect: function getElementClientRect(element) {\n          var clientRect = element instanceof domObjects.SVGElement ? element.getBoundingClientRect() : element.getClientRects()[0];\n          return clientRect && {\n            left: clientRect.left,\n            right: clientRect.right,\n            top: clientRect.top,\n            bottom: clientRect.bottom,\n            width: clientRect.width || clientRect.right - clientRect.left,\n            height: clientRect.height || clientRect.bottom - clientRect.top\n          };\n        },\n        getElementRect: function getElementRect(element) {\n          var clientRect = domUtils.getElementClientRect(element);\n\n          if (!browser.isIOS7 && clientRect) {\n            var scroll = domUtils.getScrollXY(win.getWindow(element));\n            clientRect.left += scroll.x;\n            clientRect.right += scroll.x;\n            clientRect.top += scroll.y;\n            clientRect.bottom += scroll.y;\n          }\n\n          return clientRect;\n        },\n        getPath: function getPath(element) {\n          var path = [];\n\n          while (element) {\n            path.push(element);\n            element = domUtils.parentNode(element);\n          }\n\n          return path;\n        },\n        trySelector: function trySelector(value) {\n          if (!is.string(value)) {\n            return false;\n          } // an exception will be raised if it is invalid\n\n\n          domObjects.document.querySelector(value);\n          return true;\n        }\n      };\n      module.exports = domUtils;\n    }, {\n      \"./browser\": 36,\n      \"./domObjects\": 38,\n      \"./is\": 46,\n      \"./window\": 52\n    }],\n    40: [function (require, module, exports) {\n      'use strict';\n\n      var is = require('./is');\n\n      var domUtils = require('./domUtils');\n\n      var pointerUtils = require('./pointerUtils');\n\n      var pExtend = require('./pointerExtend');\n\n      var _require = require('./window'),\n          window = _require.window;\n\n      var _require2 = require('./arr'),\n          contains = _require2.contains;\n\n      var elements = [];\n      var targets = []; // {\n      //   type: {\n      //     selectors: ['selector', ...],\n      //     contexts : [document, ...],\n      //     listeners: [[listener, capture, passive], ...]\n      //   }\n      //  }\n\n      var delegatedEvents = {};\n      var documents = [];\n\n      var supportsOptions = function () {\n        var supported = false;\n        window.document.createElement('div').addEventListener('test', null, {\n          get capture() {\n            supported = true;\n          }\n\n        });\n        return supported;\n      }();\n\n      function add(element, type, listener, optionalArg) {\n        var options = getOptions(optionalArg);\n        var elementIndex = elements.indexOf(element);\n        var target = targets[elementIndex];\n\n        if (!target) {\n          target = {\n            events: {},\n            typeCount: 0\n          };\n          elementIndex = elements.push(element) - 1;\n          targets.push(target);\n        }\n\n        if (!target.events[type]) {\n          target.events[type] = [];\n          target.typeCount++;\n        }\n\n        if (!contains(target.events[type], listener)) {\n          element.addEventListener(type, listener, supportsOptions ? options : !!options.capture);\n          target.events[type].push(listener);\n        }\n      }\n\n      function remove(element, type, listener, optionalArg) {\n        var options = getOptions(optionalArg);\n        var elementIndex = elements.indexOf(element);\n        var target = targets[elementIndex];\n\n        if (!target || !target.events) {\n          return;\n        }\n\n        if (type === 'all') {\n          for (type in target.events) {\n            if (target.events.hasOwnProperty(type)) {\n              remove(element, type, 'all');\n            }\n          }\n\n          return;\n        }\n\n        if (target.events[type]) {\n          var len = target.events[type].length;\n\n          if (listener === 'all') {\n            for (var i = 0; i < len; i++) {\n              remove(element, type, target.events[type][i], options);\n            }\n\n            return;\n          } else {\n            for (var _i = 0; _i < len; _i++) {\n              if (target.events[type][_i] === listener) {\n                element.removeEventListener('on' + type, listener, supportsOptions ? options : !!options.capture);\n                target.events[type].splice(_i, 1);\n                break;\n              }\n            }\n          }\n\n          if (target.events[type] && target.events[type].length === 0) {\n            target.events[type] = null;\n            target.typeCount--;\n          }\n        }\n\n        if (!target.typeCount) {\n          targets.splice(elementIndex, 1);\n          elements.splice(elementIndex, 1);\n        }\n      }\n\n      function addDelegate(selector, context, type, listener, optionalArg) {\n        var options = getOptions(optionalArg);\n\n        if (!delegatedEvents[type]) {\n          delegatedEvents[type] = {\n            selectors: [],\n            contexts: [],\n            listeners: []\n          }; // add delegate listener functions\n\n          for (var _i2 = 0; _i2 < documents.length; _i2++) {\n            var doc = documents[_i2];\n            add(doc, type, delegateListener);\n            add(doc, type, delegateUseCapture, true);\n          }\n        }\n\n        var delegated = delegatedEvents[type];\n        var index = void 0;\n\n        for (index = delegated.selectors.length - 1; index >= 0; index--) {\n          if (delegated.selectors[index] === selector && delegated.contexts[index] === context) {\n            break;\n          }\n        }\n\n        if (index === -1) {\n          index = delegated.selectors.length;\n          delegated.selectors.push(selector);\n          delegated.contexts.push(context);\n          delegated.listeners.push([]);\n        } // keep listener and capture and passive flags\n\n\n        delegated.listeners[index].push([listener, !!options.capture, options.passive]);\n      }\n\n      function removeDelegate(selector, context, type, listener, optionalArg) {\n        var options = getOptions(optionalArg);\n        var delegated = delegatedEvents[type];\n        var matchFound = false;\n        var index = void 0;\n\n        if (!delegated) {\n          return;\n        } // count from last index of delegated to 0\n\n\n        for (index = delegated.selectors.length - 1; index >= 0; index--) {\n          // look for matching selector and context Node\n          if (delegated.selectors[index] === selector && delegated.contexts[index] === context) {\n            var listeners = delegated.listeners[index]; // each item of the listeners array is an array: [function, capture, passive]\n\n            for (var i = listeners.length - 1; i >= 0; i--) {\n              var _listeners$i = listeners[i],\n                  fn = _listeners$i[0],\n                  capture = _listeners$i[1],\n                  passive = _listeners$i[2]; // check if the listener functions and capture and passive flags match\n\n              if (fn === listener && capture === !!options.capture && passive === options.passive) {\n                // remove the listener from the array of listeners\n                listeners.splice(i, 1); // if all listeners for this interactable have been removed\n                // remove the interactable from the delegated arrays\n\n                if (!listeners.length) {\n                  delegated.selectors.splice(index, 1);\n                  delegated.contexts.splice(index, 1);\n                  delegated.listeners.splice(index, 1); // remove delegate function from context\n\n                  remove(context, type, delegateListener);\n                  remove(context, type, delegateUseCapture, true); // remove the arrays if they are empty\n\n                  if (!delegated.selectors.length) {\n                    delegatedEvents[type] = null;\n                  }\n                } // only remove one listener\n\n\n                matchFound = true;\n                break;\n              }\n            }\n\n            if (matchFound) {\n              break;\n            }\n          }\n        }\n      } // bound to the interactable context when a DOM event\n      // listener is added to a selector interactable\n\n\n      function delegateListener(event, optionalArg) {\n        var options = getOptions(optionalArg);\n        var fakeEvent = {};\n        var delegated = delegatedEvents[event.type];\n\n        var _pointerUtils$getEven = pointerUtils.getEventTargets(event),\n            eventTarget = _pointerUtils$getEven[0];\n\n        var element = eventTarget; // duplicate the event so that currentTarget can be changed\n\n        pExtend(fakeEvent, event);\n        fakeEvent.originalEvent = event;\n        fakeEvent.preventDefault = preventOriginalDefault; // climb up document tree looking for selector matches\n\n        while (is.element(element)) {\n          for (var i = 0; i < delegated.selectors.length; i++) {\n            var selector = delegated.selectors[i];\n            var context = delegated.contexts[i];\n\n            if (domUtils.matchesSelector(element, selector) && domUtils.nodeContains(context, eventTarget) && domUtils.nodeContains(context, element)) {\n              var listeners = delegated.listeners[i];\n              fakeEvent.currentTarget = element;\n\n              for (var j = 0; j < listeners.length; j++) {\n                var _listeners$j = listeners[j],\n                    fn = _listeners$j[0],\n                    capture = _listeners$j[1],\n                    passive = _listeners$j[2];\n\n                if (capture === !!options.capture && passive === options.passive) {\n                  fn(fakeEvent);\n                }\n              }\n            }\n          }\n\n          element = domUtils.parentNode(element);\n        }\n      }\n\n      function delegateUseCapture(event) {\n        return delegateListener.call(this, event, true);\n      }\n\n      function preventOriginalDefault() {\n        this.originalEvent.preventDefault();\n      }\n\n      function getOptions(param) {\n        return is.object(param) ? param : {\n          capture: param\n        };\n      }\n\n      module.exports = {\n        add: add,\n        remove: remove,\n        addDelegate: addDelegate,\n        removeDelegate: removeDelegate,\n        delegateListener: delegateListener,\n        delegateUseCapture: delegateUseCapture,\n        delegatedEvents: delegatedEvents,\n        documents: documents,\n        supportsOptions: supportsOptions,\n        _elements: elements,\n        _targets: targets\n      };\n    }, {\n      \"./arr\": 35,\n      \"./domUtils\": 39,\n      \"./is\": 46,\n      \"./pointerExtend\": 48,\n      \"./pointerUtils\": 49,\n      \"./window\": 52\n    }],\n    41: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = function extend(dest, source) {\n        for (var prop in source) {\n          dest[prop] = source[prop];\n        }\n\n        return dest;\n      };\n    }, {}],\n    42: [function (require, module, exports) {\n      'use strict';\n\n      var _require = require('./rect'),\n          resolveRectLike = _require.resolveRectLike,\n          rectToXY = _require.rectToXY;\n\n      module.exports = function (target, element, action) {\n        var actionOptions = target.options[action];\n        var actionOrigin = actionOptions && actionOptions.origin;\n        var origin = actionOrigin || target.options.origin;\n        var originRect = resolveRectLike(origin, target, element, [target && element]);\n        return rectToXY(originRect) || {\n          x: 0,\n          y: 0\n        };\n      };\n    }, {\n      \"./rect\": 51\n    }],\n    43: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = function (x, y) {\n        return Math.sqrt(x * x + y * y);\n      };\n    }, {}],\n    44: [function (require, module, exports) {\n      'use strict';\n\n      var extend = require('./extend');\n\n      var win = require('./window');\n\n      var utils = {\n        warnOnce: function warnOnce(method, message) {\n          var warned = false;\n          return function () {\n            if (!warned) {\n              win.window.console.warn(message);\n              warned = true;\n            }\n\n            return method.apply(this, arguments);\n          };\n        },\n        // http://stackoverflow.com/a/5634528/2280888\n        _getQBezierValue: function _getQBezierValue(t, p1, p2, p3) {\n          var iT = 1 - t;\n          return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3;\n        },\n        getQuadraticCurvePoint: function getQuadraticCurvePoint(startX, startY, cpX, cpY, endX, endY, position) {\n          return {\n            x: utils._getQBezierValue(position, startX, cpX, endX),\n            y: utils._getQBezierValue(position, startY, cpY, endY)\n          };\n        },\n        // http://gizma.com/easing/\n        easeOutQuad: function easeOutQuad(t, b, c, d) {\n          t /= d;\n          return -c * t * (t - 2) + b;\n        },\n        copyAction: function copyAction(dest, src) {\n          dest.name = src.name;\n          dest.axis = src.axis;\n          dest.edges = src.edges;\n          return dest;\n        },\n        is: require('./is'),\n        extend: extend,\n        hypot: require('./hypot'),\n        getOriginXY: require('./getOriginXY')\n      };\n      extend(utils, require('./arr'));\n      extend(utils, require('./domUtils'));\n      extend(utils, require('./pointerUtils'));\n      extend(utils, require('./rect'));\n      module.exports = utils;\n    }, {\n      \"./arr\": 35,\n      \"./domUtils\": 39,\n      \"./extend\": 41,\n      \"./getOriginXY\": 42,\n      \"./hypot\": 43,\n      \"./is\": 46,\n      \"./pointerUtils\": 49,\n      \"./rect\": 51,\n      \"./window\": 52\n    }],\n    45: [function (require, module, exports) {\n      'use strict';\n\n      var scope = require('../scope');\n\n      var utils = require('./index');\n\n      var finder = {\n        methodOrder: ['simulationResume', 'mouseOrPen', 'hasPointer', 'idle'],\n        search: function search(pointer, eventType, eventTarget) {\n          var pointerType = utils.getPointerType(pointer);\n          var pointerId = utils.getPointerId(pointer);\n          var details = {\n            pointer: pointer,\n            pointerId: pointerId,\n            pointerType: pointerType,\n            eventType: eventType,\n            eventTarget: eventTarget\n          };\n\n          for (var _i = 0; _i < finder.methodOrder.length; _i++) {\n            var _ref;\n\n            _ref = finder.methodOrder[_i];\n            var method = _ref;\n            var interaction = finder[method](details);\n\n            if (interaction) {\n              return interaction;\n            }\n          }\n        },\n        // try to resume simulation with a new pointer\n        simulationResume: function simulationResume(_ref2) {\n          var pointerType = _ref2.pointerType,\n              eventType = _ref2.eventType,\n              eventTarget = _ref2.eventTarget;\n\n          if (!/down|start/i.test(eventType)) {\n            return null;\n          }\n\n          for (var _i2 = 0; _i2 < scope.interactions.length; _i2++) {\n            var _ref3;\n\n            _ref3 = scope.interactions[_i2];\n            var interaction = _ref3;\n            var element = eventTarget;\n\n            if (interaction.simulation && interaction.simulation.allowResume && interaction.pointerType === pointerType) {\n              while (element) {\n                // if the element is the interaction element\n                if (element === interaction.element) {\n                  return interaction;\n                }\n\n                element = utils.parentNode(element);\n              }\n            }\n          }\n\n          return null;\n        },\n        // if it's a mouse or pen interaction\n        mouseOrPen: function mouseOrPen(_ref4) {\n          var pointerId = _ref4.pointerId,\n              pointerType = _ref4.pointerType,\n              eventType = _ref4.eventType;\n\n          if (pointerType !== 'mouse' && pointerType !== 'pen') {\n            return null;\n          }\n\n          var firstNonActive = void 0;\n\n          for (var _i3 = 0; _i3 < scope.interactions.length; _i3++) {\n            var _ref5;\n\n            _ref5 = scope.interactions[_i3];\n            var interaction = _ref5;\n\n            if (interaction.pointerType === pointerType) {\n              // if it's a down event, skip interactions with running simulations\n              if (interaction.simulation && !utils.contains(interaction.pointerIds, pointerId)) {\n                continue;\n              } // if the interaction is active, return it immediately\n\n\n              if (interaction.interacting()) {\n                return interaction;\n              } // otherwise save it and look for another active interaction\n              else if (!firstNonActive) {\n                  firstNonActive = interaction;\n                }\n            }\n          } // if no active mouse interaction was found use the first inactive mouse\n          // interaction\n\n\n          if (firstNonActive) {\n            return firstNonActive;\n          } // find any mouse or pen interaction.\n          // ignore the interaction if the eventType is a *down, and a simulation\n          // is active\n\n\n          for (var _i4 = 0; _i4 < scope.interactions.length; _i4++) {\n            var _ref6;\n\n            _ref6 = scope.interactions[_i4];\n            var _interaction = _ref6;\n\n            if (_interaction.pointerType === pointerType && !(/down/i.test(eventType) && _interaction.simulation)) {\n              return _interaction;\n            }\n          }\n\n          return null;\n        },\n        // get interaction that has this pointer\n        hasPointer: function hasPointer(_ref7) {\n          var pointerId = _ref7.pointerId;\n\n          for (var _i5 = 0; _i5 < scope.interactions.length; _i5++) {\n            var _ref8;\n\n            _ref8 = scope.interactions[_i5];\n            var interaction = _ref8;\n\n            if (utils.contains(interaction.pointerIds, pointerId)) {\n              return interaction;\n            }\n          }\n        },\n        // get first idle interaction with a matching pointerType\n        idle: function idle(_ref9) {\n          var pointerType = _ref9.pointerType;\n\n          for (var _i6 = 0; _i6 < scope.interactions.length; _i6++) {\n            var _ref10;\n\n            _ref10 = scope.interactions[_i6];\n            var interaction = _ref10; // if there's already a pointer held down\n\n            if (interaction.pointerIds.length === 1) {\n              var target = interaction.target; // don't add this pointer if there is a target interactable and it\n              // isn't gesturable\n\n              if (target && !target.options.gesture.enabled) {\n                continue;\n              }\n            } // maximum of 2 pointers per interaction\n            else if (interaction.pointerIds.length >= 2) {\n                continue;\n              }\n\n            if (!interaction.interacting() && pointerType === interaction.pointerType) {\n              return interaction;\n            }\n          }\n\n          return null;\n        }\n      };\n      module.exports = finder;\n    }, {\n      \"../scope\": 33,\n      \"./index\": 44\n    }],\n    46: [function (require, module, exports) {\n      'use strict';\n\n      var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n        return typeof obj;\n      } : function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n\n      var win = require('./window');\n\n      var isWindow = require('./isWindow');\n\n      var is = {\n        array: function array() {},\n        window: function window(thing) {\n          return thing === win.window || isWindow(thing);\n        },\n        docFrag: function docFrag(thing) {\n          return is.object(thing) && thing.nodeType === 11;\n        },\n        object: function object(thing) {\n          return !!thing && (typeof thing === 'undefined' ? 'undefined' : _typeof(thing)) === 'object';\n        },\n        function: function _function(thing) {\n          return typeof thing === 'function';\n        },\n        number: function number(thing) {\n          return typeof thing === 'number';\n        },\n        bool: function bool(thing) {\n          return typeof thing === 'boolean';\n        },\n        string: function string(thing) {\n          return typeof thing === 'string';\n        },\n        element: function element(thing) {\n          if (!thing || (typeof thing === 'undefined' ? 'undefined' : _typeof(thing)) !== 'object') {\n            return false;\n          }\n\n          var _window = win.getWindow(thing) || win.window;\n\n          return /object|function/.test(_typeof(_window.Element)) ? thing instanceof _window.Element //DOM2\n          : thing.nodeType === 1 && typeof thing.nodeName === 'string';\n        },\n        plainObject: function plainObject(thing) {\n          return is.object(thing) && thing.constructor.name === 'Object';\n        }\n      };\n\n      is.array = function (thing) {\n        return is.object(thing) && typeof thing.length !== 'undefined' && is.function(thing.splice);\n      };\n\n      module.exports = is;\n    }, {\n      \"./isWindow\": 47,\n      \"./window\": 52\n    }],\n    47: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = function (thing) {\n        return !!(thing && thing.Window) && thing instanceof thing.Window;\n      };\n    }, {}],\n    48: [function (require, module, exports) {\n      'use strict';\n\n      function pointerExtend(dest, source) {\n        for (var prop in source) {\n          var prefixedPropREs = module.exports.prefixedPropREs;\n          var deprecated = false; // skip deprecated prefixed properties\n\n          for (var vendor in prefixedPropREs) {\n            if (prop.indexOf(vendor) === 0 && prefixedPropREs[vendor].test(prop)) {\n              deprecated = true;\n              break;\n            }\n          }\n\n          if (!deprecated && typeof source[prop] !== 'function') {\n            dest[prop] = source[prop];\n          }\n        }\n\n        return dest;\n      }\n\n      pointerExtend.prefixedPropREs = {\n        webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/\n      };\n      module.exports = pointerExtend;\n    }, {}],\n    49: [function (require, module, exports) {\n      'use strict';\n\n      var hypot = require('./hypot');\n\n      var browser = require('./browser');\n\n      var dom = require('./domObjects');\n\n      var domUtils = require('./domUtils');\n\n      var domObjects = require('./domObjects');\n\n      var is = require('./is');\n\n      var pointerExtend = require('./pointerExtend');\n\n      var pointerUtils = {\n        copyCoords: function copyCoords(dest, src) {\n          dest.page = dest.page || {};\n          dest.page.x = src.page.x;\n          dest.page.y = src.page.y;\n          dest.client = dest.client || {};\n          dest.client.x = src.client.x;\n          dest.client.y = src.client.y;\n          dest.timeStamp = src.timeStamp;\n        },\n        setCoordDeltas: function setCoordDeltas(targetObj, prev, cur) {\n          targetObj.page.x = cur.page.x - prev.page.x;\n          targetObj.page.y = cur.page.y - prev.page.y;\n          targetObj.client.x = cur.client.x - prev.client.x;\n          targetObj.client.y = cur.client.y - prev.client.y;\n          targetObj.timeStamp = cur.timeStamp - prev.timeStamp; // set pointer velocity\n\n          var dt = Math.max(targetObj.timeStamp / 1000, 0.001);\n          targetObj.page.speed = hypot(targetObj.page.x, targetObj.page.y) / dt;\n          targetObj.page.vx = targetObj.page.x / dt;\n          targetObj.page.vy = targetObj.page.y / dt;\n          targetObj.client.speed = hypot(targetObj.client.x, targetObj.page.y) / dt;\n          targetObj.client.vx = targetObj.client.x / dt;\n          targetObj.client.vy = targetObj.client.y / dt;\n        },\n        isNativePointer: function isNativePointer(pointer) {\n          return pointer instanceof dom.Event || pointer instanceof dom.Touch;\n        },\n        // Get specified X/Y coords for mouse or event.touches[0]\n        getXY: function getXY(type, pointer, xy) {\n          xy = xy || {};\n          type = type || 'page';\n          xy.x = pointer[type + 'X'];\n          xy.y = pointer[type + 'Y'];\n          return xy;\n        },\n        getPageXY: function getPageXY(pointer, page) {\n          page = page || {}; // Opera Mobile handles the viewport and scrolling oddly\n\n          if (browser.isOperaMobile && pointerUtils.isNativePointer(pointer)) {\n            pointerUtils.getXY('screen', pointer, page);\n            page.x += window.scrollX;\n            page.y += window.scrollY;\n          } else {\n            pointerUtils.getXY('page', pointer, page);\n          }\n\n          return page;\n        },\n        getClientXY: function getClientXY(pointer, client) {\n          client = client || {};\n\n          if (browser.isOperaMobile && pointerUtils.isNativePointer(pointer)) {\n            // Opera Mobile handles the viewport and scrolling oddly\n            pointerUtils.getXY('screen', pointer, client);\n          } else {\n            pointerUtils.getXY('client', pointer, client);\n          }\n\n          return client;\n        },\n        getPointerId: function getPointerId(pointer) {\n          return is.number(pointer.pointerId) ? pointer.pointerId : pointer.identifier;\n        },\n        setCoords: function setCoords(targetObj, pointers, timeStamp) {\n          var pointer = pointers.length > 1 ? pointerUtils.pointerAverage(pointers) : pointers[0];\n          var tmpXY = {};\n          pointerUtils.getPageXY(pointer, tmpXY);\n          targetObj.page.x = tmpXY.x;\n          targetObj.page.y = tmpXY.y;\n          pointerUtils.getClientXY(pointer, tmpXY);\n          targetObj.client.x = tmpXY.x;\n          targetObj.client.y = tmpXY.y;\n          targetObj.timeStamp = is.number(timeStamp) ? timeStamp : new Date().getTime();\n        },\n        pointerExtend: pointerExtend,\n        getTouchPair: function getTouchPair(event) {\n          var touches = []; // array of touches is supplied\n\n          if (is.array(event)) {\n            touches[0] = event[0];\n            touches[1] = event[1];\n          } // an event\n          else {\n              if (event.type === 'touchend') {\n                if (event.touches.length === 1) {\n                  touches[0] = event.touches[0];\n                  touches[1] = event.changedTouches[0];\n                } else if (event.touches.length === 0) {\n                  touches[0] = event.changedTouches[0];\n                  touches[1] = event.changedTouches[1];\n                }\n              } else {\n                touches[0] = event.touches[0];\n                touches[1] = event.touches[1];\n              }\n            }\n\n          return touches;\n        },\n        pointerAverage: function pointerAverage(pointers) {\n          var average = {\n            pageX: 0,\n            pageY: 0,\n            clientX: 0,\n            clientY: 0,\n            screenX: 0,\n            screenY: 0\n          };\n\n          for (var _i = 0; _i < pointers.length; _i++) {\n            var _ref;\n\n            _ref = pointers[_i];\n            var pointer = _ref;\n\n            for (var _prop in average) {\n              average[_prop] += pointer[_prop];\n            }\n          }\n\n          for (var prop in average) {\n            average[prop] /= pointers.length;\n          }\n\n          return average;\n        },\n        touchBBox: function touchBBox(event) {\n          if (!event.length && !(event.touches && event.touches.length > 1)) {\n            return;\n          }\n\n          var touches = pointerUtils.getTouchPair(event);\n          var minX = Math.min(touches[0].pageX, touches[1].pageX);\n          var minY = Math.min(touches[0].pageY, touches[1].pageY);\n          var maxX = Math.max(touches[0].pageX, touches[1].pageX);\n          var maxY = Math.max(touches[0].pageY, touches[1].pageY);\n          return {\n            x: minX,\n            y: minY,\n            left: minX,\n            top: minY,\n            width: maxX - minX,\n            height: maxY - minY\n          };\n        },\n        touchDistance: function touchDistance(event, deltaSource) {\n          var sourceX = deltaSource + 'X';\n          var sourceY = deltaSource + 'Y';\n          var touches = pointerUtils.getTouchPair(event);\n          var dx = touches[0][sourceX] - touches[1][sourceX];\n          var dy = touches[0][sourceY] - touches[1][sourceY];\n          return hypot(dx, dy);\n        },\n        touchAngle: function touchAngle(event, prevAngle, deltaSource) {\n          var sourceX = deltaSource + 'X';\n          var sourceY = deltaSource + 'Y';\n          var touches = pointerUtils.getTouchPair(event);\n          var dx = touches[1][sourceX] - touches[0][sourceX];\n          var dy = touches[1][sourceY] - touches[0][sourceY];\n          var angle = 180 * Math.atan2(dy, dx) / Math.PI;\n          return angle;\n        },\n        getPointerType: function getPointerType(pointer) {\n          return is.string(pointer.pointerType) ? pointer.pointerType : is.number(pointer.pointerType) ? [undefined, undefined, 'touch', 'pen', 'mouse'][pointer.pointerType] // if the PointerEvent API isn't available, then the \"pointer\" must\n          // be either a MouseEvent, TouchEvent, or Touch object\n          : /touch/.test(pointer.type) || pointer instanceof domObjects.Touch ? 'touch' : 'mouse';\n        },\n        // [ event.target, event.currentTarget ]\n        getEventTargets: function getEventTargets(event) {\n          var path = is.function(event.composedPath) ? event.composedPath() : event.path;\n          return [domUtils.getActualElement(path ? path[0] : event.target), domUtils.getActualElement(event.currentTarget)];\n        }\n      };\n      module.exports = pointerUtils;\n    }, {\n      \"./browser\": 36,\n      \"./domObjects\": 38,\n      \"./domUtils\": 39,\n      \"./hypot\": 43,\n      \"./is\": 46,\n      \"./pointerExtend\": 48\n    }],\n    50: [function (require, module, exports) {\n      'use strict';\n\n      var _require = require('./window'),\n          window = _require.window;\n\n      var vendors = ['ms', 'moz', 'webkit', 'o'];\n      var lastTime = 0;\n      var request = void 0;\n      var cancel = void 0;\n\n      for (var x = 0; x < vendors.length && !window.requestAnimationFrame; x++) {\n        request = window[vendors[x] + 'RequestAnimationFrame'];\n        cancel = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\n      }\n\n      if (!request) {\n        request = function request(callback) {\n          var currTime = new Date().getTime();\n          var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n          var id = setTimeout(function () {\n            callback(currTime + timeToCall);\n          }, timeToCall);\n          lastTime = currTime + timeToCall;\n          return id;\n        };\n      }\n\n      if (!cancel) {\n        cancel = function cancel(id) {\n          clearTimeout(id);\n        };\n      }\n\n      module.exports = {\n        request: request,\n        cancel: cancel\n      };\n    }, {\n      \"./window\": 52\n    }],\n    51: [function (require, module, exports) {\n      'use strict';\n\n      var extend = require('./extend');\n\n      var is = require('./is');\n\n      var _require = require('./domUtils'),\n          closest = _require.closest,\n          parentNode = _require.parentNode,\n          getElementRect = _require.getElementRect;\n\n      var rectUtils = {\n        getStringOptionResult: function getStringOptionResult(value, interactable, element) {\n          if (!is.string(value)) {\n            return null;\n          }\n\n          if (value === 'parent') {\n            value = parentNode(element);\n          } else if (value === 'self') {\n            value = interactable.getRect(element);\n          } else {\n            value = closest(element, value);\n          }\n\n          return value;\n        },\n        resolveRectLike: function resolveRectLike(value, interactable, element, functionArgs) {\n          value = rectUtils.getStringOptionResult(value, interactable, element) || value;\n\n          if (is.function(value)) {\n            value = value.apply(null, functionArgs);\n          }\n\n          if (is.element(value)) {\n            value = getElementRect(value);\n          }\n\n          return value;\n        },\n        rectToXY: function rectToXY(rect) {\n          return rect && {\n            x: 'x' in rect ? rect.x : rect.left,\n            y: 'y' in rect ? rect.y : rect.top\n          };\n        },\n        xywhToTlbr: function xywhToTlbr(rect) {\n          if (rect && !('left' in rect && 'top' in rect)) {\n            rect = extend({}, rect);\n            rect.left = rect.x || 0;\n            rect.top = rect.y || 0;\n            rect.right = rect.right || rect.left + rect.width;\n            rect.bottom = rect.bottom || rect.top + rect.height;\n          }\n\n          return rect;\n        },\n        tlbrToXywh: function tlbrToXywh(rect) {\n          if (rect && !('x' in rect && 'y' in rect)) {\n            rect = extend({}, rect);\n            rect.x = rect.left || 0;\n            rect.top = rect.top || 0;\n            rect.width = rect.width || rect.right - rect.x;\n            rect.height = rect.height || rect.bottom - rect.y;\n          }\n\n          return rect;\n        }\n      };\n      module.exports = rectUtils;\n    }, {\n      \"./domUtils\": 39,\n      \"./extend\": 41,\n      \"./is\": 46\n    }],\n    52: [function (require, module, exports) {\n      'use strict';\n\n      var win = module.exports;\n\n      var isWindow = require('./isWindow');\n\n      function init(window) {\n        // get wrapped window if using Shadow DOM polyfill\n        win.realWindow = window; // create a TextNode\n\n        var el = window.document.createTextNode(''); // check if it's wrapped by a polyfill\n\n        if (el.ownerDocument !== window.document && typeof window.wrap === 'function' && window.wrap(el) === el) {\n          // use wrapped window\n          window = window.wrap(window);\n        }\n\n        win.window = window;\n      }\n\n      if (typeof window === 'undefined') {\n        win.window = undefined;\n        win.realWindow = undefined;\n      } else {\n        init(window);\n      }\n\n      win.getWindow = function getWindow(node) {\n        if (isWindow(node)) {\n          return node;\n        }\n\n        var rootNode = node.ownerDocument || node;\n        return rootNode.defaultView || rootNode.parentWindow || win.window;\n      };\n\n      win.init = init;\n    }, {\n      \"./isWindow\": 47\n    }]\n  }, {}, [1])(1);\n});","map":{"version":3,"sources":["src/header.js","node_modules/browser-pack/_prelude.js","index.js","src/Eventable.js","src/InteractEvent.js","src/Interactable.js","src/Interaction.js","src/actions/base.js","src/actions/drag.js","src/actions/drop.js","src/actions/gesture.js","src/actions/resize.js","src/autoScroll.js","src/autoStart/InteractableMethods.js","src/autoStart/base.js","src/autoStart/drag.js","src/autoStart/gesture.js","src/autoStart/hold.js","src/autoStart/resize.js","src/defaultOptions.js","src/index.js","src/inertia.js","src/interact.js","src/interactablePreventDefault.js","src/modifiers/base.js","src/modifiers/restrict.js","src/modifiers/restrictEdges.js","src/modifiers/restrictSize.js","src/modifiers/snap.js","src/modifiers/snapSize.js","src/pointerEvents/PointerEvent.js","src/pointerEvents/base.js","src/pointerEvents/holdRepeat.js","src/pointerEvents/interactableTargets.js","src/scope.js","src/utils/Signals.js","src/utils/arr.js","src/utils/browser.js","src/utils/clone.js","src/utils/domObjects.js","src/utils/domUtils.js","src/utils/events.js","src/utils/extend.js","src/utils/getOriginXY.js","src/utils/hypot.js","src/utils/index.js","src/utils/interactionFinder.js","src/utils/is.js","src/utils/isWindow.js","src/utils/pointerExtend.js","src/utils/pointerUtils.js","src/utils/raf.js","src/utils/rect.js","src/utils/window.js"],"names":[],"mappings":"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","sourcesContent":["/**\n * interact.js v1.3.4\n *\n * Copyright (c) 2012-2018 Taye Adeyemi <dev@taye.me>\n * Released under the MIT License.\n * https://raw.github.com/taye/interact.js/master/LICENSE\n */\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/*\n * In a (windowless) server environment this file exports a factory function\n * that takes the window to use.\n *\n *     var interact = require('interact.js')(windowObject);\n *\n * See https://github.com/taye/interact.js/issues/187\n */\nif (typeof window === 'undefined') {\n  module.exports = function (window) {\n    require('./src/utils/window').init(window);\n\n    return require('./src/index');\n  };\n}\nelse {\n  module.exports = require('./src/index');\n}\n","const extend = require('./utils/extend.js');\n\nfunction fireUntilImmediateStopped (event, listeners) {\n  for (const listener of listeners) {\n    if (event.immediatePropagationStopped) { break; }\n\n    listener(event);\n  }\n}\n\nclass Eventable {\n\n  constructor (options) {\n    this.options = extend({}, options || {});\n  }\n\n  fire (event) {\n    let listeners;\n    const onEvent = 'on' + event.type;\n    const global = this.global;\n\n    // Interactable#on() listeners\n    if ((listeners = this[event.type])) {\n      fireUntilImmediateStopped(event, listeners);\n    }\n\n    // interactable.onevent listener\n    if (this[onEvent]) {\n      this[onEvent](event);\n    }\n\n    // interact.on() listeners\n    if (!event.propagationStopped && global && (listeners = global[event.type]))  {\n      fireUntilImmediateStopped(event, listeners);\n    }\n  }\n\n  on (eventType, listener) {\n    // if this type of event was never bound\n    if (this[eventType]) {\n      this[eventType].push(listener);\n    }\n    else {\n      this[eventType] = [listener];\n    }\n  }\n\n  off (eventType, listener) {\n    // if it is an action event type\n    const eventList = this[eventType];\n    const index     = eventList? eventList.indexOf(listener) : -1;\n\n    if (index !== -1) {\n      eventList.splice(index, 1);\n    }\n\n    if (eventList && eventList.length === 0 || !listener) {\n      this[eventType] = undefined;\n    }\n  }\n}\n\nmodule.exports = Eventable;\n","const extend      = require('./utils/extend');\nconst getOriginXY = require('./utils/getOriginXY');\nconst defaults    = require('./defaultOptions');\nconst signals     = require('./utils/Signals').new();\n\nclass InteractEvent {\n  /** */\n  constructor (interaction, event, action, phase, element, related, preEnd = false) {\n    const target      = interaction.target;\n    const deltaSource = (target && target.options || defaults).deltaSource;\n    const origin      = getOriginXY(target, element, action);\n    const starting    = phase === 'start';\n    const ending      = phase === 'end';\n    const coords      = starting? interaction.startCoords : interaction.curCoords;\n    const prevEvent   = interaction.prevEvent;\n\n    element = element || interaction.element;\n\n    const page   = extend({}, coords.page);\n    const client = extend({}, coords.client);\n\n    page.x -= origin.x;\n    page.y -= origin.y;\n\n    client.x -= origin.x;\n    client.y -= origin.y;\n\n    this.ctrlKey       = event.ctrlKey;\n    this.altKey        = event.altKey;\n    this.shiftKey      = event.shiftKey;\n    this.metaKey       = event.metaKey;\n    this.button        = event.button;\n    this.buttons       = event.buttons;\n    this.target        = element;\n    this.currentTarget = element;\n    this.relatedTarget = related || null;\n    this.preEnd        = preEnd;\n    this.type          = action + (phase || '');\n    this.interaction   = interaction;\n    this.interactable  = target;\n\n    this.t0 = starting ? interaction.downTimes[interaction.downTimes.length - 1]\n                       : prevEvent.t0;\n\n    const signalArg = {\n      interaction,\n      event,\n      action,\n      phase,\n      element,\n      related,\n      page,\n      client,\n      coords,\n      starting,\n      ending,\n      deltaSource,\n      iEvent: this,\n    };\n\n    signals.fire('set-xy', signalArg);\n\n    if (ending) {\n      // use previous coords when ending\n      this.pageX = prevEvent.pageX;\n      this.pageY = prevEvent.pageY;\n      this.clientX = prevEvent.clientX;\n      this.clientY = prevEvent.clientY;\n    }\n    else {\n      this.pageX     = page.x;\n      this.pageY     = page.y;\n      this.clientX   = client.x;\n      this.clientY   = client.y;\n    }\n\n    this.x0        = interaction.startCoords.page.x - origin.x;\n    this.y0        = interaction.startCoords.page.y - origin.y;\n    this.clientX0  = interaction.startCoords.client.x - origin.x;\n    this.clientY0  = interaction.startCoords.client.y - origin.y;\n\n    signals.fire('set-delta', signalArg);\n\n    this.timeStamp = coords.timeStamp;\n    this.dt        = interaction.pointerDelta.timeStamp;\n    this.duration  = this.timeStamp - this.t0;\n\n    // speed and velocity in pixels per second\n    this.speed = interaction.pointerDelta[deltaSource].speed;\n    this.velocityX = interaction.pointerDelta[deltaSource].vx;\n    this.velocityY = interaction.pointerDelta[deltaSource].vy;\n\n    this.swipe = (ending || phase === 'inertiastart')? this.getSwipe() : null;\n\n    signals.fire('new', signalArg);\n  }\n\n  getSwipe () {\n    const interaction = this.interaction;\n\n    if (interaction.prevEvent.speed < 600\n        || this.timeStamp - interaction.prevEvent.timeStamp > 150) {\n      return null;\n    }\n\n    let angle = 180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX) / Math.PI;\n    const overlap = 22.5;\n\n    if (angle < 0) {\n      angle += 360;\n    }\n\n    const left = 135 - overlap <= angle && angle < 225 + overlap;\n    const up   = 225 - overlap <= angle && angle < 315 + overlap;\n\n    const right = !left && (315 - overlap <= angle || angle <  45 + overlap);\n    const down  = !up   &&   45 - overlap <= angle && angle < 135 + overlap;\n\n    return {\n      up,\n      down,\n      left,\n      right,\n      angle,\n      speed: interaction.prevEvent.speed,\n      velocity: {\n        x: interaction.prevEvent.velocityX,\n        y: interaction.prevEvent.velocityY,\n      },\n    };\n  }\n\n  preventDefault () {}\n\n  /** */\n  stopImmediatePropagation () {\n    this.immediatePropagationStopped = this.propagationStopped = true;\n  }\n\n  /** */\n  stopPropagation () {\n    this.propagationStopped = true;\n  }\n}\n\nsignals.on('set-delta', function ({ iEvent, interaction, starting, deltaSource }) {\n  const prevEvent = starting? iEvent : interaction.prevEvent;\n\n  if (deltaSource === 'client') {\n    iEvent.dx = iEvent.clientX - prevEvent.clientX;\n    iEvent.dy = iEvent.clientY - prevEvent.clientY;\n  }\n  else {\n    iEvent.dx = iEvent.pageX - prevEvent.pageX;\n    iEvent.dy = iEvent.pageY - prevEvent.pageY;\n  }\n});\n\nInteractEvent.signals = signals;\n\nmodule.exports = InteractEvent;\n","const clone     = require('./utils/clone');\nconst is        = require('./utils/is');\nconst events    = require('./utils/events');\nconst extend    = require('./utils/extend');\nconst actions   = require('./actions/base');\nconst scope     = require('./scope');\nconst Eventable = require('./Eventable');\nconst defaults  = require('./defaultOptions');\nconst signals   = require('./utils/Signals').new();\n\nconst {\n  getElementRect,\n  nodeContains,\n  trySelector,\n  matchesSelector,\n}                    = require('./utils/domUtils');\nconst { getWindow }  = require('./utils/window');\nconst { contains }   = require('./utils/arr');\nconst { wheelEvent } = require('./utils/browser');\n\n// all set interactables\nscope.interactables = [];\n\nclass Interactable {\n  /** */\n  constructor (target, options) {\n    options = options || {};\n\n    this.target   = target;\n    this.events   = new Eventable();\n    this._context = options.context || scope.document;\n    this._win     = getWindow(trySelector(target)? this._context : target);\n    this._doc     = this._win.document;\n\n    signals.fire('new', {\n      target,\n      options,\n      interactable: this,\n      win: this._win,\n    });\n\n    scope.addDocument( this._doc, this._win );\n\n    scope.interactables.push(this);\n\n    this.set(options);\n  }\n\n  setOnEvents (action, phases) {\n    const onAction = 'on' + action;\n\n    if (is.function(phases.onstart)       ) { this.events[onAction + 'start'        ] = phases.onstart         ; }\n    if (is.function(phases.onmove)        ) { this.events[onAction + 'move'         ] = phases.onmove          ; }\n    if (is.function(phases.onend)         ) { this.events[onAction + 'end'          ] = phases.onend           ; }\n    if (is.function(phases.oninertiastart)) { this.events[onAction + 'inertiastart' ] = phases.oninertiastart  ; }\n\n    return this;\n  }\n\n  setPerAction (action, options) {\n    // for all the default per-action options\n    for (const option in options) {\n      // if this option exists for this action\n      if (option in defaults[action]) {\n        // if the option in the options arg is an object value\n        if (is.object(options[option])) {\n          // duplicate the object and merge\n          this.options[action][option] = clone(this.options[action][option] || {});\n          extend(this.options[action][option], options[option]);\n\n          if (is.object(defaults.perAction[option]) && 'enabled' in defaults.perAction[option]) {\n            this.options[action][option].enabled = options[option].enabled === false? false : true;\n          }\n        }\n        else if (is.bool(options[option]) && is.object(defaults.perAction[option])) {\n          this.options[action][option].enabled = options[option];\n        }\n        else if (options[option] !== undefined) {\n          // or if it's not undefined, do a plain assignment\n          this.options[action][option] = options[option];\n        }\n      }\n    }\n  }\n\n  /**\n   * The default function to get an Interactables bounding rect. Can be\n   * overridden using {@link Interactable.rectChecker}.\n   *\n   * @param {Element} [element] The element to measure.\n   * @return {object} The object's bounding rectangle.\n   */\n  getRect (element) {\n    element = element || this.target;\n\n    if (is.string(this.target) && !(is.element(element))) {\n      element = this._context.querySelector(this.target);\n    }\n\n    return getElementRect(element);\n  }\n\n  /**\n   * Returns or sets the function used to calculate the interactable's\n   * element's rectangle\n   *\n   * @param {function} [checker] A function which returns this Interactable's\n   * bounding rectangle. See {@link Interactable.getRect}\n   * @return {function | object} The checker function or this Interactable\n   */\n  rectChecker (checker) {\n    if (is.function(checker)) {\n      this.getRect = checker;\n\n      return this;\n    }\n\n    if (checker === null) {\n      delete this.options.getRect;\n\n      return this;\n    }\n\n    return this.getRect;\n  }\n\n  _backCompatOption (optionName, newValue) {\n    if (trySelector(newValue) || is.object(newValue)) {\n      this.options[optionName] = newValue;\n\n      for (const action of actions.names) {\n        this.options[action][optionName] = newValue;\n      }\n\n      return this;\n    }\n\n    return this.options[optionName];\n  }\n\n  /**\n   * Gets or sets the origin of the Interactable's element.  The x and y\n   * of the origin will be subtracted from action event coordinates.\n   *\n   * @param {Element | object | string} [origin] An HTML or SVG Element whose\n   * rect will be used, an object eg. { x: 0, y: 0 } or string 'parent', 'self'\n   * or any CSS selector\n   *\n   * @return {object} The current origin or this Interactable\n   */\n  origin (newValue) {\n    return this._backCompatOption('origin', newValue);\n  }\n\n  /**\n   * Returns or sets the mouse coordinate types used to calculate the\n   * movement of the pointer.\n   *\n   * @param {string} [newValue] Use 'client' if you will be scrolling while\n   * interacting; Use 'page' if you want autoScroll to work\n   * @return {string | object} The current deltaSource or this Interactable\n   */\n  deltaSource (newValue) {\n    if (newValue === 'page' || newValue === 'client') {\n      this.options.deltaSource = newValue;\n\n      return this;\n    }\n\n    return this.options.deltaSource;\n  }\n\n  /**\n   * Gets the selector context Node of the Interactable. The default is\n   * `window.document`.\n   *\n   * @return {Node} The context Node of this Interactable\n   */\n  context () {\n    return this._context;\n  }\n\n  inContext (element) {\n    return (this._context === element.ownerDocument\n            || nodeContains(this._context, element));\n  }\n\n  /**\n   * Calls listeners for the given InteractEvent type bound globally\n   * and directly to this Interactable\n   *\n   * @param {InteractEvent} iEvent The InteractEvent object to be fired on this\n   * Interactable\n   * @return {Interactable} this Interactable\n   */\n  fire (iEvent) {\n    this.events.fire(iEvent);\n\n    return this;\n  }\n\n  _onOffMultiple (method, eventType, listener, options) {\n    if (is.string(eventType) && eventType.search(' ') !== -1) {\n      eventType = eventType.trim().split(/ +/);\n    }\n\n    if (is.array(eventType)) {\n      for (const type of eventType) {\n        this[method](type, listener, options);\n      }\n\n      return true;\n    }\n\n    if (is.object(eventType)) {\n      for (const prop in eventType) {\n        this[method](prop, eventType[prop], listener);\n      }\n\n      return true;\n    }\n  }\n\n  /**\n   * Binds a listener for an InteractEvent, pointerEvent or DOM event.\n   *\n   * @param {string | array | object} eventType  The types of events to listen\n   * for\n   * @param {function} listener   The function event (s)\n   * @param {object | boolean} [options]    options object or useCapture flag\n   * for addEventListener\n   * @return {object} This Interactable\n   */\n  on (eventType, listener, options) {\n    if (this._onOffMultiple('on', eventType, listener, options)) {\n      return this;\n    }\n\n    if (eventType === 'wheel') { eventType = wheelEvent; }\n\n    if (contains(Interactable.eventTypes, eventType)) {\n      this.events.on(eventType, listener);\n    }\n    // delegated event for selector\n    else if (is.string(this.target)) {\n      events.addDelegate(this.target, this._context, eventType, listener, options);\n    }\n    else {\n      events.add(this.target, eventType, listener, options);\n    }\n\n    return this;\n  }\n\n  /**\n   * Removes an InteractEvent, pointerEvent or DOM event listener\n   *\n   * @param {string | array | object} eventType The types of events that were\n   * listened for\n   * @param {function} listener The listener function to be removed\n   * @param {object | boolean} [options] options object or useCapture flag for\n   * removeEventListener\n   * @return {object} This Interactable\n   */\n  off (eventType, listener, options) {\n    if (this._onOffMultiple('off', eventType, listener, options)) {\n      return this;\n    }\n\n    if (eventType === 'wheel') { eventType = wheelEvent; }\n\n    // if it is an action event type\n    if (contains(Interactable.eventTypes, eventType)) {\n      this.events.off(eventType, listener);\n    }\n    // delegated event\n    else if (is.string(this.target)) {\n      events.removeDelegate(this.target, this._context, eventType, listener, options);\n    }\n    // remove listener from this Interatable's element\n    else {\n      events.remove(this.target, eventType, listener, options);\n    }\n\n    return this;\n  }\n\n  /**\n   * Reset the options of this Interactable\n   *\n   * @param {object} options The new settings to apply\n   * @return {object} This Interactable\n   */\n  set (options) {\n    if (!is.object(options)) {\n      options = {};\n    }\n\n    this.options = clone(defaults.base);\n\n    const perActions = clone(defaults.perAction);\n\n    for (const actionName in actions.methodDict) {\n      const methodName = actions.methodDict[actionName];\n\n      this.options[actionName] = clone(defaults[actionName]);\n\n      this.setPerAction(actionName, perActions);\n\n      this[methodName](options[actionName]);\n    }\n\n    for (const setting of Interactable.settingsMethods) {\n      this.options[setting] = defaults.base[setting];\n\n      if (setting in options) {\n        this[setting](options[setting]);\n      }\n    }\n\n    signals.fire('set', {\n      options,\n      interactable: this,\n    });\n\n    return this;\n  }\n\n  /**\n   * Remove this interactable from the list of interactables and remove it's\n   * action capabilities and event listeners\n   *\n   * @return {interact}\n   */\n  unset () {\n    events.remove(this.target, 'all');\n\n    if (is.string(this.target)) {\n      // remove delegated events\n      for (const type in events.delegatedEvents) {\n        const delegated = events.delegatedEvents[type];\n\n        if (delegated.selectors[0] === this.target\n            && delegated.contexts[0] === this._context) {\n\n          delegated.selectors.splice(0, 1);\n          delegated.contexts .splice(0, 1);\n          delegated.listeners.splice(0, 1);\n\n          // remove the arrays if they are empty\n          if (!delegated.selectors.length) {\n            delegated[type] = null;\n          }\n        }\n\n        events.remove(this._context, type, events.delegateListener);\n        events.remove(this._context, type, events.delegateUseCapture, true);\n      }\n    }\n    else {\n      events.remove(this, 'all');\n    }\n\n    signals.fire('unset', { interactable: this });\n\n    scope.interactables.splice(scope.interactables.indexOf(this), 1);\n\n    // Stop related interactions when an Interactable is unset\n    for (const interaction of scope.interactions || []) {\n      if (interaction.target === this && interaction.interacting() && !interaction._ending) {\n        interaction.stop();\n      }\n    }\n\n    return scope.interact;\n  }\n}\n\nscope.interactables.indexOfElement = function indexOfElement (target, context) {\n  context = context || scope.document;\n\n  for (let i = 0; i < this.length; i++) {\n    const interactable = this[i];\n\n    if (interactable.target === target && interactable._context === context) {\n      return i;\n    }\n  }\n  return -1;\n};\n\nscope.interactables.get = function interactableGet (element, options, dontCheckInContext) {\n  const ret = this[this.indexOfElement(element, options && options.context)];\n\n  return ret && (is.string(element) || dontCheckInContext || ret.inContext(element))? ret : null;\n};\n\nscope.interactables.forEachMatch = function (element, callback) {\n  for (const interactable of this) {\n    let ret;\n\n    if ((is.string(interactable.target)\n        // target is a selector and the element matches\n        ? (is.element(element) && matchesSelector(element, interactable.target))\n        // target is the element\n        : element === interactable.target)\n        // the element is in context\n      && (interactable.inContext(element))) {\n      ret = callback(interactable);\n    }\n\n    if (ret !== undefined) {\n      return ret;\n    }\n  }\n};\n\n// all interact.js eventTypes\nInteractable.eventTypes = scope.eventTypes = [];\n\nInteractable.signals = signals;\n\nInteractable.settingsMethods = [ 'deltaSource', 'origin', 'preventDefault', 'rectChecker' ];\n\nmodule.exports = Interactable;\n","const scope      = require('./scope');\nconst utils      = require('./utils');\nconst events     = require('./utils/events');\nconst browser    = require('./utils/browser');\nconst domObjects = require('./utils/domObjects');\nconst finder     = require('./utils/interactionFinder');\nconst signals    = require('./utils/Signals').new();\n\nconst listeners   = {};\nconst methodNames = [\n  'pointerDown', 'pointerMove', 'pointerUp',\n  'updatePointer', 'removePointer',\n];\n\n// for ignoring browser's simulated mouse events\nlet prevTouchTime = 0;\n\n// all active and idle interactions\nscope.interactions = [];\n\nclass Interaction {\n  /** */\n  constructor ({ pointerType }) {\n    this.target        = null; // current interactable being interacted with\n    this.element       = null; // the target element of the interactable\n\n    this.prepared      = {     // action that's ready to be fired on next move event\n      name : null,\n      axis : null,\n      edges: null,\n    };\n\n    // keep track of added pointers\n    this.pointers    = [];\n    this.pointerIds  = [];\n    this.downTargets = [];\n    this.downTimes   = [];\n\n    // Previous native pointer move event coordinates\n    this.prevCoords = {\n      page     : { x: 0, y: 0 },\n      client   : { x: 0, y: 0 },\n      timeStamp: 0,\n    };\n    // current native pointer move event coordinates\n    this.curCoords = {\n      page     : { x: 0, y: 0 },\n      client   : { x: 0, y: 0 },\n      timeStamp: 0,\n    };\n\n    // Starting InteractEvent pointer coordinates\n    this.startCoords = {\n      page     : { x: 0, y: 0 },\n      client   : { x: 0, y: 0 },\n      timeStamp: 0,\n    };\n\n    // Change in coordinates and time of the pointer\n    this.pointerDelta = {\n      page     : { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n      client   : { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n      timeStamp: 0,\n    };\n\n    this.downEvent   = null;    // pointerdown/mousedown/touchstart event\n    this.downPointer = {};\n\n    this._eventTarget    = null;\n    this._curEventTarget = null;\n\n    this.prevEvent = null;      // previous action event\n\n    this.pointerIsDown   = false;\n    this.pointerWasMoved = false;\n    this._interacting    = false;\n    this._ending         = false;\n\n    this.pointerType = pointerType;\n\n    signals.fire('new', this);\n\n    scope.interactions.push(this);\n  }\n\n  pointerDown (pointer, event, eventTarget) {\n    const pointerIndex = this.updatePointer(pointer, event, true);\n\n    signals.fire('down', {\n      pointer,\n      event,\n      eventTarget,\n      pointerIndex,\n      interaction: this,\n    });\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable({\n   *     // disable the default drag start by down->move\n   *     manualStart: true\n   *   })\n   *   // start dragging after the user holds the pointer down\n   *   .on('hold', function (event) {\n   *     var interaction = event.interaction;\n   *\n   *     if (!interaction.interacting()) {\n   *       interaction.start({ name: 'drag' },\n   *                         event.interactable,\n   *                         event.currentTarget);\n   *     }\n   * });\n   * ```\n   *\n   * Start an action with the given Interactable and Element as tartgets. The\n   * action must be enabled for the target Interactable and an appropriate\n   * number of pointers must be held down - 1 for drag/resize, 2 for gesture.\n   *\n   * Use it with `interactable.<action>able({ manualStart: false })` to always\n   * [start actions manually](https://github.com/taye/interact.js/issues/114)\n   *\n   * @param {object} action   The action to be performed - drag, resize, etc.\n   * @param {Interactable} target  The Interactable to target\n   * @param {Element} element The DOM Element to target\n   * @return {object} interact\n   */\n  start (action, target, element) {\n    if (this.interacting()\n        || !this.pointerIsDown\n        || this.pointerIds.length < (action.name === 'gesture'? 2 : 1)) {\n      return;\n    }\n\n    // if this interaction had been removed after stopping\n    // add it back\n    if (scope.interactions.indexOf(this) === -1) {\n      scope.interactions.push(this);\n    }\n\n    utils.copyAction(this.prepared, action);\n    this.target         = target;\n    this.element        = element;\n\n    signals.fire('action-start', {\n      interaction: this,\n      event: this.downEvent,\n    });\n  }\n\n  pointerMove (pointer, event, eventTarget) {\n    if (!this.simulation) {\n      this.updatePointer(pointer);\n      utils.setCoords(this.curCoords, this.pointers);\n    }\n\n    const duplicateMove = (this.curCoords.page.x === this.prevCoords.page.x\n                           && this.curCoords.page.y === this.prevCoords.page.y\n                           && this.curCoords.client.x === this.prevCoords.client.x\n                           && this.curCoords.client.y === this.prevCoords.client.y);\n\n    let dx;\n    let dy;\n\n    // register movement greater than pointerMoveTolerance\n    if (this.pointerIsDown && !this.pointerWasMoved) {\n      dx = this.curCoords.client.x - this.startCoords.client.x;\n      dy = this.curCoords.client.y - this.startCoords.client.y;\n\n      this.pointerWasMoved = utils.hypot(dx, dy) > Interaction.pointerMoveTolerance;\n    }\n\n    const signalArg = {\n      pointer,\n      pointerIndex: this.getPointerIndex(pointer),\n      event,\n      eventTarget,\n      dx,\n      dy,\n      duplicate: duplicateMove,\n      interaction: this,\n      interactingBeforeMove: this.interacting(),\n    };\n\n    if (!duplicateMove) {\n      // set pointer coordinate, time changes and speeds\n      utils.setCoordDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n    }\n\n    signals.fire('move', signalArg);\n\n    if (!duplicateMove) {\n      // if interacting, fire an 'action-move' signal etc\n      if (this.interacting()) {\n        this.doMove(signalArg);\n      }\n\n      if (this.pointerWasMoved) {\n        utils.copyCoords(this.prevCoords, this.curCoords);\n      }\n    }\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable(true)\n   *   .on('dragmove', function (event) {\n   *     if (someCondition) {\n   *       // change the snap settings\n   *       event.interactable.draggable({ snap: { targets: [] }});\n   *       // fire another move event with re-calculated snap\n   *       event.interaction.doMove();\n   *     }\n   *   });\n   * ```\n   *\n   * Force a move of the current action at the same coordinates. Useful if\n   * snap/restrict has been changed and you want a movement with the new\n   * settings.\n   */\n  doMove (signalArg) {\n    signalArg = utils.extend({\n      pointer: this.pointers[0],\n      event: this.prevEvent,\n      eventTarget: this._eventTarget,\n      interaction: this,\n    }, signalArg || {});\n\n    signals.fire('before-action-move', signalArg);\n\n    if (!this._dontFireMove) {\n      signals.fire('action-move', signalArg);\n    }\n\n    this._dontFireMove = false;\n  }\n\n  // End interact move events and stop auto-scroll unless simulation is running\n  pointerUp (pointer, event, eventTarget, curEventTarget) {\n    const pointerIndex = this.getPointerIndex(pointer);\n\n    signals.fire(/cancel$/i.test(event.type)? 'cancel' : 'up', {\n      pointer,\n      pointerIndex,\n      event,\n      eventTarget,\n      curEventTarget,\n      interaction: this,\n    });\n\n    if (!this.simulation) {\n      this.end(event);\n    }\n\n    this.pointerIsDown = false;\n    this.removePointer(pointer, event);\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable(true)\n   *   .on('move', function (event) {\n   *     if (event.pageX > 1000) {\n   *       // end the current action\n   *       event.interaction.end();\n   *       // stop all further listeners from being called\n   *       event.stopImmediatePropagation();\n   *     }\n   *   });\n   * ```\n   *\n   * Stop the current action and fire an end event. Inertial movement does\n   * not happen.\n   *\n   * @param {PointerEvent} [event]\n   */\n  end (event) {\n    this._ending = true;\n\n    event = event || this.prevEvent;\n\n    if (this.interacting()) {\n      signals.fire('action-end', {\n        event,\n        interaction: this,\n      });\n    }\n\n    this.stop();\n    this._ending = false;\n  }\n\n  currentAction () {\n    return this._interacting? this.prepared.name: null;\n  }\n\n  interacting () {\n    return this._interacting;\n  }\n\n  /** */\n  stop () {\n    signals.fire('stop', { interaction: this });\n\n    if (this._interacting) {\n      signals.fire('stop-active', { interaction: this });\n      signals.fire('stop-' + this.prepared.name, { interaction: this });\n    }\n\n    this.target = this.element = null;\n\n    this._interacting = false;\n    this.prepared.name = this.prevEvent = null;\n  }\n\n  getPointerIndex (pointer) {\n    // mouse and pen interactions may have only one pointer\n    if (this.pointerType === 'mouse' || this.pointerType === 'pen') {\n      return 0;\n    }\n\n    return this.pointerIds.indexOf(utils.getPointerId(pointer));\n  }\n\n  updatePointer (pointer, event, down = event && /(down|start)$/i.test(event.type)) {\n    const id = utils.getPointerId(pointer);\n    let index = this.getPointerIndex(pointer);\n\n    if (index === -1) {\n      index = this.pointerIds.length;\n      this.pointerIds[index] = id;\n    }\n\n    if (down) {\n      signals.fire('update-pointer-down', {\n        pointer,\n        event,\n        down,\n        pointerId: id,\n        pointerIndex: index,\n        interaction: this,\n      });\n    }\n\n    this.pointers[index] = pointer;\n\n    return index;\n  }\n\n  removePointer (pointer, event) {\n    const index = this.getPointerIndex(pointer);\n\n    if (index === -1) { return; }\n\n    signals.fire('remove-pointer', {\n      pointer,\n      event,\n      pointerIndex: index,\n      interaction: this,\n    });\n\n    this.pointers   .splice(index, 1);\n    this.pointerIds .splice(index, 1);\n    this.downTargets.splice(index, 1);\n    this.downTimes  .splice(index, 1);\n  }\n\n  _updateEventTargets (target, currentTarget) {\n    this._eventTarget    = target;\n    this._curEventTarget = currentTarget;\n  }\n}\n\nfor (const method of methodNames) {\n  listeners[method] = doOnInteractions(method);\n}\n\nfunction doOnInteractions (method) {\n  return (function (event) {\n    const pointerType = utils.getPointerType(event);\n    const [eventTarget, curEventTarget] = utils.getEventTargets(event);\n    const matches = []; // [ [pointer, interaction], ...]\n\n    if (browser.supportsTouch && /touch/.test(event.type)) {\n      prevTouchTime = new Date().getTime();\n\n      for (const changedTouch of event.changedTouches) {\n        const pointer = changedTouch;\n        const interaction = finder.search(pointer, event.type, eventTarget);\n\n        matches.push([pointer, interaction || new Interaction({ pointerType })]);\n      }\n    }\n    else {\n      let invalidPointer = false;\n\n      if (!browser.supportsPointerEvent && /mouse/.test(event.type)) {\n        // ignore mouse events while touch interactions are active\n        for (let i = 0; i < scope.interactions.length && !invalidPointer; i++) {\n          invalidPointer = scope.interactions[i].pointerType !== 'mouse' && scope.interactions[i].pointerIsDown;\n        }\n\n        // try to ignore mouse events that are simulated by the browser\n        // after a touch event\n        invalidPointer = invalidPointer\n          || (new Date().getTime() - prevTouchTime < 500)\n          // on iOS and Firefox Mobile, MouseEvent.timeStamp is zero if simulated\n          || event.timeStamp === 0;\n      }\n\n      if (!invalidPointer) {\n        let interaction = finder.search(event, event.type, eventTarget);\n\n        if (!interaction) {\n          interaction = new Interaction({ pointerType });\n        }\n\n        matches.push([event, interaction]);\n      }\n    }\n\n    for (const [pointer, interaction] of matches) {\n      interaction._updateEventTargets(eventTarget, curEventTarget);\n      interaction[method](pointer, event, eventTarget, curEventTarget);\n    }\n  });\n}\n\nfunction endAll (event) {\n  for (const interaction of scope.interactions) {\n    interaction.end(event);\n    signals.fire('endall', { event, interaction });\n  }\n}\n\nconst docEvents = { /* 'eventType': listenerFunc */ };\nconst pEventTypes = browser.pEventTypes;\n\nif (domObjects.PointerEvent) {\n  docEvents[pEventTypes.down  ] = listeners.pointerDown;\n  docEvents[pEventTypes.move  ] = listeners.pointerMove;\n  docEvents[pEventTypes.up    ] = listeners.pointerUp;\n  docEvents[pEventTypes.cancel] = listeners.pointerUp;\n}\nelse {\n  docEvents.mousedown   = listeners.pointerDown;\n  docEvents.mousemove   = listeners.pointerMove;\n  docEvents.mouseup     = listeners.pointerUp;\n\n  docEvents.touchstart  = listeners.pointerDown;\n  docEvents.touchmove   = listeners.pointerMove;\n  docEvents.touchend    = listeners.pointerUp;\n  docEvents.touchcancel = listeners.pointerUp;\n}\n\ndocEvents.blur = endAll;\n\nfunction onDocSignal ({ doc }, signalName) {\n  const eventMethod = signalName.indexOf('add') === 0\n    ? events.add : events.remove;\n\n  // delegate event listener\n  for (const eventType in scope.delegatedEvents) {\n    eventMethod(doc, eventType, events.delegateListener);\n    eventMethod(doc, eventType, events.delegateUseCapture, true);\n  }\n\n  for (const eventType in docEvents) {\n    eventMethod(doc, eventType, docEvents[eventType], browser.isIOS ? { passive: false } : undefined);\n  }\n}\n\nsignals.on('update-pointer-down', ({ interaction, pointer, pointerId, pointerIndex, event, eventTarget, down }) => {\n  interaction.pointerIds[pointerIndex] = pointerId;\n  interaction.pointers[pointerIndex] = pointer;\n\n  if (down) {\n    interaction.pointerIsDown = true;\n  }\n\n  if (!interaction.interacting()) {\n    utils.setCoords(interaction.startCoords, interaction.pointers);\n\n    utils.copyCoords(interaction.curCoords , interaction.startCoords);\n    utils.copyCoords(interaction.prevCoords, interaction.startCoords);\n\n    interaction.downEvent                 = event;\n    interaction.downTimes[pointerIndex]   = interaction.curCoords.timeStamp;\n    interaction.downTargets[pointerIndex] = eventTarget || event && utils.getEventTargets(event)[0];\n    interaction.pointerWasMoved           = false;\n\n    utils.pointerExtend(interaction.downPointer, pointer);\n  }\n});\n\nscope.signals.on('add-document'   , onDocSignal);\nscope.signals.on('remove-document', onDocSignal);\n\nInteraction.pointerMoveTolerance = 1;\nInteraction.doOnInteractions = doOnInteractions;\nInteraction.endAll = endAll;\nInteraction.signals = signals;\nInteraction.docEvents = docEvents;\n\nscope.endAllInteractions = endAll;\n\nmodule.exports = Interaction;\n","const Interaction   = require('../Interaction');\nconst InteractEvent = require('../InteractEvent');\n\nconst actions = {\n  firePrepared,\n  names: [],\n  methodDict: {},\n};\n\nInteraction.signals.on('action-start', function ({ interaction, event }) {\n  interaction._interacting = true;\n  firePrepared(interaction, event, 'start');\n});\n\nInteraction.signals.on('action-move', function ({ interaction, event, preEnd }) {\n  firePrepared(interaction, event, 'move', preEnd);\n\n  // if the action was ended in a listener\n  if (!interaction.interacting()) { return false; }\n});\n\nInteraction.signals.on('action-end', function ({ interaction, event }) {\n  firePrepared(interaction, event, 'end');\n});\n\nfunction firePrepared (interaction, event, phase, preEnd) {\n  const actionName = interaction.prepared.name;\n\n  const newEvent = new InteractEvent(interaction, event, actionName, phase, interaction.element, null, preEnd);\n\n  interaction.target.fire(newEvent);\n  interaction.prevEvent = newEvent;\n}\n\nmodule.exports = actions;\n","const actions        = require('./base');\nconst utils          = require('../utils');\nconst InteractEvent  = require('../InteractEvent');\n/** @lends Interactable */\nconst Interactable   = require('../Interactable');\nconst Interaction    = require('../Interaction');\nconst defaultOptions = require('../defaultOptions');\n\nconst drag = {\n  defaults: {\n    enabled     : false,\n    mouseButtons: null,\n\n    origin    : null,\n    snap      : null,\n    restrict  : null,\n    inertia   : null,\n    autoScroll: null,\n\n    startAxis : 'xy',\n    lockAxis  : 'xy',\n  },\n\n  checker: function (pointer, event, interactable) {\n    const dragOptions = interactable.options.drag;\n\n    return dragOptions.enabled\n      ? { name: 'drag', axis: (dragOptions.lockAxis === 'start'\n                               ? dragOptions.startAxis\n                               : dragOptions.lockAxis)}\n      : null;\n  },\n\n  getCursor: function () {\n    return 'move';\n  },\n};\n\nInteraction.signals.on('before-action-move', function ({ interaction }) {\n  if (interaction.prepared.name !== 'drag') { return; }\n\n  const axis = interaction.prepared.axis;\n\n  if (axis === 'x') {\n    interaction.curCoords.page.y   = interaction.startCoords.page.y;\n    interaction.curCoords.client.y = interaction.startCoords.client.y;\n\n    interaction.pointerDelta.page.speed   = Math.abs(interaction.pointerDelta.page.vx);\n    interaction.pointerDelta.client.speed = Math.abs(interaction.pointerDelta.client.vx);\n    interaction.pointerDelta.client.vy = 0;\n    interaction.pointerDelta.page.vy   = 0;\n  }\n  else if (axis === 'y') {\n    interaction.curCoords.page.x   = interaction.startCoords.page.x;\n    interaction.curCoords.client.x = interaction.startCoords.client.x;\n\n    interaction.pointerDelta.page.speed   = Math.abs(interaction.pointerDelta.page.vy);\n    interaction.pointerDelta.client.speed = Math.abs(interaction.pointerDelta.client.vy);\n    interaction.pointerDelta.client.vx = 0;\n    interaction.pointerDelta.page.vx   = 0;\n  }\n});\n\n// dragmove\nInteractEvent.signals.on('new', function ({ iEvent, interaction }) {\n  if (iEvent.type !== 'dragmove') { return; }\n\n  const axis = interaction.prepared.axis;\n\n  if (axis === 'x') {\n    iEvent.pageY   = interaction.startCoords.page.y;\n    iEvent.clientY = interaction.startCoords.client.y;\n    iEvent.dy = 0;\n  }\n  else if (axis === 'y') {\n    iEvent.pageX   = interaction.startCoords.page.x;\n    iEvent.clientX = interaction.startCoords.client.x;\n    iEvent.dx = 0;\n  }\n});\n\n/**\n * ```js\n * interact(element).draggable({\n *     onstart: function (event) {},\n *     onmove : function (event) {},\n *     onend  : function (event) {},\n *\n *     // the axis in which the first movement must be\n *     // for the drag sequence to start\n *     // 'xy' by default - any direction\n *     startAxis: 'x' || 'y' || 'xy',\n *\n *     // 'xy' by default - don't restrict to one axis (move in any direction)\n *     // 'x' or 'y' to restrict movement to either axis\n *     // 'start' to restrict movement to the axis the drag started in\n *     lockAxis: 'x' || 'y' || 'xy' || 'start',\n *\n *     // max number of drags that can happen concurrently\n *     // with elements of this Interactable. Infinity by default\n *     max: Infinity,\n *\n *     // max number of drags that can target the same element+Interactable\n *     // 1 by default\n *     maxPerElement: 2\n * });\n *\n * var isDraggable = interact('element').draggable(); // true\n * ```\n *\n * Get or set whether drag actions can be performed on the target\n *\n * @param {boolean | object} [options] true/false or An object with event\n * listeners to be fired on drag events (object makes the Interactable\n * draggable)\n * @return {boolean | Interactable} boolean indicating if this can be the\n * target of drag events, or this Interctable\n */\nInteractable.prototype.draggable = function (options) {\n  if (utils.is.object(options)) {\n    this.options.drag.enabled = options.enabled === false? false: true;\n    this.setPerAction('drag', options);\n    this.setOnEvents('drag', options);\n\n    if (/^(xy|x|y|start)$/.test(options.lockAxis)) {\n      this.options.drag.lockAxis = options.lockAxis;\n    }\n    if (/^(xy|x|y)$/.test(options.startAxis)) {\n      this.options.drag.startAxis = options.startAxis;\n    }\n\n    return this;\n  }\n\n  if (utils.is.bool(options)) {\n    this.options.drag.enabled = options;\n\n    if (!options) {\n      this.ondragstart = this.ondragstart = this.ondragend = null;\n    }\n\n    return this;\n  }\n\n  return this.options.drag;\n};\n\nactions.drag = drag;\nactions.names.push('drag');\nutils.merge(Interactable.eventTypes, [\n  'dragstart',\n  'dragmove',\n  'draginertiastart',\n  'draginertiaresume',\n  'dragend',\n]);\nactions.methodDict.drag = 'draggable';\n\ndefaultOptions.drag = drag.defaults;\n\nmodule.exports = drag;\n","const actions        = require('./base');\nconst utils          = require('../utils');\nconst scope          = require('../scope');\n/** @lends module:interact */\nconst interact       = require('../interact');\nconst InteractEvent  = require('../InteractEvent');\n/** @lends Interactable */\nconst Interactable   = require('../Interactable');\nconst Interaction    = require('../Interaction');\nconst defaultOptions = require('../defaultOptions');\n\nconst drop = {\n  defaults: {\n    enabled: false,\n    accept : null,\n    overlap: 'pointer',\n  },\n};\n\nlet dynamicDrop = false;\n\nInteraction.signals.on('action-start', function ({ interaction, event }) {\n  if (interaction.prepared.name !== 'drag') { return; }\n\n  // reset active dropzones\n  interaction.activeDrops.dropzones = [];\n  interaction.activeDrops.elements  = [];\n  interaction.activeDrops.rects     = [];\n\n  interaction.dropEvents = null;\n\n  if (!interaction.dynamicDrop) {\n    setActiveDrops(interaction.activeDrops, interaction.element);\n  }\n\n  const dragEvent = interaction.prevEvent;\n  const dropEvents = getDropEvents(interaction, event, dragEvent);\n\n  if (dropEvents.activate) {\n    fireActiveDrops(interaction.activeDrops, dropEvents.activate);\n  }\n});\n\nInteractEvent.signals.on('new', function ({ interaction, iEvent, event }) {\n  if (iEvent.type !== 'dragmove' && iEvent.type !== 'dragend') { return; }\n\n  const draggableElement = interaction.element;\n  const dragEvent = iEvent;\n  const dropResult = getDrop(dragEvent, event, draggableElement);\n\n  interaction.dropTarget  = dropResult.dropzone;\n  interaction.dropElement = dropResult.element;\n\n  interaction.dropEvents = getDropEvents(interaction, event, dragEvent);\n});\n\nInteraction.signals.on('action-move', function ({ interaction }) {\n  if (interaction.prepared.name !== 'drag') { return; }\n\n  fireDropEvents(interaction, interaction.dropEvents);\n});\n\nInteraction.signals.on('action-end', function ({ interaction }) {\n  if (interaction.prepared.name === 'drag') {\n    fireDropEvents(interaction, interaction.dropEvents);\n  }\n});\n\nInteraction.signals.on('stop-drag', function ({ interaction }) {\n  interaction.activeDrops = {\n    dropzones: null,\n    elements: null,\n    rects: null,\n  };\n\n  interaction.dropEvents = null;\n});\n\nfunction collectDrops (activeDrops, element) {\n  const drops = [];\n  const elements = [];\n\n  // collect all dropzones and their elements which qualify for a drop\n  for (const current of scope.interactables) {\n    if (!current.options.drop.enabled) { continue; }\n\n    const accept = current.options.drop.accept;\n\n    // test the draggable element against the dropzone's accept setting\n    if ((utils.is.element(accept) && accept !== element)\n        || (utils.is.string(accept)\n        && !utils.matchesSelector(element, accept))) {\n\n      continue;\n    }\n\n    // query for new elements if necessary\n    const dropElements = utils.is.string(current.target)\n      ? current._context.querySelectorAll(current.target)\n      : [current.target];\n\n    for (const currentElement of dropElements) {\n      if (currentElement !== element) {\n        drops.push(current);\n        elements.push(currentElement);\n      }\n    }\n  }\n\n  return {\n    elements,\n    dropzones: drops,\n  };\n}\n\nfunction fireActiveDrops (activeDrops, event) {\n  let prevElement;\n\n  // loop through all active dropzones and trigger event\n  for (let i = 0; i < activeDrops.dropzones.length; i++) {\n    const current = activeDrops.dropzones[i];\n    const currentElement = activeDrops.elements [i];\n\n    // prevent trigger of duplicate events on same element\n    if (currentElement !== prevElement) {\n      // set current element as event target\n      event.target = currentElement;\n      current.fire(event);\n    }\n    prevElement = currentElement;\n  }\n}\n\n// Collect a new set of possible drops and save them in activeDrops.\n// setActiveDrops should always be called when a drag has just started or a\n// drag event happens while dynamicDrop is true\nfunction setActiveDrops (activeDrops, dragElement) {\n  // get dropzones and their elements that could receive the draggable\n  const possibleDrops = collectDrops(activeDrops, dragElement);\n\n  activeDrops.dropzones = possibleDrops.dropzones;\n  activeDrops.elements  = possibleDrops.elements;\n  activeDrops.rects     = [];\n\n  for (let i = 0; i < activeDrops.dropzones.length; i++) {\n    activeDrops.rects[i] = activeDrops.dropzones[i].getRect(activeDrops.elements[i]);\n  }\n}\n\nfunction getDrop (dragEvent, event, dragElement) {\n  const interaction = dragEvent.interaction;\n  const validDrops = [];\n\n  if (dynamicDrop) {\n    setActiveDrops(interaction.activeDrops, dragElement);\n  }\n\n  // collect all dropzones and their elements which qualify for a drop\n  for (let j = 0; j < interaction.activeDrops.dropzones.length; j++) {\n    const current        = interaction.activeDrops.dropzones[j];\n    const currentElement = interaction.activeDrops.elements [j];\n    const rect           = interaction.activeDrops.rects    [j];\n\n    validDrops.push(current.dropCheck(dragEvent, event, interaction.target, dragElement, currentElement, rect)\n      ? currentElement\n      : null);\n  }\n\n  // get the most appropriate dropzone based on DOM depth and order\n  const dropIndex = utils.indexOfDeepestElement(validDrops);\n\n  return {\n    dropzone: interaction.activeDrops.dropzones[dropIndex] || null,\n    element : interaction.activeDrops.elements [dropIndex] || null,\n  };\n}\n\nfunction getDropEvents (interaction, pointerEvent, dragEvent) {\n  const dropEvents = {\n    enter     : null,\n    leave     : null,\n    activate  : null,\n    deactivate: null,\n    move      : null,\n    drop      : null,\n  };\n\n  const tmpl = {\n    dragEvent,\n    interaction,\n    target       : interaction.dropElement,\n    dropzone     : interaction.dropTarget,\n    relatedTarget: dragEvent.target,\n    draggable    : dragEvent.interactable,\n    timeStamp    : dragEvent.timeStamp,\n  };\n\n  if (interaction.dropElement !== interaction.prevDropElement) {\n    // if there was a prevDropTarget, create a dragleave event\n    if (interaction.prevDropTarget) {\n      dropEvents.leave = utils.extend({ type: 'dragleave' }, tmpl);\n\n      dragEvent.dragLeave    = dropEvents.leave.target   = interaction.prevDropElement;\n      dragEvent.prevDropzone = dropEvents.leave.dropzone = interaction.prevDropTarget;\n    }\n    // if the dropTarget is not null, create a dragenter event\n    if (interaction.dropTarget) {\n      dropEvents.enter = {\n        dragEvent,\n        interaction,\n        target       : interaction.dropElement,\n        dropzone     : interaction.dropTarget,\n        relatedTarget: dragEvent.target,\n        draggable    : dragEvent.interactable,\n        timeStamp    : dragEvent.timeStamp,\n        type         : 'dragenter',\n      };\n\n      dragEvent.dragEnter = interaction.dropElement;\n      dragEvent.dropzone = interaction.dropTarget;\n    }\n  }\n\n  if (dragEvent.type === 'dragend' && interaction.dropTarget) {\n    dropEvents.drop = utils.extend({ type: 'drop' }, tmpl);\n\n    dragEvent.dropzone = interaction.dropTarget;\n    dragEvent.relatedTarget = interaction.dropElement;\n  }\n  if (dragEvent.type === 'dragstart') {\n    dropEvents.activate = utils.extend({ type: 'dropactivate' }, tmpl);\n\n    dropEvents.activate.target   = null;\n    dropEvents.activate.dropzone = null;\n  }\n  if (dragEvent.type === 'dragend') {\n    dropEvents.deactivate = utils.extend({ type: 'dropdeactivate' }, tmpl);\n\n    dropEvents.deactivate.target   = null;\n    dropEvents.deactivate.dropzone = null;\n  }\n  if (dragEvent.type === 'dragmove' && interaction.dropTarget) {\n    dropEvents.move = utils.extend({\n      dragmove     : dragEvent,\n      type         : 'dropmove',\n    }, tmpl);\n\n    dragEvent.dropzone = interaction.dropTarget;\n  }\n\n  return dropEvents;\n}\n\nfunction fireDropEvents (interaction, dropEvents) {\n  const {\n    activeDrops,\n    prevDropTarget,\n    dropTarget,\n    dropElement,\n  } = interaction;\n\n  if (dropEvents.leave) { prevDropTarget.fire(dropEvents.leave); }\n  if (dropEvents.move ) {     dropTarget.fire(dropEvents.move ); }\n  if (dropEvents.enter) {     dropTarget.fire(dropEvents.enter); }\n  if (dropEvents.drop ) {     dropTarget.fire(dropEvents.drop ); }\n  if (dropEvents.deactivate) {\n    fireActiveDrops(activeDrops, dropEvents.deactivate);\n  }\n\n  interaction.prevDropTarget  = dropTarget;\n  interaction.prevDropElement = dropElement;\n}\n\n/**\n * ```js\n * interact(target)\n * .dropChecker(function(dragEvent,         // related dragmove or dragend event\n *                       event,             // TouchEvent/PointerEvent/MouseEvent\n *                       dropped,           // bool result of the default checker\n *                       dropzone,          // dropzone Interactable\n *                       dropElement,       // dropzone elemnt\n *                       draggable,         // draggable Interactable\n *                       draggableElement) {// draggable element\n *\n *   return dropped && event.target.hasAttribute('allow-drop');\n * }\n * ```\n *\n * ```js\n * interact('.drop').dropzone({\n *   accept: '.can-drop' || document.getElementById('single-drop'),\n *   overlap: 'pointer' || 'center' || zeroToOne\n * }\n * ```\n *\n * Returns or sets whether draggables can be dropped onto this target to\n * trigger drop events\n *\n * Dropzones can receive the following events:\n *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends\n *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone\n *  - `dragmove` when a draggable that has entered the dropzone is moved\n *  - `drop` when a draggable is dropped into this dropzone\n *\n * Use the `accept` option to allow only elements that match the given CSS\n * selector or element. The value can be:\n *\n *  - **an Element** - only that element can be dropped into this dropzone.\n *  - **a string**, - the element being dragged must match it as a CSS selector.\n *  - **`null`** - accept options is cleared - it accepts any element.\n *\n * Use the `overlap` option to set how drops are checked for. The allowed\n * values are:\n *\n *   - `'pointer'`, the pointer must be over the dropzone (default)\n *   - `'center'`, the draggable element's center must be over the dropzone\n *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.\n *   e.g. `0.5` for drop to happen when half of the area of the draggable is\n *   over the dropzone\n *\n * Use the `checker` option to specify a function to check if a dragged element\n * is over this Interactable.\n *\n * @param {boolean | object | null} [options] The new options to be set.\n * @return {boolean | Interactable} The current setting or this Interactable\n */\nInteractable.prototype.dropzone = function (options) {\n  if (utils.is.object(options)) {\n    this.options.drop.enabled = options.enabled === false? false: true;\n\n    if (utils.is.function(options.ondrop)          ) { this.events.ondrop           = options.ondrop          ; }\n    if (utils.is.function(options.ondropactivate)  ) { this.events.ondropactivate   = options.ondropactivate  ; }\n    if (utils.is.function(options.ondropdeactivate)) { this.events.ondropdeactivate = options.ondropdeactivate; }\n    if (utils.is.function(options.ondragenter)     ) { this.events.ondragenter      = options.ondragenter     ; }\n    if (utils.is.function(options.ondragleave)     ) { this.events.ondragleave      = options.ondragleave     ; }\n    if (utils.is.function(options.ondropmove)      ) { this.events.ondropmove       = options.ondropmove      ; }\n\n    if (/^(pointer|center)$/.test(options.overlap)) {\n      this.options.drop.overlap = options.overlap;\n    }\n    else if (utils.is.number(options.overlap)) {\n      this.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0);\n    }\n    if ('accept' in options) {\n      this.options.drop.accept = options.accept;\n    }\n    if ('checker' in options) {\n      this.options.drop.checker = options.checker;\n    }\n\n\n    return this;\n  }\n\n  if (utils.is.bool(options)) {\n    this.options.drop.enabled = options;\n\n    if (!options) {\n      this.ondragenter = this.ondragleave = this.ondrop\n        = this.ondropactivate = this.ondropdeactivate = null;\n    }\n\n    return this;\n  }\n\n  return this.options.drop;\n};\n\nInteractable.prototype.dropCheck = function (dragEvent, event, draggable, draggableElement, dropElement, rect) {\n  let dropped = false;\n\n  // if the dropzone has no rect (eg. display: none)\n  // call the custom dropChecker or just return false\n  if (!(rect = rect || this.getRect(dropElement))) {\n    return (this.options.drop.checker\n      ? this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement)\n      : false);\n  }\n\n  const dropOverlap = this.options.drop.overlap;\n\n  if (dropOverlap === 'pointer') {\n    const origin = utils.getOriginXY(draggable, draggableElement, 'drag');\n    const page = utils.getPageXY(dragEvent);\n\n    page.x += origin.x;\n    page.y += origin.y;\n\n    const horizontal = (page.x > rect.left) && (page.x < rect.right);\n    const vertical   = (page.y > rect.top ) && (page.y < rect.bottom);\n\n    dropped = horizontal && vertical;\n  }\n\n  const dragRect = draggable.getRect(draggableElement);\n\n  if (dragRect && dropOverlap === 'center') {\n    const cx = dragRect.left + dragRect.width  / 2;\n    const cy = dragRect.top  + dragRect.height / 2;\n\n    dropped = cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom;\n  }\n\n  if (dragRect && utils.is.number(dropOverlap)) {\n    const overlapArea  = (Math.max(0, Math.min(rect.right , dragRect.right ) - Math.max(rect.left, dragRect.left))\n                          * Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top , dragRect.top )));\n\n    const overlapRatio = overlapArea / (dragRect.width * dragRect.height);\n\n    dropped = overlapRatio >= dropOverlap;\n  }\n\n  if (this.options.drop.checker) {\n    dropped = this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement);\n  }\n\n  return dropped;\n};\n\nInteractable.signals.on('unset', function ({ interactable }) {\n  interactable.dropzone(false);\n});\n\nInteractable.settingsMethods.push('dropChecker');\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.dropTarget      = null; // the dropzone a drag target might be dropped into\n  interaction.dropElement     = null; // the element at the time of checking\n  interaction.prevDropTarget  = null; // the dropzone that was recently dragged away from\n  interaction.prevDropElement = null; // the element at the time of checking\n  interaction.dropEvents      = null; // the dropEvents related to the current drag event\n\n  interaction.activeDrops = {\n    dropzones: [],      // the dropzones that are mentioned below\n    elements : [],      // elements of dropzones that accept the target draggable\n    rects    : [],      // the rects of the elements mentioned above\n  };\n\n});\n\nInteraction.signals.on('stop', function ({ interaction }) {\n  interaction.dropTarget = interaction.dropElement =\n    interaction.prevDropTarget = interaction.prevDropElement = null;\n});\n\n/**\n * Returns or sets whether the dimensions of dropzone elements are calculated\n * on every dragmove or only on dragstart for the default dropChecker\n *\n * @param {boolean} [newValue] True to check on each move. False to check only\n * before start\n * @return {boolean | interact} The current setting or interact\n */\ninteract.dynamicDrop = function (newValue) {\n  if (utils.is.bool(newValue)) {\n    //if (dragging && dynamicDrop !== newValue && !newValue) {\n      //calcRects(dropzones);\n    //}\n\n    dynamicDrop = newValue;\n\n    return interact;\n  }\n  return dynamicDrop;\n};\n\nutils.merge(Interactable.eventTypes, [\n  'dragenter',\n  'dragleave',\n  'dropactivate',\n  'dropdeactivate',\n  'dropmove',\n  'drop',\n]);\nactions.methodDict.drop = 'dropzone';\n\ndefaultOptions.drop = drop.defaults;\n\nmodule.exports = drop;\n","const actions        = require('./base');\nconst utils          = require('../utils');\nconst InteractEvent  = require('../InteractEvent');\nconst Interactable   = require('../Interactable');\nconst Interaction    = require('../Interaction');\nconst defaultOptions = require('../defaultOptions');\n\nconst gesture = {\n  defaults: {\n    enabled : false,\n    origin  : null,\n    restrict: null,\n  },\n\n  checker: function (pointer, event, interactable, element, interaction) {\n    if (interaction.pointerIds.length >= 2) {\n      return { name: 'gesture' };\n    }\n\n    return null;\n  },\n\n  getCursor: function () {\n    return '';\n  },\n};\n\nInteractEvent.signals.on('new', function ({ iEvent, interaction }) {\n  if (iEvent.type !== 'gesturestart') { return; }\n  iEvent.ds = 0;\n\n  interaction.gesture.startDistance = interaction.gesture.prevDistance = iEvent.distance;\n  interaction.gesture.startAngle = interaction.gesture.prevAngle = iEvent.angle;\n  interaction.gesture.scale = 1;\n});\n\nInteractEvent.signals.on('new', function ({ iEvent, interaction }) {\n  if (iEvent.type !== 'gesturemove') { return; }\n\n  iEvent.ds = iEvent.scale - interaction.gesture.scale;\n\n  interaction.target.fire(iEvent);\n\n  interaction.gesture.prevAngle = iEvent.angle;\n  interaction.gesture.prevDistance = iEvent.distance;\n\n  if (iEvent.scale !== Infinity\n      && iEvent.scale !== null\n      && iEvent.scale !== undefined\n      && !isNaN(iEvent.scale)) {\n\n    interaction.gesture.scale = iEvent.scale;\n  }\n});\n\n/**\n * ```js\n * interact(element).gesturable({\n *     onstart: function (event) {},\n *     onmove : function (event) {},\n *     onend  : function (event) {},\n *\n *     // limit multiple gestures.\n *     // See the explanation in {@link Interactable.draggable} example\n *     max: Infinity,\n *     maxPerElement: 1,\n * });\n *\n * var isGestureable = interact(element).gesturable();\n * ```\n *\n * Gets or sets whether multitouch gestures can be performed on the target\n *\n * @param {boolean | object} [options] true/false or An object with event\n * listeners to be fired on gesture events (makes the Interactable gesturable)\n * @return {boolean | Interactable} A boolean indicating if this can be the\n * target of gesture events, or this Interactable\n */\nInteractable.prototype.gesturable = function (options) {\n  if (utils.is.object(options)) {\n    this.options.gesture.enabled = options.enabled === false? false: true;\n    this.setPerAction('gesture', options);\n    this.setOnEvents('gesture', options);\n\n    return this;\n  }\n\n  if (utils.is.bool(options)) {\n    this.options.gesture.enabled = options;\n\n    if (!options) {\n      this.ongesturestart = this.ongesturestart = this.ongestureend = null;\n    }\n\n    return this;\n  }\n\n  return this.options.gesture;\n};\n\nInteractEvent.signals.on('set-delta', function ({ interaction, iEvent, action, event, starting, ending, deltaSource }) {\n  if (action !== 'gesture') { return; }\n\n  const pointers = interaction.pointers;\n\n  iEvent.touches = [pointers[0], pointers[1]];\n\n  if (starting) {\n    iEvent.distance = utils.touchDistance(pointers, deltaSource);\n    iEvent.box      = utils.touchBBox(pointers);\n    iEvent.scale    = 1;\n    iEvent.ds       = 0;\n    iEvent.angle    = utils.touchAngle(pointers, undefined, deltaSource);\n    iEvent.da       = 0;\n  }\n  else if (ending || event instanceof InteractEvent) {\n    iEvent.distance = interaction.prevEvent.distance;\n    iEvent.box      = interaction.prevEvent.box;\n    iEvent.scale    = interaction.prevEvent.scale;\n    iEvent.ds       = iEvent.scale - 1;\n    iEvent.angle    = interaction.prevEvent.angle;\n    iEvent.da       = iEvent.angle - interaction.gesture.startAngle;\n  }\n  else {\n    iEvent.distance = utils.touchDistance(pointers, deltaSource);\n    iEvent.box      = utils.touchBBox(pointers);\n    iEvent.scale    = iEvent.distance / interaction.gesture.startDistance;\n    iEvent.angle    = utils.touchAngle(pointers, interaction.gesture.prevAngle, deltaSource);\n\n    iEvent.ds = iEvent.scale - interaction.gesture.prevScale;\n    iEvent.da = iEvent.angle - interaction.gesture.prevAngle;\n  }\n});\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.gesture = {\n    start: { x: 0, y: 0 },\n\n    startDistance: 0,   // distance between two touches of touchStart\n    prevDistance : 0,\n    distance     : 0,\n\n    scale: 1,           // gesture.distance / gesture.startDistance\n\n    startAngle: 0,      // angle of line joining two touches\n    prevAngle : 0,      // angle of the previous gesture event\n  };\n});\n\nactions.gesture = gesture;\nactions.names.push('gesture');\nutils.merge(Interactable.eventTypes, [\n  'gesturestart',\n  'gesturemove',\n  'gestureend',\n]);\nactions.methodDict.gesture = 'gesturable';\n\ndefaultOptions.gesture = gesture.defaults;\n\nmodule.exports = gesture;\n","const actions        = require('./base');\nconst utils          = require('../utils');\nconst browser        = require('../utils/browser');\nconst InteractEvent  = require('../InteractEvent');\n/** @lends Interactable */\nconst Interactable   = require('../Interactable');\nconst Interaction    = require('../Interaction');\nconst defaultOptions = require('../defaultOptions');\n\n// Less Precision with touch input\nconst defaultMargin = browser.supportsTouch || browser.supportsPointerEvent? 20: 10;\n\nconst resize = {\n  defaults: {\n    enabled     : false,\n    mouseButtons: null,\n\n    origin    : null,\n    snap      : null,\n    restrict  : null,\n    inertia   : null,\n    autoScroll: null,\n\n    square: false,\n    preserveAspectRatio: false,\n    axis: 'xy',\n\n    // use default margin\n    margin: NaN,\n\n    // object with props left, right, top, bottom which are\n    // true/false values to resize when the pointer is over that edge,\n    // CSS selectors to match the handles for each direction\n    // or the Elements for each handle\n    edges: null,\n\n    // a value of 'none' will limit the resize rect to a minimum of 0x0\n    // 'negate' will alow the rect to have negative width/height\n    // 'reposition' will keep the width/height positive by swapping\n    // the top and bottom edges and/or swapping the left and right edges\n    invert: 'none',\n  },\n\n  checker: function (pointer, event, interactable, element, interaction, rect) {\n    if (!rect) { return null; }\n\n    const page = utils.extend({}, interaction.curCoords.page);\n    const options = interactable.options;\n\n    if (options.resize.enabled) {\n      const resizeOptions = options.resize;\n      const resizeEdges = { left: false, right: false, top: false, bottom: false };\n\n      // if using resize.edges\n      if (utils.is.object(resizeOptions.edges)) {\n        for (const edge in resizeEdges) {\n          resizeEdges[edge] = checkResizeEdge(edge,\n                                              resizeOptions.edges[edge],\n                                              page,\n                                              interaction._eventTarget,\n                                              element,\n                                              rect,\n                                              resizeOptions.margin || defaultMargin);\n        }\n\n        resizeEdges.left = resizeEdges.left && !resizeEdges.right;\n        resizeEdges.top  = resizeEdges.top  && !resizeEdges.bottom;\n\n        if (resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom) {\n          return {\n            name: 'resize',\n            edges: resizeEdges,\n          };\n        }\n      }\n      else {\n        const right  = options.resize.axis !== 'y' && page.x > (rect.right  - defaultMargin);\n        const bottom = options.resize.axis !== 'x' && page.y > (rect.bottom - defaultMargin);\n\n        if (right || bottom) {\n          return {\n            name: 'resize',\n            axes: (right? 'x' : '') + (bottom? 'y' : ''),\n          };\n        }\n      }\n    }\n\n    return null;\n  },\n\n  cursors: (browser.isIe9 ? {\n    x : 'e-resize',\n    y : 's-resize',\n    xy: 'se-resize',\n\n    top        : 'n-resize',\n    left       : 'w-resize',\n    bottom     : 's-resize',\n    right      : 'e-resize',\n    topleft    : 'se-resize',\n    bottomright: 'se-resize',\n    topright   : 'ne-resize',\n    bottomleft : 'ne-resize',\n  } : {\n    x : 'ew-resize',\n    y : 'ns-resize',\n    xy: 'nwse-resize',\n\n    top        : 'ns-resize',\n    left       : 'ew-resize',\n    bottom     : 'ns-resize',\n    right      : 'ew-resize',\n    topleft    : 'nwse-resize',\n    bottomright: 'nwse-resize',\n    topright   : 'nesw-resize',\n    bottomleft : 'nesw-resize',\n  }),\n\n  getCursor: function (action) {\n    if (action.axis) {\n      return resize.cursors[action.name + action.axis];\n    }\n    else if (action.edges) {\n      let cursorKey = '';\n      const edgeNames = ['top', 'bottom', 'left', 'right'];\n\n      for (let i = 0; i < 4; i++) {\n        if (action.edges[edgeNames[i]]) {\n          cursorKey += edgeNames[i];\n        }\n      }\n\n      return resize.cursors[cursorKey];\n    }\n  },\n};\n\n// resizestart\nInteractEvent.signals.on('new', function ({ iEvent, interaction }) {\n  if (iEvent.type !== 'resizestart' || !interaction.prepared.edges) {\n    return;\n  }\n\n  const startRect = interaction.target.getRect(interaction.element);\n  const resizeOptions = interaction.target.options.resize;\n\n  /*\n   * When using the `resizable.square` or `resizable.preserveAspectRatio` options, resizing from one edge\n   * will affect another. E.g. with `resizable.square`, resizing to make the right edge larger will make\n   * the bottom edge larger by the same amount. We call these 'linked' edges. Any linked edges will depend\n   * on the active edges and the edge being interacted with.\n   */\n  if (resizeOptions.square || resizeOptions.preserveAspectRatio) {\n    const linkedEdges = utils.extend({}, interaction.prepared.edges);\n\n    linkedEdges.top    = linkedEdges.top    || (linkedEdges.left   && !linkedEdges.bottom);\n    linkedEdges.left   = linkedEdges.left   || (linkedEdges.top    && !linkedEdges.right );\n    linkedEdges.bottom = linkedEdges.bottom || (linkedEdges.right  && !linkedEdges.top   );\n    linkedEdges.right  = linkedEdges.right  || (linkedEdges.bottom && !linkedEdges.left  );\n\n    interaction.prepared._linkedEdges = linkedEdges;\n  }\n  else {\n    interaction.prepared._linkedEdges = null;\n  }\n\n  // if using `resizable.preserveAspectRatio` option, record aspect ratio at the start of the resize\n  if (resizeOptions.preserveAspectRatio) {\n    interaction.resizeStartAspectRatio = startRect.width / startRect.height;\n  }\n\n  interaction.resizeRects = {\n    start     : startRect,\n    current   : utils.extend({}, startRect),\n    inverted  : utils.extend({}, startRect),\n    previous  : utils.extend({}, startRect),\n    delta     : {\n      left: 0, right : 0, width : 0,\n      top : 0, bottom: 0, height: 0,\n    },\n  };\n\n  iEvent.rect = interaction.resizeRects.inverted;\n  iEvent.deltaRect = interaction.resizeRects.delta;\n});\n\n// resizemove\nInteractEvent.signals.on('new', function ({ iEvent, phase, interaction }) {\n  if (phase !== 'move' || !interaction.prepared.edges) { return; }\n\n  const resizeOptions = interaction.target.options.resize;\n  const invert = resizeOptions.invert;\n  const invertible = invert === 'reposition' || invert === 'negate';\n\n  let edges = interaction.prepared.edges;\n\n  const start      = interaction.resizeRects.start;\n  const current    = interaction.resizeRects.current;\n  const inverted   = interaction.resizeRects.inverted;\n  const delta      = interaction.resizeRects.delta;\n  const previous   = utils.extend(interaction.resizeRects.previous, inverted);\n  const originalEdges = edges;\n\n  let dx = iEvent.dx;\n  let dy = iEvent.dy;\n\n  if (resizeOptions.preserveAspectRatio || resizeOptions.square) {\n    // `resize.preserveAspectRatio` takes precedence over `resize.square`\n    const startAspectRatio = resizeOptions.preserveAspectRatio\n      ? interaction.resizeStartAspectRatio\n      : 1;\n\n    edges = interaction.prepared._linkedEdges;\n\n    if ((originalEdges.left && originalEdges.bottom)\n        || (originalEdges.right && originalEdges.top)) {\n      dy = -dx / startAspectRatio;\n    }\n    else if (originalEdges.left || originalEdges.right ) { dy = dx / startAspectRatio; }\n    else if (originalEdges.top  || originalEdges.bottom) { dx = dy * startAspectRatio; }\n  }\n\n  // update the 'current' rect without modifications\n  if (edges.top   ) { current.top    += dy; }\n  if (edges.bottom) { current.bottom += dy; }\n  if (edges.left  ) { current.left   += dx; }\n  if (edges.right ) { current.right  += dx; }\n\n  if (invertible) {\n    // if invertible, copy the current rect\n    utils.extend(inverted, current);\n\n    if (invert === 'reposition') {\n      // swap edge values if necessary to keep width/height positive\n      let swap;\n\n      if (inverted.top > inverted.bottom) {\n        swap = inverted.top;\n\n        inverted.top = inverted.bottom;\n        inverted.bottom = swap;\n      }\n      if (inverted.left > inverted.right) {\n        swap = inverted.left;\n\n        inverted.left = inverted.right;\n        inverted.right = swap;\n      }\n    }\n  }\n  else {\n    // if not invertible, restrict to minimum of 0x0 rect\n    inverted.top    = Math.min(current.top, start.bottom);\n    inverted.bottom = Math.max(current.bottom, start.top);\n    inverted.left   = Math.min(current.left, start.right);\n    inverted.right  = Math.max(current.right, start.left);\n  }\n\n  inverted.width  = inverted.right  - inverted.left;\n  inverted.height = inverted.bottom - inverted.top ;\n\n  for (const edge in inverted) {\n    delta[edge] = inverted[edge] - previous[edge];\n  }\n\n  iEvent.edges = interaction.prepared.edges;\n  iEvent.rect = inverted;\n  iEvent.deltaRect = delta;\n});\n\n/**\n * ```js\n * interact(element).resizable({\n *   onstart: function (event) {},\n *   onmove : function (event) {},\n *   onend  : function (event) {},\n *\n *   edges: {\n *     top   : true,       // Use pointer coords to check for resize.\n *     left  : false,      // Disable resizing from left edge.\n *     bottom: '.resize-s',// Resize if pointer target matches selector\n *     right : handleEl    // Resize if pointer target is the given Element\n *   },\n *\n *     // Width and height can be adjusted independently. When `true`, width and\n *     // height are adjusted at a 1:1 ratio.\n *     square: false,\n *\n *     // Width and height can be adjusted independently. When `true`, width and\n *     // height maintain the aspect ratio they had when resizing started.\n *     preserveAspectRatio: false,\n *\n *   // a value of 'none' will limit the resize rect to a minimum of 0x0\n *   // 'negate' will allow the rect to have negative width/height\n *   // 'reposition' will keep the width/height positive by swapping\n *   // the top and bottom edges and/or swapping the left and right edges\n *   invert: 'none' || 'negate' || 'reposition'\n *\n *   // limit multiple resizes.\n *   // See the explanation in the {@link Interactable.draggable} example\n *   max: Infinity,\n *   maxPerElement: 1,\n * });\n *\n * var isResizeable = interact(element).resizable();\n * ```\n *\n * Gets or sets whether resize actions can be performed on the target\n *\n * @param {boolean | object} [options] true/false or An object with event\n * listeners to be fired on resize events (object makes the Interactable\n * resizable)\n * @return {boolean | Interactable} A boolean indicating if this can be the\n * target of resize elements, or this Interactable\n */\nInteractable.prototype.resizable = function (options) {\n  if (utils.is.object(options)) {\n    this.options.resize.enabled = options.enabled === false? false: true;\n    this.setPerAction('resize', options);\n    this.setOnEvents('resize', options);\n\n    if (/^x$|^y$|^xy$/.test(options.axis)) {\n      this.options.resize.axis = options.axis;\n    }\n    else if (options.axis === null) {\n      this.options.resize.axis = defaultOptions.resize.axis;\n    }\n\n    if (utils.is.bool(options.preserveAspectRatio)) {\n      this.options.resize.preserveAspectRatio = options.preserveAspectRatio;\n    }\n    else if (utils.is.bool(options.square)) {\n      this.options.resize.square = options.square;\n    }\n\n    return this;\n  }\n  if (utils.is.bool(options)) {\n    this.options.resize.enabled = options;\n\n    if (!options) {\n      this.onresizestart = this.onresizestart = this.onresizeend = null;\n    }\n\n    return this;\n  }\n  return this.options.resize;\n};\n\nfunction checkResizeEdge (name, value, page, element, interactableElement, rect, margin) {\n  // false, '', undefined, null\n  if (!value) { return false; }\n\n  // true value, use pointer coords and element rect\n  if (value === true) {\n    // if dimensions are negative, \"switch\" edges\n    const width  = utils.is.number(rect.width )? rect.width  : rect.right  - rect.left;\n    const height = utils.is.number(rect.height)? rect.height : rect.bottom - rect.top ;\n\n    if (width < 0) {\n      if      (name === 'left' ) { name = 'right'; }\n      else if (name === 'right') { name = 'left' ; }\n    }\n    if (height < 0) {\n      if      (name === 'top'   ) { name = 'bottom'; }\n      else if (name === 'bottom') { name = 'top'   ; }\n    }\n\n    if (name === 'left'  ) { return page.x < ((width  >= 0? rect.left: rect.right ) + margin); }\n    if (name === 'top'   ) { return page.y < ((height >= 0? rect.top : rect.bottom) + margin); }\n\n    if (name === 'right' ) { return page.x > ((width  >= 0? rect.right : rect.left) - margin); }\n    if (name === 'bottom') { return page.y > ((height >= 0? rect.bottom: rect.top ) - margin); }\n  }\n\n  // the remaining checks require an element\n  if (!utils.is.element(element)) { return false; }\n\n  return utils.is.element(value)\n  // the value is an element to use as a resize handle\n    ? value === element\n    // otherwise check if element matches value as selector\n    : utils.matchesUpTo(element, value, interactableElement);\n}\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.resizeAxes = 'xy';\n});\n\nInteractEvent.signals.on('set-delta', function ({ interaction, iEvent, action }) {\n  if (action !== 'resize' || !interaction.resizeAxes) { return; }\n\n  const options = interaction.target.options;\n\n  if (options.resize.square) {\n    if (interaction.resizeAxes === 'y') {\n      iEvent.dx = iEvent.dy;\n    }\n    else {\n      iEvent.dy = iEvent.dx;\n    }\n    iEvent.axes = 'xy';\n  }\n  else {\n    iEvent.axes = interaction.resizeAxes;\n\n    if (interaction.resizeAxes === 'x') {\n      iEvent.dy = 0;\n    }\n    else if (interaction.resizeAxes === 'y') {\n      iEvent.dx = 0;\n    }\n  }\n});\n\nactions.resize = resize;\nactions.names.push('resize');\nutils.merge(Interactable.eventTypes, [\n  'resizestart',\n  'resizemove',\n  'resizeinertiastart',\n  'resizeinertiaresume',\n  'resizeend',\n]);\nactions.methodDict.resize = 'resizable';\n\ndefaultOptions.resize = resize.defaults;\n\nmodule.exports = resize;\n","const raf            = require('./utils/raf');\nconst getWindow      = require('./utils/window').getWindow;\nconst is             = require('./utils/is');\nconst domUtils       = require('./utils/domUtils');\nconst Interaction    = require('./Interaction');\nconst defaultOptions = require('./defaultOptions');\n\nconst autoScroll = {\n  defaults: {\n    enabled  : false,\n    container: null,     // the item that is scrolled (Window or HTMLElement)\n    margin   : 60,\n    speed    : 300,      // the scroll speed in pixels per second\n  },\n\n  interaction: null,\n  i: null,    // the handle returned by window.setInterval\n  x: 0, y: 0, // Direction each pulse is to scroll in\n\n  isScrolling: false,\n  prevTime: 0,\n\n  start: function (interaction) {\n    autoScroll.isScrolling = true;\n    raf.cancel(autoScroll.i);\n\n    autoScroll.interaction = interaction;\n    autoScroll.prevTime = new Date().getTime();\n    autoScroll.i = raf.request(autoScroll.scroll);\n  },\n\n  stop: function () {\n    autoScroll.isScrolling = false;\n    raf.cancel(autoScroll.i);\n  },\n\n  // scroll the window by the values in scroll.x/y\n  scroll: function () {\n    const options = autoScroll.interaction.target.options[autoScroll.interaction.prepared.name].autoScroll;\n    const container = options.container || getWindow(autoScroll.interaction.element);\n    const now = new Date().getTime();\n    // change in time in seconds\n    const dt = (now - autoScroll.prevTime) / 1000;\n    // displacement\n    const s = options.speed * dt;\n\n    if (s >= 1) {\n      if (is.window(container)) {\n        container.scrollBy(autoScroll.x * s, autoScroll.y * s);\n      }\n      else if (container) {\n        container.scrollLeft += autoScroll.x * s;\n        container.scrollTop  += autoScroll.y * s;\n      }\n\n      autoScroll.prevTime = now;\n    }\n\n    if (autoScroll.isScrolling) {\n      raf.cancel(autoScroll.i);\n      autoScroll.i = raf.request(autoScroll.scroll);\n    }\n  },\n  check: function (interactable, actionName) {\n    const options = interactable.options;\n\n    return options[actionName].autoScroll && options[actionName].autoScroll.enabled;\n  },\n  onInteractionMove: function ({ interaction, pointer }) {\n    if (!(interaction.interacting()\n          && autoScroll.check(interaction.target, interaction.prepared.name))) {\n      return;\n    }\n\n    if (interaction.simulation) {\n      autoScroll.x = autoScroll.y = 0;\n      return;\n    }\n\n    let top;\n    let right;\n    let bottom;\n    let left;\n\n    const options = interaction.target.options[interaction.prepared.name].autoScroll;\n    const container = options.container || getWindow(interaction.element);\n\n    if (is.window(container)) {\n      left   = pointer.clientX < autoScroll.margin;\n      top    = pointer.clientY < autoScroll.margin;\n      right  = pointer.clientX > container.innerWidth  - autoScroll.margin;\n      bottom = pointer.clientY > container.innerHeight - autoScroll.margin;\n    }\n    else {\n      const rect = domUtils.getElementClientRect(container);\n\n      left   = pointer.clientX < rect.left   + autoScroll.margin;\n      top    = pointer.clientY < rect.top    + autoScroll.margin;\n      right  = pointer.clientX > rect.right  - autoScroll.margin;\n      bottom = pointer.clientY > rect.bottom - autoScroll.margin;\n    }\n\n    autoScroll.x = (right ? 1: left? -1: 0);\n    autoScroll.y = (bottom? 1:  top? -1: 0);\n\n    if (!autoScroll.isScrolling) {\n      // set the autoScroll properties to those of the target\n      autoScroll.margin = options.margin;\n      autoScroll.speed  = options.speed;\n\n      autoScroll.start(interaction);\n    }\n  },\n};\n\nInteraction.signals.on('stop-active', function () {\n  autoScroll.stop();\n});\n\nInteraction.signals.on('action-move', autoScroll.onInteractionMove);\n\ndefaultOptions.perAction.autoScroll = autoScroll.defaults;\n\nmodule.exports = autoScroll;\n","/** @lends Interactable */\nconst Interactable = require('../Interactable');\nconst actions      = require('../actions/base');\nconst is           = require('../utils/is');\nconst domUtils     = require('../utils/domUtils');\n\nconst { warnOnce } = require('../utils');\n\nInteractable.prototype.getAction = function (pointer, event, interaction, element) {\n  const action = this.defaultActionChecker(pointer, event, interaction, element);\n\n  if (this.options.actionChecker) {\n    return this.options.actionChecker(pointer, event, action, this, element, interaction);\n  }\n\n  return action;\n};\n\n/**\n * ```js\n * interact(element, { ignoreFrom: document.getElementById('no-action') });\n * // or\n * interact(element).ignoreFrom('input, textarea, a');\n * ```\n * @deprecated\n * If the target of the `mousedown`, `pointerdown` or `touchstart` event or any\n * of it's parents match the given CSS selector or Element, no\n * drag/resize/gesture is started.\n *\n * Don't use this method. Instead set the `ignoreFrom` option for each action\n * or for `pointerEvents`\n *\n * @example\n * interact(targett)\n *   .draggable({\n *     ignoreFrom: 'input, textarea, a[href]'',\n *   })\n *   .pointerEvents({\n *     ignoreFrom: '[no-pointer]',\n *   });\n *\n * @param {string | Element | null} [newValue] a CSS selector string, an\n * Element or `null` to not ignore any elements\n * @return {string | Element | object} The current ignoreFrom value or this\n * Interactable\n */\nInteractable.prototype.ignoreFrom = warnOnce(function (newValue) {\n  return this._backCompatOption('ignoreFrom', newValue);\n}, 'Interactable.ignoreForm() has been deprecated. Use Interactble.draggable({ignoreFrom: newValue}).');\n\n/**\n * ```js\n *\n * @deprecated\n * A drag/resize/gesture is started only If the target of the `mousedown`,\n * `pointerdown` or `touchstart` event or any of it's parents match the given\n * CSS selector or Element.\n *\n * Don't use this method. Instead set the `allowFrom` option for each action\n * or for `pointerEvents`\n *\n * @example\n * interact(targett)\n *   .resizable({\n *     allowFrom: '.resize-handle',\n *   .pointerEvents({\n *     allowFrom: '.handle',,\n *   });\n *\n * @param {string | Element | null} [newValue] a CSS selector string, an\n * Element or `null` to allow from any element\n * @return {string | Element | object} The current allowFrom value or this\n * Interactable\n */\nInteractable.prototype.allowFrom = warnOnce(function (newValue) {\n  return this._backCompatOption('allowFrom', newValue);\n}, 'Interactable.allowForm() has been deprecated. Use Interactble.draggable({allowFrom: newValue}).');\n\nInteractable.prototype.testIgnore = function (ignoreFrom, interactableElement, element) {\n  if (!ignoreFrom || !is.element(element)) { return false; }\n\n  if (is.string(ignoreFrom)) {\n    return domUtils.matchesUpTo(element, ignoreFrom, interactableElement);\n  }\n  else if (is.element(ignoreFrom)) {\n    return domUtils.nodeContains(ignoreFrom, element);\n  }\n\n  return false;\n};\n\nInteractable.prototype.testAllow = function (allowFrom, interactableElement, element) {\n  if (!allowFrom) { return true; }\n\n  if (!is.element(element)) { return false; }\n\n  if (is.string(allowFrom)) {\n    return domUtils.matchesUpTo(element, allowFrom, interactableElement);\n  }\n  else if (is.element(allowFrom)) {\n    return domUtils.nodeContains(allowFrom, element);\n  }\n\n  return false;\n};\n\nInteractable.prototype.testIgnoreAllow = function (options, interactableElement, eventTarget) {\n  return (!this.testIgnore(options.ignoreFrom, interactableElement, eventTarget)\n    && this.testAllow(options.allowFrom, interactableElement, eventTarget));\n};\n\n/**\n * ```js\n * interact('.resize-drag')\n *   .resizable(true)\n *   .draggable(true)\n *   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\n *\n *   if (interact.matchesSelector(event.target, '.drag-handle') {\n *     // force drag with handle target\n *     action.name = drag;\n *   }\n *   else {\n *     // resize from the top and right edges\n *     action.name  = 'resize';\n *     action.edges = { top: true, right: true };\n *   }\n *\n *   return action;\n * });\n * ```\n *\n * Gets or sets the function used to check action to be performed on\n * pointerDown\n *\n * @param {function | null} [checker] A function which takes a pointer event,\n * defaultAction string, interactable, element and interaction as parameters\n * and returns an object with name property 'drag' 'resize' or 'gesture' and\n * optionally an `edges` object with boolean 'top', 'left', 'bottom' and right\n * props.\n * @return {Function | Interactable} The checker function or this Interactable\n */\nInteractable.prototype.actionChecker = function (checker) {\n  if (is.function(checker)) {\n    this.options.actionChecker = checker;\n\n    return this;\n  }\n\n  if (checker === null) {\n    delete this.options.actionChecker;\n\n    return this;\n  }\n\n  return this.options.actionChecker;\n};\n\n/**\n * Returns or sets whether the the cursor should be changed depending on the\n * action that would be performed if the mouse were pressed and dragged.\n *\n * @param {boolean} [newValue]\n * @return {boolean | Interactable} The current setting or this Interactable\n */\nInteractable.prototype.styleCursor = function (newValue) {\n  if (is.bool(newValue)) {\n    this.options.styleCursor = newValue;\n\n    return this;\n  }\n\n  if (newValue === null) {\n    delete this.options.styleCursor;\n\n    return this;\n  }\n\n  return this.options.styleCursor;\n};\n\nInteractable.prototype.defaultActionChecker = function (pointer, event, interaction, element) {\n  const rect = this.getRect(element);\n  const buttons = event.buttons || ({\n    0: 1,\n    1: 4,\n    3: 8,\n    4: 16,\n  })[event.button];\n  let action = null;\n\n  for (const actionName of actions.names) {\n    // check mouseButton setting if the pointer is down\n    if (interaction.pointerIsDown\n        && /mouse|pointer/.test(interaction.pointerType)\n        && (buttons & this.options[actionName].mouseButtons) === 0) {\n      continue;\n    }\n\n    action = actions[actionName].checker(pointer, event, this, element, interaction, rect);\n\n    if (action) {\n      return action;\n    }\n  }\n};\n\n","const interact       = require('../interact');\nconst Interactable   = require('../Interactable');\nconst Interaction    = require('../Interaction');\nconst actions        = require('../actions/base');\nconst defaultOptions = require('../defaultOptions');\nconst scope          = require('../scope');\nconst utils          = require('../utils');\nconst signals        = require('../utils/Signals').new();\n\nrequire('./InteractableMethods');\n\nconst autoStart = {\n  signals,\n  withinInteractionLimit,\n  // Allow this many interactions to happen simultaneously\n  maxInteractions: Infinity,\n  defaults: {\n    perAction: {\n      manualStart: false,\n      max: Infinity,\n      maxPerElement: 1,\n      allowFrom:  null,\n      ignoreFrom: null,\n\n      // only allow left button by default\n      // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value\n      mouseButtons: 1,\n    },\n  },\n  setActionDefaults: function (action) {\n    utils.extend(action.defaults, autoStart.defaults.perAction);\n  },\n  validateAction,\n};\n\n// set cursor style on mousedown\nInteraction.signals.on('down', function ({ interaction, pointer, event, eventTarget }) {\n  if (interaction.interacting()) { return; }\n\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget);\n  prepare(interaction, actionInfo);\n});\n\n// set cursor style on mousemove\nInteraction.signals.on('move', function ({ interaction, pointer, event, eventTarget }) {\n  if (interaction.pointerType !== 'mouse'\n      || interaction.pointerIsDown\n      || interaction.interacting()) { return; }\n\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget);\n  prepare(interaction, actionInfo);\n});\n\nInteraction.signals.on('move', function (arg) {\n  const { interaction, event } = arg;\n\n  if (!interaction.pointerIsDown\n      || interaction.interacting()\n      || !interaction.pointerWasMoved\n      || !interaction.prepared.name) {\n    return;\n  }\n\n  signals.fire('before-start', arg);\n\n  const target = interaction.target;\n\n  if (interaction.prepared.name && target) {\n    // check manualStart and interaction limit\n    if (target.options[interaction.prepared.name].manualStart\n        || !withinInteractionLimit(target, interaction.element, interaction.prepared)) {\n      interaction.stop(event);\n    }\n    else {\n      interaction.start(interaction.prepared, target, interaction.element);\n    }\n  }\n});\n\n// Check if the current target supports the action.\n// If so, return the validated action. Otherwise, return null\nfunction validateAction (action, interactable, element, eventTarget) {\n  if (utils.is.object(action)\n      && interactable.testIgnoreAllow(interactable.options[action.name], element, eventTarget)\n      && interactable.options[action.name].enabled\n      && withinInteractionLimit(interactable, element, action)) {\n    return action;\n  }\n\n  return null;\n}\n\nfunction validateSelector (interaction, pointer, event, matches, matchElements, eventTarget) {\n  for (let i = 0, len = matches.length; i < len; i++) {\n    const match = matches[i];\n    const matchElement = matchElements[i];\n    const action = validateAction(match.getAction(pointer, event, interaction, matchElement),\n                                  match,\n                                  matchElement,\n                                  eventTarget);\n\n    if (action) {\n      return {\n        action,\n        target: match,\n        element: matchElement,\n      };\n    }\n  }\n\n  return {};\n}\n\nfunction getActionInfo (interaction, pointer, event, eventTarget) {\n  let matches = [];\n  let matchElements = [];\n\n  let element = eventTarget;\n\n  function pushMatches (interactable) {\n    matches.push(interactable);\n    matchElements.push(element);\n  }\n\n  while (utils.is.element(element)) {\n    matches = [];\n    matchElements = [];\n\n    scope.interactables.forEachMatch(element, pushMatches);\n\n    const actionInfo = validateSelector(interaction, pointer, event, matches, matchElements, eventTarget);\n\n    if (actionInfo.action\n      && !actionInfo.target.options[actionInfo.action.name].manualStart) {\n      return actionInfo;\n    }\n\n    element = utils.parentNode(element);\n  }\n\n  return {};\n}\n\nfunction prepare (interaction, { action, target, element }) {\n  action = action || {};\n\n  if (interaction.target && interaction.target.options.styleCursor) {\n    interaction.target._doc.documentElement.style.cursor = '';\n  }\n\n  interaction.target = target;\n  interaction.element = element;\n  utils.copyAction(interaction.prepared, action);\n\n  if (target && target.options.styleCursor) {\n    const cursor = action? actions[action.name].getCursor(action) : '';\n    interaction.target._doc.documentElement.style.cursor = cursor;\n  }\n\n  signals.fire('prepared', { interaction: interaction });\n}\n\nInteraction.signals.on('stop', function ({ interaction }) {\n  const target = interaction.target;\n\n  if (target && target.options.styleCursor) {\n    target._doc.documentElement.style.cursor = '';\n  }\n});\n\nfunction withinInteractionLimit (interactable, element, action) {\n  const options = interactable.options;\n  const maxActions = options[action.name].max;\n  const maxPerElement = options[action.name].maxPerElement;\n  let activeInteractions = 0;\n  let targetCount = 0;\n  let targetElementCount = 0;\n\n  // no actions if any of these values == 0\n  if (!(maxActions && maxPerElement && autoStart.maxInteractions)) { return; }\n\n  for (const interaction of scope.interactions) {\n    const otherAction = interaction.prepared.name;\n\n    if (!interaction.interacting()) { continue; }\n\n    activeInteractions++;\n\n    if (activeInteractions >= autoStart.maxInteractions) {\n      return false;\n    }\n\n    if (interaction.target !== interactable) { continue; }\n\n    targetCount += (otherAction === action.name)|0;\n\n    if (targetCount >= maxActions) {\n      return false;\n    }\n\n    if (interaction.element === element) {\n      targetElementCount++;\n\n      if (otherAction !== action.name || targetElementCount >= maxPerElement) {\n        return false;\n      }\n    }\n  }\n\n  return autoStart.maxInteractions > 0;\n}\n\n/**\n * Returns or sets the maximum number of concurrent interactions allowed.  By\n * default only 1 interaction is allowed at a time (for backwards\n * compatibility). To allow multiple interactions on the same Interactables and\n * elements, you need to enable it in the draggable, resizable and gesturable\n * `'max'` and `'maxPerElement'` options.\n *\n * @alias module:interact.maxInteractions\n *\n * @param {number} [newValue] Any number. newValue <= 0 means no interactions.\n */\ninteract.maxInteractions = function (newValue) {\n  if (utils.is.number(newValue)) {\n    autoStart.maxInteractions = newValue;\n\n    return interact;\n  }\n\n  return autoStart.maxInteractions;\n};\n\nInteractable.settingsMethods.push('styleCursor');\nInteractable.settingsMethods.push('actionChecker');\nInteractable.settingsMethods.push('ignoreFrom');\nInteractable.settingsMethods.push('allowFrom');\n\ndefaultOptions.base.actionChecker = null;\ndefaultOptions.base.styleCursor = true;\n\nutils.extend(defaultOptions.perAction, autoStart.defaults.perAction);\n\nmodule.exports = autoStart;\n","const autoStart = require('./base');\nconst scope     = require('../scope');\nconst is        = require('../utils/is');\n\nconst { parentNode } = require('../utils/domUtils');\n\nautoStart.setActionDefaults(require('../actions/drag'));\n\nautoStart.signals.on('before-start',  function ({ interaction, eventTarget, dx, dy }) {\n  if (interaction.prepared.name !== 'drag') { return; }\n\n  // check if a drag is in the correct axis\n  const absX = Math.abs(dx);\n  const absY = Math.abs(dy);\n  const targetOptions = interaction.target.options.drag;\n  const startAxis = targetOptions.startAxis;\n  const currentAxis = (absX > absY ? 'x' : absX < absY ? 'y' : 'xy');\n\n  interaction.prepared.axis = targetOptions.lockAxis === 'start'\n    ? currentAxis[0] // always lock to one axis even if currentAxis === 'xy'\n    : targetOptions.lockAxis;\n\n  // if the movement isn't in the startAxis of the interactable\n  if (currentAxis !== 'xy' && startAxis !== 'xy' && startAxis !== currentAxis) {\n    // cancel the prepared action\n    interaction.prepared.name = null;\n\n    // then try to get a drag from another ineractable\n    let element = eventTarget;\n\n    const getDraggable = function (interactable) {\n      if (interactable === interaction.target) { return; }\n\n      const options = interaction.target.options.drag;\n\n      if (!options.manualStart\n          && interactable.testIgnoreAllow(options, element, eventTarget)) {\n\n        const action = interactable.getAction(\n          interaction.downPointer, interaction.downEvent, interaction, element);\n\n        if (action\n            && action.name === 'drag'\n            && checkStartAxis(currentAxis, interactable)\n            && autoStart.validateAction(action, interactable, element, eventTarget)) {\n\n          return interactable;\n        }\n      }\n    };\n\n    // check all interactables\n    while (is.element(element)) {\n      const interactable = scope.interactables.forEachMatch(element, getDraggable);\n\n      if (interactable) {\n        interaction.prepared.name = 'drag';\n        interaction.target = interactable;\n        interaction.element = element;\n        break;\n      }\n\n      element = parentNode(element);\n    }\n  }\n});\n\nfunction checkStartAxis (startAxis, interactable) {\n  if (!interactable) { return false; }\n\n  const thisAxis = interactable.options.drag.startAxis;\n\n  return (startAxis === 'xy' || thisAxis === 'xy' || thisAxis === startAxis);\n}\n","require('./base').setActionDefaults(require('../actions/gesture'));\n","const autoStart   = require('./base');\nconst Interaction = require('../Interaction');\n\nautoStart.defaults.perAction.hold = 0;\nautoStart.defaults.perAction.delay = 0;\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.autoStartHoldTimer = null;\n});\n\nautoStart.signals.on('prepared', function ({ interaction }) {\n  const hold = getHoldDuration(interaction);\n\n  if (hold > 0) {\n    interaction.autoStartHoldTimer = setTimeout(() => {\n      interaction.start(interaction.prepared, interaction.target, interaction.element);\n    }, hold);\n  }\n});\n\nInteraction.signals.on('move', function ({ interaction, duplicate }) {\n  if (interaction.pointerWasMoved && !duplicate) {\n    clearTimeout(interaction.autoStartHoldTimer);\n  }\n});\n\n// prevent regular down->move autoStart\nautoStart.signals.on('before-start', function ({ interaction }) {\n  const hold = getHoldDuration(interaction);\n\n  if (hold > 0) {\n    interaction.prepared.name = null;\n  }\n});\n\nfunction getHoldDuration (interaction) {\n  const actionName = interaction.prepared && interaction.prepared.name;\n\n  if (!actionName) { return null; }\n\n  const options = interaction.target.options;\n\n  return options[actionName].hold || options[actionName].delay;\n}\n\nmodule.exports = {\n  getHoldDuration,\n};\n","require('./base').setActionDefaults(require('../actions/resize'));\n","module.exports = {\n  base: {\n    accept        : null,\n    preventDefault: 'auto',\n    deltaSource   : 'page',\n  },\n\n  perAction: {\n    origin: { x: 0, y: 0 },\n\n    inertia: {\n      enabled          : false,\n      resistance       : 10,    // the lambda in exponential decay\n      minSpeed         : 100,   // target speed must be above this for inertia to start\n      endSpeed         : 10,    // the speed at which inertia is slow enough to stop\n      allowResume      : true,  // allow resuming an action in inertia phase\n      smoothEndDuration: 300,   // animate to snap/restrict endOnly if there's no inertia\n    },\n  },\n};\n","/* browser entry point */\n\n// inertia\nrequire('./inertia');\n\n// modifiers\nrequire('./modifiers/snap');\nrequire('./modifiers/restrict');\n\n// pointerEvents\nrequire('./pointerEvents/base');\nrequire('./pointerEvents/holdRepeat');\nrequire('./pointerEvents/interactableTargets');\n\n// autoStart hold\nrequire('./autoStart/hold');\n\n// actions\nrequire('./actions/gesture');\nrequire('./actions/resize');\nrequire('./actions/drag');\nrequire('./actions/drop');\n\n// load these modifiers after resize is loaded\nrequire('./modifiers/snapSize');\nrequire('./modifiers/restrictEdges');\nrequire('./modifiers/restrictSize');\n\n// autoStart actions\nrequire('./autoStart/gesture');\nrequire('./autoStart/resize');\nrequire('./autoStart/drag');\n\n// Interactable preventDefault setting\nrequire('./interactablePreventDefault.js');\n\n// autoScroll\nrequire('./autoScroll');\n\n// export interact\nmodule.exports = require('./interact');\n","const InteractEvent  = require('./InteractEvent');\nconst Interaction    = require('./Interaction');\nconst modifiers      = require('./modifiers/base');\nconst utils          = require('./utils');\nconst animationFrame = require('./utils/raf');\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.inertiaStatus = {\n    active     : false,\n    smoothEnd  : false,\n    allowResume: false,\n\n    startEvent: null,\n    upCoords  : {},\n\n    xe: 0, ye: 0,\n    sx: 0, sy: 0,\n\n    t0: 0,\n    vx0: 0, vys: 0,\n    duration: 0,\n\n    lambda_v0: 0,\n    one_ve_v0: 0,\n    i  : null,\n  };\n\n  interaction.boundInertiaFrame   = () => inertiaFrame  .apply(interaction);\n  interaction.boundSmoothEndFrame = () => smoothEndFrame.apply(interaction);\n});\n\nInteraction.signals.on('down', function ({ interaction, event, pointer, eventTarget }) {\n  const status = interaction.inertiaStatus;\n\n  // Check if the down event hits the current inertia target\n  if (status.active) {\n    let element = eventTarget;\n\n    // climb up the DOM tree from the event target\n    while (utils.is.element(element)) {\n\n      // if interaction element is the current inertia target element\n      if (element === interaction.element) {\n        // stop inertia\n        animationFrame.cancel(status.i);\n        status.active = false;\n        interaction.simulation = null;\n\n        // update pointers to the down event's coordinates\n        interaction.updatePointer(pointer);\n        utils.setCoords(interaction.curCoords, interaction.pointers);\n\n        // fire appropriate signals\n        const signalArg = { interaction };\n        Interaction.signals.fire('before-action-move', signalArg);\n        Interaction.signals.fire('action-resume'     , signalArg);\n\n        // fire a reume event\n        const resumeEvent = new InteractEvent(interaction,\n                                              event,\n                                              interaction.prepared.name,\n                                              'inertiaresume',\n                                              interaction.element);\n\n        interaction.target.fire(resumeEvent);\n        interaction.prevEvent = resumeEvent;\n        modifiers.resetStatuses(interaction.modifierStatuses);\n\n        utils.copyCoords(interaction.prevCoords, interaction.curCoords);\n        break;\n      }\n\n      element = utils.parentNode(element);\n    }\n  }\n});\n\nInteraction.signals.on('up', function ({ interaction, event }) {\n  const status = interaction.inertiaStatus;\n\n  if (!interaction.interacting() || status.active) { return; }\n\n  const target = interaction.target;\n  const options = target && target.options;\n  const inertiaOptions = options && interaction.prepared.name && options[interaction.prepared.name].inertia;\n\n  const now = new Date().getTime();\n  const statuses = {};\n  const page = utils.extend({}, interaction.curCoords.page);\n  const pointerSpeed = interaction.pointerDelta.client.speed;\n\n  let smoothEnd = false;\n  let modifierResult;\n\n  // check if inertia should be started\n  const inertiaPossible = (inertiaOptions && inertiaOptions.enabled\n                     && interaction.prepared.name !== 'gesture'\n                     && event !== status.startEvent);\n\n  const inertia = (inertiaPossible\n    && (now - interaction.curCoords.timeStamp) < 50\n    && pointerSpeed > inertiaOptions.minSpeed\n    && pointerSpeed > inertiaOptions.endSpeed);\n\n  const modifierArg = {\n    interaction,\n    pageCoords: page,\n    statuses,\n    preEnd: true,\n    requireEndOnly: true,\n  };\n\n  // smoothEnd\n  if (inertiaPossible && !inertia) {\n    modifiers.resetStatuses(statuses);\n\n    modifierResult = modifiers.setAll(modifierArg);\n\n    if (modifierResult.shouldMove && modifierResult.locked) {\n      smoothEnd = true;\n    }\n  }\n\n  if (!(inertia || smoothEnd)) { return; }\n\n  utils.copyCoords(status.upCoords, interaction.curCoords);\n\n  interaction.pointers[0] = status.startEvent =\n    new InteractEvent(interaction, event, interaction.prepared.name, 'inertiastart', interaction.element);\n\n  status.t0 = now;\n\n  status.active = true;\n  status.allowResume = inertiaOptions.allowResume;\n  interaction.simulation = status;\n\n  target.fire(status.startEvent);\n\n  if (inertia) {\n    status.vx0 = interaction.pointerDelta.client.vx;\n    status.vy0 = interaction.pointerDelta.client.vy;\n    status.v0 = pointerSpeed;\n\n    calcInertia(interaction, status);\n\n    utils.extend(page, interaction.curCoords.page);\n\n    page.x += status.xe;\n    page.y += status.ye;\n\n    modifiers.resetStatuses(statuses);\n\n    modifierResult = modifiers.setAll(modifierArg);\n\n    status.modifiedXe += modifierResult.dx;\n    status.modifiedYe += modifierResult.dy;\n\n    status.i = animationFrame.request(interaction.boundInertiaFrame);\n  }\n  else {\n    status.smoothEnd = true;\n    status.xe = modifierResult.dx;\n    status.ye = modifierResult.dy;\n\n    status.sx = status.sy = 0;\n\n    status.i = animationFrame.request(interaction.boundSmoothEndFrame);\n  }\n});\n\nInteraction.signals.on('stop-active', function ({ interaction }) {\n  const status = interaction.inertiaStatus;\n\n  if (status.active) {\n    animationFrame.cancel(status.i);\n    status.active = false;\n    interaction.simulation = null;\n  }\n});\n\nfunction calcInertia (interaction, status) {\n  const inertiaOptions = interaction.target.options[interaction.prepared.name].inertia;\n  const lambda = inertiaOptions.resistance;\n  const inertiaDur = -Math.log(inertiaOptions.endSpeed / status.v0) / lambda;\n\n  status.x0 = interaction.prevEvent.pageX;\n  status.y0 = interaction.prevEvent.pageY;\n  status.t0 = status.startEvent.timeStamp / 1000;\n  status.sx = status.sy = 0;\n\n  status.modifiedXe = status.xe = (status.vx0 - inertiaDur) / lambda;\n  status.modifiedYe = status.ye = (status.vy0 - inertiaDur) / lambda;\n  status.te = inertiaDur;\n\n  status.lambda_v0 = lambda / status.v0;\n  status.one_ve_v0 = 1 - inertiaOptions.endSpeed / status.v0;\n}\n\nfunction inertiaFrame () {\n  updateInertiaCoords(this);\n  utils.setCoordDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n\n  const status = this.inertiaStatus;\n  const options = this.target.options[this.prepared.name].inertia;\n  const lambda = options.resistance;\n  const t = new Date().getTime() / 1000 - status.t0;\n\n  if (t < status.te) {\n\n    const progress =  1 - (Math.exp(-lambda * t) - status.lambda_v0) / status.one_ve_v0;\n\n    if (status.modifiedXe === status.xe && status.modifiedYe === status.ye) {\n      status.sx = status.xe * progress;\n      status.sy = status.ye * progress;\n    }\n    else {\n      const quadPoint = utils.getQuadraticCurvePoint(0, 0,\n                                                     status.xe,\n                                                     status.ye,\n                                                     status.modifiedXe,\n                                                     status.modifiedYe,\n                                                     progress);\n\n      status.sx = quadPoint.x;\n      status.sy = quadPoint.y;\n    }\n\n    this.doMove();\n\n    status.i = animationFrame.request(this.boundInertiaFrame);\n  }\n  else {\n    status.sx = status.modifiedXe;\n    status.sy = status.modifiedYe;\n\n    this.doMove();\n    this.end(status.startEvent);\n    status.active = false;\n    this.simulation = null;\n  }\n\n  utils.copyCoords(this.prevCoords, this.curCoords);\n}\n\nfunction smoothEndFrame () {\n  updateInertiaCoords(this);\n\n  const status = this.inertiaStatus;\n  const t = new Date().getTime() - status.t0;\n  const duration = this.target.options[this.prepared.name].inertia.smoothEndDuration;\n\n  if (t < duration) {\n    status.sx = utils.easeOutQuad(t, 0, status.xe, duration);\n    status.sy = utils.easeOutQuad(t, 0, status.ye, duration);\n\n    this.pointerMove(status.startEvent, status.startEvent);\n\n    status.i = animationFrame.request(this.boundSmoothEndFrame);\n  }\n  else {\n    status.sx = status.xe;\n    status.sy = status.ye;\n\n    this.pointerMove(status.startEvent, status.startEvent);\n    this.end(status.startEvent);\n\n    status.smoothEnd =\n      status.active = false;\n    this.simulation = null;\n  }\n}\n\nfunction updateInertiaCoords (interaction) {\n  const status = interaction.inertiaStatus;\n\n  // return if inertia isn't running\n  if (!status.active) { return; }\n\n  const pageUp   = status.upCoords.page;\n  const clientUp = status.upCoords.client;\n\n  utils.setCoords(interaction.curCoords, [ {\n    pageX  : pageUp.x   + status.sx,\n    pageY  : pageUp.y   + status.sy,\n    clientX: clientUp.x + status.sx,\n    clientY: clientUp.y + status.sy,\n  } ]);\n}\n","/** @module interact */\n\nconst browser      = require('./utils/browser');\nconst events       = require('./utils/events');\nconst utils        = require('./utils');\nconst scope        = require('./scope');\nconst Interactable = require('./Interactable');\nconst Interaction  = require('./Interaction');\n\nconst globalEvents = {};\n\n/**\n * ```js\n * interact('#draggable').draggable(true);\n *\n * var rectables = interact('rect');\n * rectables\n *   .gesturable(true)\n *   .on('gesturemove', function (event) {\n *       // ...\n *   });\n * ```\n *\n * The methods of this variable can be used to set elements as interactables\n * and also to change various default settings.\n *\n * Calling it as a function and passing an element or a valid CSS selector\n * string returns an Interactable object which has various methods to configure\n * it.\n *\n * @global\n *\n * @param {Element | string} element The HTML or SVG Element to interact with\n * or CSS selector\n * @return {Interactable}\n */\nfunction interact (element, options) {\n  let interactable = scope.interactables.get(element, options);\n\n  if (!interactable) {\n    interactable = new Interactable(element, options);\n    interactable.events.global = globalEvents;\n  }\n\n  return interactable;\n}\n\n/**\n * Check if an element or selector has been set with the {@link interact}\n * function\n *\n * @alias module:interact.isSet\n *\n * @param {Element} element The Element being searched for\n * @return {boolean} Indicates if the element or CSS selector was previously\n * passed to interact\n*/\ninteract.isSet = function (element, options) {\n  return scope.interactables.indexOfElement(element, options && options.context) !== -1;\n};\n\n/**\n * Add a global listener for an InteractEvent or adds a DOM event to `document`\n *\n * @alias module:interact.on\n *\n * @param {string | array | object} type The types of events to listen for\n * @param {function} listener The function event (s)\n * @param {object | boolean} [options] object or useCapture flag for\n * addEventListener\n * @return {object} interact\n */\ninteract.on = function (type, listener, options) {\n  if (utils.is.string(type) && type.search(' ') !== -1) {\n    type = type.trim().split(/ +/);\n  }\n\n  if (utils.is.array(type)) {\n    for (const eventType of type) {\n      interact.on(eventType, listener, options);\n    }\n\n    return interact;\n  }\n\n  if (utils.is.object(type)) {\n    for (const prop in type) {\n      interact.on(prop, type[prop], listener);\n    }\n\n    return interact;\n  }\n\n  // if it is an InteractEvent type, add listener to globalEvents\n  if (utils.contains(Interactable.eventTypes, type)) {\n    // if this type of event was never bound\n    if (!globalEvents[type]) {\n      globalEvents[type] = [listener];\n    }\n    else {\n      globalEvents[type].push(listener);\n    }\n  }\n  // If non InteractEvent type, addEventListener to document\n  else {\n    events.add(scope.document, type, listener, { options });\n  }\n\n  return interact;\n};\n\n/**\n * Removes a global InteractEvent listener or DOM event from `document`\n *\n * @alias module:interact.off\n *\n * @param {string | array | object} type The types of events that were listened\n * for\n * @param {function} listener The listener function to be removed\n * @param {object | boolean} options [options] object or useCapture flag for\n * removeEventListener\n * @return {object} interact\n */\ninteract.off = function (type, listener, options) {\n  if (utils.is.string(type) && type.search(' ') !== -1) {\n    type = type.trim().split(/ +/);\n  }\n\n  if (utils.is.array(type)) {\n    for (const eventType of type) {\n      interact.off(eventType, listener, options);\n    }\n\n    return interact;\n  }\n\n  if (utils.is.object(type)) {\n    for (const prop in type) {\n      interact.off(prop, type[prop], listener);\n    }\n\n    return interact;\n  }\n\n  if (!utils.contains(Interactable.eventTypes, type)) {\n    events.remove(scope.document, type, listener, options);\n  }\n  else {\n    let index;\n\n    if (type in globalEvents\n        && (index = globalEvents[type].indexOf(listener)) !== -1) {\n      globalEvents[type].splice(index, 1);\n    }\n  }\n\n  return interact;\n};\n\n/**\n * Returns an object which exposes internal data\n\n * @alias module:interact.debug\n *\n * @return {object} An object with properties that outline the current state\n * and expose internal functions and variables\n */\ninteract.debug = function () {\n  return scope;\n};\n\n// expose the functions used to calculate multi-touch properties\ninteract.getPointerAverage  = utils.pointerAverage;\ninteract.getTouchBBox       = utils.touchBBox;\ninteract.getTouchDistance   = utils.touchDistance;\ninteract.getTouchAngle      = utils.touchAngle;\n\ninteract.getElementRect       = utils.getElementRect;\ninteract.getElementClientRect = utils.getElementClientRect;\ninteract.matchesSelector      = utils.matchesSelector;\ninteract.closest              = utils.closest;\n\n/**\n * @alias module:interact.supportsTouch\n *\n * @return {boolean} Whether or not the browser supports touch input\n */\ninteract.supportsTouch = function () {\n  return browser.supportsTouch;\n};\n\n/**\n * @alias module:interact.supportsPointerEvent\n *\n * @return {boolean} Whether or not the browser supports PointerEvents\n */\ninteract.supportsPointerEvent = function () {\n  return browser.supportsPointerEvent;\n};\n\n/**\n * Cancels all interactions (end events are not fired)\n *\n * @alias module:interact.stop\n *\n * @param {Event} event An event on which to call preventDefault()\n * @return {object} interact\n */\ninteract.stop = function (event) {\n  for (let i = scope.interactions.length - 1; i >= 0; i--) {\n    scope.interactions[i].stop(event);\n  }\n\n  return interact;\n};\n\n/**\n * Returns or sets the distance the pointer must be moved before an action\n * sequence occurs. This also affects tolerance for tap events.\n *\n * @alias module:interact.pointerMoveTolerance\n *\n * @param {number} [newValue] The movement from the start position must be greater than this value\n * @return {interact | number}\n */\ninteract.pointerMoveTolerance = function (newValue) {\n  if (utils.is.number(newValue)) {\n    Interaction.pointerMoveTolerance = newValue;\n\n    return interact;\n  }\n\n  return Interaction.pointerMoveTolerance;\n};\n\ninteract.addDocument    = scope.addDocument;\ninteract.removeDocument = scope.removeDocument;\n\nscope.interact = interact;\n\nmodule.exports = interact;\n","const Interactable = require('./Interactable');\nconst Interaction  = require('./Interaction');\nconst scope        = require('./scope');\nconst is           = require('./utils/is');\nconst events       = require('./utils/events');\nconst browser      = require('./utils/browser');\n\nconst { nodeContains, matchesSelector } = require('./utils/domUtils');\n\n/**\n * Returns or sets whether to prevent the browser's default behaviour in\n * response to pointer events. Can be set to:\n *  - `'always'` to always prevent\n *  - `'never'` to never prevent\n *  - `'auto'` to let interact.js try to determine what would be best\n *\n * @param {string} [newValue] `true`, `false` or `'auto'`\n * @return {string | Interactable} The current setting or this Interactable\n */\nInteractable.prototype.preventDefault = function (newValue) {\n  if (/^(always|never|auto)$/.test(newValue)) {\n    this.options.preventDefault = newValue;\n    return this;\n  }\n\n  if (is.bool(newValue)) {\n    this.options.preventDefault = newValue? 'always' : 'never';\n    return this;\n  }\n\n  return this.options.preventDefault;\n};\n\nInteractable.prototype.checkAndPreventDefault = function (event) {\n  const setting = this.options.preventDefault;\n\n  if (setting === 'never') { return; }\n\n  if (setting === 'always') {\n    event.preventDefault();\n    return;\n  }\n\n  // setting === 'auto'\n\n  // don't preventDefault of touch{start,move} events if the browser supports passive\n  // events listeners. CSS touch-action and user-selecct should be used instead\n  if (events.supportsPassive\n    && /^touch(start|move)$/.test(event.type)\n    && !browser.isIOS) {\n    return;\n  }\n\n  // don't preventDefault of pointerdown events\n  if (/^(mouse|pointer|touch)*(down|start)/i.test(event.type)) {\n    return;\n  }\n\n  // don't preventDefault on editable elements\n  if (is.element(event.target)\n      && matchesSelector(event.target, 'input,select,textarea,[contenteditable=true],[contenteditable=true] *')) {\n    return;\n  }\n\n  event.preventDefault();\n};\n\nfunction onInteractionEvent ({ interaction, event }) {\n  if (interaction.target) {\n    interaction.target.checkAndPreventDefault(event);\n  }\n}\n\nfor (const eventSignal of ['down', 'move', 'up', 'cancel']) {\n  Interaction.signals.on(eventSignal, onInteractionEvent);\n}\n\n// prevent native HTML5 drag on interact.js target elements\nInteraction.docEvents.dragstart = function preventNativeDrag (event) {\n  for (const interaction of scope.interactions) {\n\n    if (interaction.element\n        && (interaction.element === event.target\n            || nodeContains(interaction.element, event.target))) {\n\n      interaction.target.checkAndPreventDefault(event);\n      return;\n    }\n  }\n};\n","const InteractEvent = require('../InteractEvent');\nconst Interaction   = require('../Interaction');\nconst extend        = require('../utils/extend');\n\nconst modifiers = {\n  names: [],\n\n  setOffsets: function (arg) {\n    const { interaction, pageCoords: page } = arg;\n    const { target, element, startOffset } = interaction;\n    const rect = target.getRect(element);\n\n    if (rect) {\n      startOffset.left = page.x - rect.left;\n      startOffset.top  = page.y - rect.top;\n\n      startOffset.right  = rect.right  - page.x;\n      startOffset.bottom = rect.bottom - page.y;\n\n      if (!('width'  in rect)) { rect.width  = rect.right  - rect.left; }\n      if (!('height' in rect)) { rect.height = rect.bottom - rect.top ; }\n    }\n    else {\n      startOffset.left = startOffset.top = startOffset.right = startOffset.bottom = 0;\n    }\n\n    arg.rect = rect;\n    arg.interactable = target;\n    arg.element = element;\n\n    for (const modifierName of modifiers.names) {\n      arg.options = target.options[interaction.prepared.name][modifierName];\n\n      if (!arg.options) {\n        continue;\n      }\n\n      interaction.modifierOffsets[modifierName] = modifiers[modifierName].setOffset(arg);\n    }\n  },\n\n  setAll: function (arg) {\n    const { interaction, statuses, preEnd, requireEndOnly } = arg;\n    const result = {\n      dx: 0,\n      dy: 0,\n      changed: false,\n      locked: false,\n      shouldMove: true,\n    };\n\n    arg.modifiedCoords = extend({}, arg.pageCoords);\n\n    for (const modifierName of modifiers.names) {\n      const modifier = modifiers[modifierName];\n      const options = interaction.target.options[interaction.prepared.name][modifierName];\n\n      if (!shouldDo(options, preEnd, requireEndOnly)) { continue; }\n\n      arg.status = arg.status = statuses[modifierName];\n      arg.options = options;\n      arg.offset = arg.interaction.modifierOffsets[modifierName];\n\n      modifier.set(arg);\n\n      if (arg.status.locked) {\n        arg.modifiedCoords.x += arg.status.dx;\n        arg.modifiedCoords.y += arg.status.dy;\n\n        result.dx += arg.status.dx;\n        result.dy += arg.status.dy;\n\n        result.locked = true;\n      }\n    }\n\n    // a move should be fired if:\n    //  - there are no modifiers enabled,\n    //  - no modifiers are \"locked\" i.e. have changed the pointer's coordinates, or\n    //  - the locked coords have changed since the last pointer move\n    result.shouldMove = !arg.status || !result.locked || arg.status.changed;\n\n    return result;\n  },\n\n  resetStatuses: function (statuses) {\n    for (const modifierName of modifiers.names) {\n      const status = statuses[modifierName] || {};\n\n      status.dx = status.dy = 0;\n      status.modifiedX = status.modifiedY = NaN;\n      status.locked = false;\n      status.changed = true;\n\n      statuses[modifierName] = status;\n    }\n\n    return statuses;\n  },\n\n  start: function ({ interaction }, signalName) {\n    const arg = {\n      interaction,\n      pageCoords: (signalName === 'action-resume' ?\n                   interaction.curCoords : interaction.startCoords).page,\n      startOffset: interaction.startOffset,\n      statuses: interaction.modifierStatuses,\n      preEnd: false,\n      requireEndOnly: false,\n    };\n\n    modifiers.setOffsets(arg);\n    modifiers.resetStatuses(arg.statuses);\n\n    arg.pageCoords = extend({}, interaction.startCoords.page);\n    interaction.modifierResult = modifiers.setAll(arg);\n  },\n\n  beforeMove: function ({ interaction, preEnd, interactingBeforeMove }) {\n    const modifierResult = modifiers.setAll({\n      interaction,\n      preEnd,\n      pageCoords: interaction.curCoords.page,\n      statuses: interaction.modifierStatuses,\n      requireEndOnly: false,\n    });\n\n    // don't fire an action move if a modifier would keep the event in the same\n    // cordinates as before\n    if (!modifierResult.shouldMove && interactingBeforeMove) {\n      interaction._dontFireMove = true;\n    }\n\n    interaction.modifierResult = modifierResult;\n  },\n\n  end: function ({ interaction, event }) {\n    for (const modifierName of modifiers.names) {\n      const options = interaction.target.options[interaction.prepared.name][modifierName];\n\n      // if the endOnly option is true for any modifier\n      if (shouldDo(options, true, true)) {\n        // fire a move event at the modified coordinates\n        interaction.doMove({ event, preEnd: true });\n        break;\n      }\n    }\n  },\n\n  setXY: function (arg) {\n    const { iEvent, interaction } = arg;\n    const modifierArg = extend({}, arg);\n\n    for (let i = 0; i < modifiers.names.length; i++) {\n      const modifierName = modifiers.names[i];\n      modifierArg.options = interaction.target.options[interaction.prepared.name][modifierName];\n\n      if (!modifierArg.options) {\n        continue;\n      }\n\n      const modifier = modifiers[modifierName];\n\n      modifierArg.status = interaction.modifierStatuses[modifierName];\n\n      iEvent[modifierName] = modifier.modifyCoords(modifierArg);\n    }\n  },\n};\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.startOffset      = { left: 0, right: 0, top: 0, bottom: 0 };\n  interaction.modifierOffsets  = {};\n  interaction.modifierStatuses = modifiers.resetStatuses({});\n  interaction.modifierResult   = null;\n});\n\nInteraction.signals.on('action-start' , modifiers.start);\nInteraction.signals.on('action-resume', modifiers.start);\nInteraction.signals.on('before-action-move', modifiers.beforeMove);\nInteraction.signals.on('action-end', modifiers.end);\n\nInteractEvent.signals.on('set-xy', modifiers.setXY);\n\nfunction shouldDo (options, preEnd, requireEndOnly) {\n  return (options && options.enabled\n          && (preEnd || !options.endOnly)\n          && (!requireEndOnly || options.endOnly));\n}\n\nmodule.exports = modifiers;\n","const modifiers      = require('./base');\nconst utils          = require('../utils');\nconst defaultOptions = require('../defaultOptions');\n\nconst restrict = {\n  defaults: {\n    enabled    : false,\n    endOnly    : false,\n    restriction: null,\n    elementRect: null,\n  },\n\n  setOffset: function ({ rect, startOffset, options }) {\n    const elementRect = options && options.elementRect;\n    const offset = {};\n\n    if (rect && elementRect) {\n      offset.left = startOffset.left - (rect.width  * elementRect.left);\n      offset.top  = startOffset.top  - (rect.height * elementRect.top);\n\n      offset.right  = startOffset.right  - (rect.width  * (1 - elementRect.right));\n      offset.bottom = startOffset.bottom - (rect.height * (1 - elementRect.bottom));\n    }\n    else {\n      offset.left = offset.top = offset.right = offset.bottom = 0;\n    }\n\n    return offset;\n  },\n\n  set: function ({ modifiedCoords, interaction, status, options }) {\n    if (!options) { return status; }\n\n    const page = status.useStatusXY\n      ? { x: status.x, y: status.y }\n      : utils.extend({}, modifiedCoords);\n\n    const restriction = getRestrictionRect(options.restriction, interaction, page);\n\n    if (!restriction) { return status; }\n\n    status.dx = 0;\n    status.dy = 0;\n    status.locked = false;\n\n    const rect = restriction;\n    let modifiedX = page.x;\n    let modifiedY = page.y;\n\n    const offset = interaction.modifierOffsets.restrict;\n\n    // object is assumed to have\n    // x, y, width, height or\n    // left, top, right, bottom\n    if ('x' in restriction && 'y' in restriction) {\n      modifiedX = Math.max(Math.min(rect.x + rect.width  - offset.right , page.x), rect.x + offset.left);\n      modifiedY = Math.max(Math.min(rect.y + rect.height - offset.bottom, page.y), rect.y + offset.top );\n    }\n    else {\n      modifiedX = Math.max(Math.min(rect.right  - offset.right , page.x), rect.left + offset.left);\n      modifiedY = Math.max(Math.min(rect.bottom - offset.bottom, page.y), rect.top  + offset.top );\n    }\n\n    status.dx = modifiedX - page.x;\n    status.dy = modifiedY - page.y;\n\n    status.changed = status.modifiedX !== modifiedX || status.modifiedY !== modifiedY;\n    status.locked = !!(status.dx || status.dy);\n\n    status.modifiedX = modifiedX;\n    status.modifiedY = modifiedY;\n  },\n\n  modifyCoords: function ({ page, client, status, phase, options }) {\n    const elementRect = options && options.elementRect;\n\n    if (options && options.enabled\n        && !(phase === 'start' && elementRect && status.locked)) {\n\n      if (status.locked) {\n        page.x += status.dx;\n        page.y += status.dy;\n        client.x += status.dx;\n        client.y += status.dy;\n\n        return {\n          dx: status.dx,\n          dy: status.dy,\n        };\n      }\n    }\n  },\n\n  getRestrictionRect,\n};\n\nfunction getRestrictionRect (value, interaction, page) {\n  if (utils.is.function(value)) {\n    return utils.resolveRectLike(value, interaction.target, interaction.element, [page.x, page.y, interaction]);\n  } else {\n    return utils.resolveRectLike(value, interaction.target, interaction.element);\n  }\n}\n\nmodifiers.restrict = restrict;\nmodifiers.names.push('restrict');\n\ndefaultOptions.perAction.restrict = restrict.defaults;\n\nmodule.exports = restrict;\n","// This module adds the options.resize.restrictEdges setting which sets min and\n// max for the top, left, bottom and right edges of the target being resized.\n//\n// interact(target).resize({\n//   edges: { top: true, left: true },\n//   restrictEdges: {\n//     inner: { top: 200, left: 200, right: 400, bottom: 400 },\n//     outer: { top:   0, left:   0, right: 600, bottom: 600 },\n//   },\n// });\n\nconst modifiers      = require('./base');\nconst utils          = require('../utils');\nconst rectUtils      = require('../utils/rect');\nconst defaultOptions = require('../defaultOptions');\nconst resize         = require('../actions/resize');\n\nconst { getRestrictionRect } = require('./restrict');\n\nconst noInner = { top: +Infinity, left: +Infinity, bottom: -Infinity, right: -Infinity };\nconst noOuter = { top: -Infinity, left: -Infinity, bottom: +Infinity, right: +Infinity };\n\nconst restrictEdges = {\n  defaults: {\n    enabled: false,\n    endOnly: false,\n    min: null,\n    max: null,\n    offset: null,\n  },\n\n  setOffset: function ({ interaction, startOffset, options }) {\n    if (!options) {\n      return utils.extend({}, startOffset);\n    }\n\n    const offset = getRestrictionRect(options.offset, interaction, interaction.startCoords.page);\n\n    if (offset) {\n      return {\n        top:    startOffset.top    + offset.y,\n        left:   startOffset.left   + offset.x,\n        bottom: startOffset.bottom + offset.y,\n        right:  startOffset.right  + offset.x,\n      };\n    }\n\n    return startOffset;\n  },\n\n  set: function ({ modifiedCoords, interaction, status, offset, options }) {\n    const edges = interaction.prepared.linkedEdges || interaction.prepared.edges;\n\n    if (!interaction.interacting() || !edges) {\n      return;\n    }\n\n    const page = status.useStatusXY\n      ? { x: status.x, y: status.y }\n      : utils.extend({}, modifiedCoords);\n    const inner = rectUtils.xywhToTlbr(getRestrictionRect(options.inner, interaction, page)) || noInner;\n    const outer = rectUtils.xywhToTlbr(getRestrictionRect(options.outer, interaction, page)) || noOuter;\n\n    let modifiedX = page.x;\n    let modifiedY = page.y;\n\n    status.dx = 0;\n    status.dy = 0;\n    status.locked = false;\n\n    if (edges.top) {\n      modifiedY = Math.min(Math.max(outer.top    + offset.top,    page.y), inner.top    + offset.top);\n    }\n    else if (edges.bottom) {\n      modifiedY = Math.max(Math.min(outer.bottom - offset.bottom, page.y), inner.bottom - offset.bottom);\n    }\n    if (edges.left) {\n      modifiedX = Math.min(Math.max(outer.left   + offset.left,   page.x), inner.left   + offset.left);\n    }\n    else if (edges.right) {\n      modifiedX = Math.max(Math.min(outer.right  - offset.right,  page.x), inner.right  - offset.right);\n    }\n\n    status.dx = modifiedX - page.x;\n    status.dy = modifiedY - page.y;\n\n    status.changed = status.modifiedX !== modifiedX || status.modifiedY !== modifiedY;\n    status.locked = !!(status.dx || status.dy);\n\n    status.modifiedX = modifiedX;\n    status.modifiedY = modifiedY;\n  },\n\n  modifyCoords: function ({ page, client, status, phase, options }) {\n    if (options && options.enabled\n        && !(phase === 'start' && status.locked)) {\n\n      if (status.locked) {\n        page.x += status.dx;\n        page.y += status.dy;\n        client.x += status.dx;\n        client.y += status.dy;\n\n        return {\n          dx: status.dx,\n          dy: status.dy,\n        };\n      }\n    }\n  },\n\n  noInner,\n  noOuter,\n  getRestrictionRect,\n};\n\nmodifiers.restrictEdges = restrictEdges;\nmodifiers.names.push('restrictEdges');\n\ndefaultOptions.perAction.restrictEdges = restrictEdges.defaults;\nresize.defaults.restrictEdges          = restrictEdges.defaults;\n\nmodule.exports = restrictEdges;\n","// This module adds the options.resize.restrictSize setting which sets min and\n// max width and height for the target being resized.\n//\n// interact(target).resize({\n//   edges: { top: true, left: true },\n//   restrictSize: {\n//     min: { width: -600, height: -600 },\n//     max: { width:  600, height:  600 },\n//   },\n// });\n\nconst modifiers      = require('./base');\nconst restrictEdges  = require('./restrictEdges');\nconst utils          = require('../utils');\nconst rectUtils      = require('../utils/rect');\nconst defaultOptions = require('../defaultOptions');\nconst resize         = require('../actions/resize');\n\nconst noMin = { width: -Infinity, height: -Infinity };\nconst noMax = { width: +Infinity, height: +Infinity };\n\nconst restrictSize = {\n  defaults: {\n    enabled: false,\n    endOnly: false,\n    min: null,\n    max: null,\n  },\n\n  setOffset: function ({ interaction }) {\n    return interaction.startOffset;\n  },\n\n  set: function (arg) {\n    const { interaction, options } = arg;\n    const edges = interaction.prepared.linkedEdges || interaction.prepared.edges;\n\n    if (!interaction.interacting() || !edges) {\n      return;\n    }\n\n    const rect = rectUtils.xywhToTlbr(interaction.resizeRects.inverted);\n\n    const minSize = rectUtils.tlbrToXywh(restrictEdges.getRestrictionRect(options.min, interaction)) || noMin;\n    const maxSize = rectUtils.tlbrToXywh(restrictEdges.getRestrictionRect(options.max, interaction)) || noMax;\n\n    arg.options = {\n      enabled: options.enabled,\n      endOnly: options.endOnly,\n      inner: utils.extend({}, restrictEdges.noInner),\n      outer: utils.extend({}, restrictEdges.noOuter),\n    };\n\n    if (edges.top) {\n      arg.options.inner.top = rect.bottom - minSize.height;\n      arg.options.outer.top = rect.bottom - maxSize.height;\n    }\n    else if (edges.bottom) {\n      arg.options.inner.bottom = rect.top + minSize.height;\n      arg.options.outer.bottom = rect.top + maxSize.height;\n    }\n    if (edges.left) {\n      arg.options.inner.left = rect.right - minSize.width;\n      arg.options.outer.left = rect.right - maxSize.width;\n    }\n    else if (edges.right) {\n      arg.options.inner.right = rect.left + minSize.width;\n      arg.options.outer.right = rect.left + maxSize.width;\n    }\n\n    restrictEdges.set(arg);\n  },\n\n  modifyCoords: restrictEdges.modifyCoords,\n};\n\nmodifiers.restrictSize = restrictSize;\nmodifiers.names.push('restrictSize');\n\ndefaultOptions.perAction.restrictSize = restrictSize.defaults;\nresize.defaults.restrictSize          = restrictSize.defaults;\n\nmodule.exports = restrictSize;\n","const modifiers      = require('./base');\nconst interact       = require('../interact');\nconst utils          = require('../utils');\nconst defaultOptions = require('../defaultOptions');\n\nconst snap = {\n  defaults: {\n    enabled: false,\n    endOnly: false,\n    range  : Infinity,\n    targets: null,\n    offsets: null,\n\n    relativePoints: null,\n  },\n\n  setOffset: function ({ interaction, interactable, element, rect, startOffset, options }) {\n    const offsets = [];\n    const optionsOrigin = utils.rectToXY(utils.resolveRectLike(options.origin));\n    const origin = optionsOrigin || utils.getOriginXY(interactable, element, interaction.prepared.name);\n    options = options || interactable.options[interaction.prepared.name].snap || {};\n\n    let snapOffset;\n\n    if (options.offset === 'startCoords') {\n      snapOffset = {\n        x: interaction.startCoords.page.x - origin.x,\n        y: interaction.startCoords.page.y - origin.y,\n      };\n    }\n    else  {\n      const offsetRect = utils.resolveRectLike(options.offset, interactable, element, [interaction]);\n\n      snapOffset = utils.rectToXY(offsetRect) || { x: 0, y: 0 };\n    }\n\n    if (rect && options.relativePoints && options.relativePoints.length) {\n      for (const { x: relativeX, y: relativeY } of options.relativePoints) {\n        offsets.push({\n          x: startOffset.left - (rect.width  * relativeX) + snapOffset.x,\n          y: startOffset.top  - (rect.height * relativeY) + snapOffset.y,\n        });\n      }\n    }\n    else {\n      offsets.push(snapOffset);\n    }\n\n    return offsets;\n  },\n\n  set: function ({ interaction, modifiedCoords, status, options, offset: offsets }) {\n    const targets = [];\n    let target;\n    let page;\n    let i;\n\n    if (status.useStatusXY) {\n      page = { x: status.x, y: status.y };\n    }\n    else {\n      const origin = utils.getOriginXY(interaction.target, interaction.element, interaction.prepared.name);\n\n      page = utils.extend({}, modifiedCoords);\n\n      page.x -= origin.x;\n      page.y -= origin.y;\n    }\n\n    status.realX = page.x;\n    status.realY = page.y;\n\n    let len = options.targets? options.targets.length : 0;\n\n    for (const { x: offsetX, y: offsetY } of offsets) {\n      const relativeX = page.x - offsetX;\n      const relativeY = page.y - offsetY;\n\n      for (const snapTarget of (options.targets || [])) {\n        if (utils.is.function(snapTarget)) {\n          target = snapTarget(relativeX, relativeY, interaction);\n        }\n        else {\n          target = snapTarget;\n        }\n\n        if (!target) { continue; }\n\n        targets.push({\n          x: utils.is.number(target.x) ? (target.x + offsetX) : relativeX,\n          y: utils.is.number(target.y) ? (target.y + offsetY) : relativeY,\n\n          range: utils.is.number(target.range)? target.range: options.range,\n        });\n      }\n    }\n\n    const closest = {\n      target: null,\n      inRange: false,\n      distance: 0,\n      range: 0,\n      dx: 0,\n      dy: 0,\n    };\n\n    for (i = 0, len = targets.length; i < len; i++) {\n      target = targets[i];\n\n      const range = target.range;\n      const dx = target.x - page.x;\n      const dy = target.y - page.y;\n      const distance = utils.hypot(dx, dy);\n      let inRange = distance <= range;\n\n      // Infinite targets count as being out of range\n      // compared to non infinite ones that are in range\n      if (range === Infinity && closest.inRange && closest.range !== Infinity) {\n        inRange = false;\n      }\n\n      if (!closest.target || (inRange\n          // is the closest target in range?\n          ? (closest.inRange && range !== Infinity\n          // the pointer is relatively deeper in this target\n          ? distance / range < closest.distance / closest.range\n          // this target has Infinite range and the closest doesn't\n          : (range === Infinity && closest.range !== Infinity)\n          // OR this target is closer that the previous closest\n        || distance < closest.distance)\n          // The other is not in range and the pointer is closer to this target\n          : (!closest.inRange && distance < closest.distance))) {\n\n        closest.target = target;\n        closest.distance = distance;\n        closest.range = range;\n        closest.inRange = inRange;\n        closest.dx = dx;\n        closest.dy = dy;\n\n        status.range = range;\n      }\n    }\n\n    let snapChanged;\n\n    if (closest.target) {\n      snapChanged = (status.modifiedX !== closest.target.x || status.modifiedY !== closest.target.y);\n\n      status.modifiedX = closest.target.x;\n      status.modifiedY = closest.target.y;\n    }\n    else {\n      snapChanged = true;\n\n      status.modifiedX = NaN;\n      status.modifiedY = NaN;\n    }\n\n    status.dx = closest.dx;\n    status.dy = closest.dy;\n\n    status.changed = (snapChanged || (closest.inRange && !status.locked));\n    status.locked = closest.inRange;\n  },\n\n  modifyCoords: function ({ page, client, status, phase, options }) {\n    const relativePoints = options && options.relativePoints;\n\n    if (options && options.enabled\n        && !(phase === 'start' && relativePoints && relativePoints.length)) {\n\n      if (status.locked) {\n        page.x += status.dx;\n        page.y += status.dy;\n        client.x += status.dx;\n        client.y += status.dy;\n      }\n\n      return {\n        range  : status.range,\n        locked : status.locked,\n        x      : status.modifiedX,\n        y      : status.modifiedY,\n        realX  : status.realX,\n        realY  : status.realY,\n        dx     : status.dx,\n        dy     : status.dy,\n      };\n    }\n  },\n};\n\ninteract.createSnapGrid = function (grid) {\n  return function (x, y) {\n    const limits = grid.limits || {\n      left  : -Infinity,\n      right :  Infinity,\n      top   : -Infinity,\n      bottom:  Infinity,\n    };\n    let offsetX = 0;\n    let offsetY = 0;\n\n    if (utils.is.object(grid.offset)) {\n      offsetX = grid.offset.x;\n      offsetY = grid.offset.y;\n    }\n\n    const gridx = Math.round((x - offsetX) / grid.x);\n    const gridy = Math.round((y - offsetY) / grid.y);\n\n    const newX = Math.max(limits.left, Math.min(limits.right , gridx * grid.x + offsetX));\n    const newY = Math.max(limits.top , Math.min(limits.bottom, gridy * grid.y + offsetY));\n\n    return {\n      x: newX,\n      y: newY,\n      range: grid.range,\n    };\n  };\n};\n\nmodifiers.snap = snap;\nmodifiers.names.push('snap');\n\ndefaultOptions.perAction.snap = snap.defaults;\n\nmodule.exports = snap;\n","// This module allows snapping of the size of targets during resize\n// interactions.\n\nconst modifiers      = require('./base');\nconst snap           = require('./snap');\nconst defaultOptions = require('../defaultOptions');\nconst resize         = require('../actions/resize');\nconst utils          = require('../utils/');\n\nconst snapSize = {\n  defaults: {\n    enabled: false,\n    endOnly: false,\n    range  : Infinity,\n    targets: null,\n    offsets: null,\n  },\n\n  setOffset: function (arg) {\n    const { interaction, options } = arg;\n    const edges = interaction.prepared.edges;\n\n    if (!edges) { return; }\n\n    arg.options = {\n      relativePoints: [{\n        x: edges.left? 0 : 1,\n        y: edges.top ? 0 : 1,\n      }],\n      origin: { x: 0, y: 0 },\n      offset: 'self',\n      range: options.range,\n    };\n\n    const offsets = snap.setOffset(arg);\n    arg.options = options;\n\n    return offsets;\n  },\n\n  set: function (arg) {\n    const { interaction, options, offset, modifiedCoords } = arg;\n    const page = utils.extend({}, modifiedCoords);\n    const relativeX = page.x - offset[0].x;\n    const relativeY = page.y - offset[0].y;\n\n    arg.options = utils.extend({}, options);\n    arg.options.targets = [];\n\n    for (const snapTarget of (options.targets || [])) {\n      let target;\n\n      if (utils.is.function(snapTarget)) {\n        target = snapTarget(relativeX, relativeY, interaction);\n      }\n      else {\n        target = snapTarget;\n      }\n\n      if (!target) { continue; }\n\n      if ('width' in target && 'height' in target) {\n        target.x = target.width;\n        target.y = target.height;\n      }\n\n      arg.options.targets.push(target);\n    }\n\n    snap.set(arg);\n  },\n\n  modifyCoords: function (arg) {\n    const { options } = arg;\n\n    arg.options = utils.extend({}, options);\n    arg.options.enabled = options.enabled;\n    arg.options.relativePoints = [null];\n\n    snap.modifyCoords(arg);\n  },\n};\n\nmodifiers.snapSize = snapSize;\nmodifiers.names.push('snapSize');\n\ndefaultOptions.perAction.snapSize = snapSize.defaults;\nresize.defaults.snapSize          = snapSize.defaults;\n\nmodule.exports = snapSize;\n","const pointerUtils = require('../utils/pointerUtils');\n\nmodule.exports = class PointerEvent {\n  /** */\n  constructor (type, pointer, event, eventTarget, interaction) {\n    pointerUtils.pointerExtend(this, event);\n\n    if (event !== pointer) {\n      pointerUtils.pointerExtend(this, pointer);\n    }\n\n    this.interaction = interaction;\n\n    this.timeStamp     = new Date().getTime();\n    this.originalEvent = event;\n    this.type          = type;\n    this.pointerId     = pointerUtils.getPointerId(pointer);\n    this.pointerType   = pointerUtils.getPointerType(pointer);\n    this.target        = eventTarget;\n    this.currentTarget = null;\n\n    if (type === 'tap') {\n      const pointerIndex = interaction.getPointerIndex(pointer);\n      this.dt = this.timeStamp - interaction.downTimes[pointerIndex];\n\n      const interval = this.timeStamp - interaction.tapTime;\n\n      this.double = !!(interaction.prevTap\n        && interaction.prevTap.type !== 'doubletap'\n        && interaction.prevTap.target === this.target\n        && interval < 500);\n    }\n    else if (type === 'doubletap') {\n      this.dt = pointer.timeStamp - interaction.tapTime;\n    }\n  }\n\n  subtractOrigin ({ x: originX, y: originY }) {\n    this.pageX   -= originX;\n    this.pageY   -= originY;\n    this.clientX -= originX;\n    this.clientY -= originY;\n\n    return this;\n  }\n\n  addOrigin ({ x: originX, y: originY }) {\n    this.pageX   += originX;\n    this.pageY   += originY;\n    this.clientX += originX;\n    this.clientY += originY;\n\n    return this;\n  }\n\n  /** */\n  preventDefault () {\n    this.originalEvent.preventDefault();\n  }\n\n  /** */\n  stopPropagation () {\n    this.propagationStopped = true;\n  }\n\n  /** */\n  stopImmediatePropagation () {\n    this.immediatePropagationStopped = this.propagationStopped = true;\n  }\n};\n","const PointerEvent = require('./PointerEvent');\nconst Interaction  = require('../Interaction');\nconst utils        = require('../utils');\nconst defaults     = require('../defaultOptions');\nconst signals      = require('../utils/Signals').new();\n\nconst simpleSignals = [ 'down', 'up', 'cancel' ];\nconst simpleEvents  = [ 'down', 'up', 'cancel' ];\n\nconst pointerEvents = {\n  PointerEvent,\n  fire,\n  collectEventTargets,\n  signals,\n  defaults: {\n    holdDuration: 600,\n    ignoreFrom  : null,\n    allowFrom   : null,\n    origin      : { x: 0, y: 0 },\n  },\n  types: [\n    'down',\n    'move',\n    'up',\n    'cancel',\n    'tap',\n    'doubletap',\n    'hold',\n  ],\n};\n\nfunction fire (arg) {\n  const {\n    interaction, pointer, event, eventTarget,\n    type = arg.pointerEvent.type,\n    targets = collectEventTargets(arg),\n    pointerEvent = new PointerEvent(type, pointer, event, eventTarget, interaction),\n  } = arg;\n\n  const signalArg = {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    targets,\n    type,\n    pointerEvent,\n  };\n\n  for (let i = 0; i < targets.length; i++) {\n    const target = targets[i];\n\n    for (const prop in target.props || {}) {\n      pointerEvent[prop] = target.props[prop];\n    }\n\n    const origin = utils.getOriginXY(target.eventable, target.element);\n\n    pointerEvent.subtractOrigin(origin);\n    pointerEvent.eventable = target.eventable;\n    pointerEvent.currentTarget = target.element;\n\n    target.eventable.fire(pointerEvent);\n\n    pointerEvent.addOrigin(origin);\n\n    if (pointerEvent.immediatePropagationStopped\n        || (pointerEvent.propagationStopped\n            && (i + 1) < targets.length && targets[i + 1].element !== pointerEvent.currentTarget)) {\n      break;\n    }\n  }\n\n  signals.fire('fired', signalArg);\n\n  if (type === 'tap') {\n    // if pointerEvent should make a double tap, create and fire a doubletap\n    // PointerEvent and use that as the prevTap\n    const prevTap = pointerEvent.double\n      ? fire({\n        interaction, pointer, event, eventTarget,\n        type: 'doubletap',\n      })\n      : pointerEvent;\n\n    interaction.prevTap = prevTap;\n    interaction.tapTime = prevTap.timeStamp;\n  }\n\n  return pointerEvent;\n}\n\nfunction collectEventTargets ({ interaction, pointer, event, eventTarget, type }) {\n  const pointerIndex = interaction.getPointerIndex(pointer);\n\n  // do not fire a tap event if the pointer was moved before being lifted\n  if (type === 'tap' && (interaction.pointerWasMoved\n      // or if the pointerup target is different to the pointerdown target\n      || !(interaction.downTargets[pointerIndex] && interaction.downTargets[pointerIndex] === eventTarget))) {\n    return [];\n  }\n\n  const path = utils.getPath(eventTarget);\n  const signalArg = {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    type,\n    path,\n    targets: [],\n    element: null,\n  };\n\n  for (const element of path) {\n    signalArg.element = element;\n\n    signals.fire('collect-targets', signalArg);\n  }\n\n  if (type === 'hold') {\n    signalArg.targets = signalArg.targets.filter(target =>\n      target.eventable.options.holdDuration === interaction.holdTimers[pointerIndex].duration);\n  }\n\n  return signalArg.targets;\n}\n\nInteraction.signals.on('update-pointer-down', function ({ interaction, pointerIndex }) {\n  interaction.holdTimers[pointerIndex] = { duration: Infinity, timeout: null };\n});\n\nInteraction.signals.on('remove-pointer', function ({ interaction, pointerIndex }) {\n  interaction.holdTimers.splice(pointerIndex, 1);\n});\n\nInteraction.signals.on('move', function ({ interaction, pointer, event, eventTarget, duplicateMove }) {\n  const pointerIndex = interaction.getPointerIndex(pointer);\n\n  if (!duplicateMove && (!interaction.pointerIsDown || interaction.pointerWasMoved)) {\n    if (interaction.pointerIsDown) {\n      clearTimeout(interaction.holdTimers[pointerIndex].timeout);\n    }\n\n    fire({\n      interaction, pointer, event, eventTarget,\n      type: 'move',\n    });\n  }\n});\n\nInteraction.signals.on('down', function ({ interaction, pointer, event, eventTarget, pointerIndex }) {\n  const timer = interaction.holdTimers[pointerIndex];\n  const path = utils.getPath(eventTarget);\n  const signalArg = {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    type: 'hold',\n    targets: [],\n    path,\n    element: null,\n  };\n\n  for (const element of path) {\n    signalArg.element = element;\n\n    signals.fire('collect-targets', signalArg);\n  }\n\n  if (!signalArg.targets.length) { return; }\n\n  let minDuration = Infinity;\n\n  for (const target of signalArg.targets) {\n    const holdDuration = target.eventable.options.holdDuration;\n\n    if (holdDuration < minDuration) {\n      minDuration = holdDuration;\n    }\n  }\n\n  timer.duration = minDuration;\n  timer.timeout = setTimeout(function () {\n    fire({\n      interaction,\n      eventTarget,\n      pointer,\n      event,\n      type: 'hold',\n    });\n  }, minDuration);\n});\n\nInteraction.signals.on('up', ({ interaction, pointer, event, eventTarget }) => {\n  if (!interaction.pointerWasMoved) {\n    fire({ interaction, eventTarget, pointer, event, type: 'tap' });\n  }\n});\n\nfor (const signalName of ['up', 'cancel']) {\n  Interaction.signals.on(signalName, function ({ interaction, pointerIndex }) {\n    if (interaction.holdTimers[pointerIndex]) {\n      clearTimeout(interaction.holdTimers[pointerIndex].timeout);\n    }\n  });\n}\n\nfunction createSignalListener (type) {\n  return function ({ interaction, pointer, event, eventTarget }) {\n    fire({ interaction, eventTarget, pointer, event, type });\n  };\n}\n\nfor (let i = 0; i < simpleSignals.length; i++) {\n  Interaction.signals.on(simpleSignals[i], createSignalListener(simpleEvents[i]));\n}\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.prevTap    = null;  // the most recent tap event on this interaction\n  interaction.tapTime    = 0;     // time of the most recent tap event\n  interaction.holdTimers = [];    // [{ duration, timeout }]\n});\n\ndefaults.pointerEvents = pointerEvents.defaults;\nmodule.exports = pointerEvents;\n","const pointerEvents = require('./base');\nconst Interaction   = require('../Interaction');\n\npointerEvents.signals.on('new', onNew);\npointerEvents.signals.on('fired', onFired);\n\nfor (const signal of ['move', 'up', 'cancel', 'endall']) {\n  Interaction.signals.on(signal, endHoldRepeat);\n}\n\nfunction onNew ({ pointerEvent }) {\n  if (pointerEvent.type !== 'hold') { return; }\n\n  pointerEvent.count = (pointerEvent.count || 0) + 1;\n}\n\nfunction onFired ({ interaction, pointerEvent, eventTarget, targets }) {\n  if (pointerEvent.type !== 'hold' || !targets.length) { return; }\n\n  // get the repeat interval from the first eventable\n  const interval = targets[0].eventable.options.holdRepeatInterval;\n\n  // don't repeat if the interval is 0 or less\n  if (interval <= 0) { return; }\n\n  // set a timeout to fire the holdrepeat event\n  interaction.holdIntervalHandle = setTimeout(function () {\n    pointerEvents.fire({\n      interaction,\n      eventTarget,\n      type: 'hold',\n      pointer: pointerEvent,\n      event: pointerEvent,\n    });\n  }, interval);\n}\n\nfunction endHoldRepeat ({ interaction }) {\n  // set the interaction's holdStopTime property\n  // to stop further holdRepeat events\n  if (interaction.holdIntervalHandle) {\n    clearInterval(interaction.holdIntervalHandle);\n    interaction.holdIntervalHandle = null;\n  }\n}\n\n// don't repeat by default\npointerEvents.defaults.holdRepeatInterval = 0;\npointerEvents.types.push('holdrepeat');\n\nmodule.exports = {\n  onNew,\n  onFired,\n  endHoldRepeat,\n};\n","const pointerEvents = require('./base');\nconst Interactable  = require('../Interactable');\nconst is            = require('../utils/is');\nconst scope         = require('../scope');\nconst extend        = require('../utils/extend');\nconst { merge }     = require('../utils/arr');\n\npointerEvents.signals.on('collect-targets', function ({ targets, element, type, eventTarget }) {\n  scope.interactables.forEachMatch(element, interactable => {\n    const eventable = interactable.events;\n    const options = eventable.options;\n\n    if (eventable[type]\n      && is.element(element)\n      && interactable.testIgnoreAllow(options, element, eventTarget)) {\n\n      targets.push({\n        element,\n        eventable,\n        props: { interactable },\n      });\n    }\n  });\n});\n\nInteractable.signals.on('new', function ({ interactable }) {\n  interactable.events.getRect = function (element) {\n    return interactable.getRect(element);\n  };\n});\n\nInteractable.signals.on('set', function ({ interactable, options }) {\n  extend(interactable.events.options, pointerEvents.defaults);\n  extend(interactable.events.options, options);\n});\n\nmerge(Interactable.eventTypes, pointerEvents.types);\n\nInteractable.prototype.pointerEvents = function (options) {\n  extend(this.events.options, options);\n\n  return this;\n};\n\nconst __backCompatOption = Interactable.prototype._backCompatOption;\n\nInteractable.prototype._backCompatOption = function (optionName, newValue) {\n  const ret = __backCompatOption.call(this, optionName, newValue);\n\n  if (ret === this) {\n    this.events.options[optionName] = newValue;\n  }\n\n  return ret;\n};\n\nInteractable.settingsMethods.push('pointerEvents');\n","const utils   = require('./utils');\nconst events  = require('./utils/events');\nconst signals = require('./utils/Signals').new();\n\nconst { getWindow } = require('./utils/window');\n\nconst scope = {\n  signals,\n  events,\n  utils,\n\n  // main document\n  document: require('./utils/domObjects').document,\n  // all documents being listened to\n  documents: [],\n\n  addDocument: function (doc, win) {\n    // do nothing if document is already known\n    if (utils.contains(scope.documents, doc)) { return false; }\n\n    win = win || getWindow(doc);\n\n    scope.documents.push(doc);\n    events.documents.push(doc);\n\n    // don't add an unload event for the main document\n    // so that the page may be cached in browser history\n    if (doc !== scope.document) {\n      events.add(win, 'unload', scope.onWindowUnload);\n    }\n\n    signals.fire('add-document', { doc, win });\n  },\n\n  removeDocument: function (doc, win) {\n    const index = scope.documents.indexOf(doc);\n\n    win = win || getWindow(doc);\n\n    events.remove(win, 'unload', scope.onWindowUnload);\n\n    scope.documents.splice(index, 1);\n    events.documents.splice(index, 1);\n\n    signals.fire('remove-document', { win, doc });\n  },\n\n  onWindowUnload: function () {\n    scope.removeDocument(this.document, this);\n  },\n};\n\nmodule.exports = scope;\n","class Signals {\n  constructor () {\n    this.listeners = {\n      // signalName: [listeners],\n    };\n  }\n\n  on (name, listener) {\n    if (!this.listeners[name]) {\n      this.listeners[name] = [listener];\n      return;\n    }\n\n    this.listeners[name].push(listener);\n  }\n\n  off (name, listener) {\n    if (!this.listeners[name]) { return; }\n\n    const index = this.listeners[name].indexOf(listener);\n\n    if (index !== -1) {\n      this.listeners[name].splice(index, 1);\n    }\n  }\n\n  fire (name, arg) {\n    const targetListeners = this.listeners[name];\n\n    if (!targetListeners) { return; }\n\n    for (const listener of targetListeners) {\n      if (listener(arg, name) === false) {\n        return;\n      }\n    }\n  }\n}\n\nSignals.new = function () {\n  return new Signals();\n};\n\nmodule.exports = Signals;\n","function contains (array, target) {\n  return array.indexOf(target) !== -1;\n}\n\nfunction merge (target, source) {\n  for (const item of source) {\n    target.push(item);\n  }\n\n  return target;\n}\n\nmodule.exports = {\n  contains,\n  merge,\n};\n","const { window } = require('./window');\nconst is     = require('./is');\nconst domObjects = require('./domObjects');\n\nconst Element = domObjects.Element;\nconst navigator  = window.navigator;\n\nconst browser = {\n  // Does the browser support touch input?\n  supportsTouch: !!(('ontouchstart' in window) || is.function(window.DocumentTouch)\n                     && domObjects.document instanceof window.DocumentTouch),\n\n  // Does the browser support PointerEvents\n  supportsPointerEvent: !!domObjects.PointerEvent,\n\n  isIOS: (/iP(hone|od|ad)/.test(navigator.platform)),\n\n  // scrolling doesn't change the result of getClientRects on iOS 7\n  isIOS7: (/iP(hone|od|ad)/.test(navigator.platform)\n           && /OS 7[^\\d]/.test(navigator.appVersion)),\n\n  isIe9: /MSIE 9/.test(navigator.userAgent),\n\n  // prefix matchesSelector\n  prefixedMatchesSelector: 'matches' in Element.prototype\n    ? 'matches': 'webkitMatchesSelector' in Element.prototype\n    ? 'webkitMatchesSelector': 'mozMatchesSelector' in Element.prototype\n    ? 'mozMatchesSelector': 'oMatchesSelector' in Element.prototype\n    ? 'oMatchesSelector': 'msMatchesSelector',\n\n  pEventTypes: (domObjects.PointerEvent\n    ? (domObjects.PointerEvent === window.MSPointerEvent\n      ? {\n        up:     'MSPointerUp',\n        down:   'MSPointerDown',\n        over:   'mouseover',\n        out:    'mouseout',\n        move:   'MSPointerMove',\n        cancel: 'MSPointerCancel',\n      }\n      : {\n        up:     'pointerup',\n        down:   'pointerdown',\n        over:   'pointerover',\n        out:    'pointerout',\n        move:   'pointermove',\n        cancel: 'pointercancel',\n      })\n    : null),\n\n  // because Webkit and Opera still use 'mousewheel' event type\n  wheelEvent: 'onmousewheel' in domObjects.document? 'mousewheel': 'wheel',\n\n};\n\n// Opera Mobile must be handled differently\nbrowser.isOperaMobile = (navigator.appName === 'Opera'\n  && browser.supportsTouch\n  && navigator.userAgent.match('Presto'));\n\nmodule.exports = browser;\n","const is = require('./is');\n\nmodule.exports = function clone (source) {\n  const dest = {};\n  for (const prop in source) {\n    if (is.plainObject(source[prop])) {\n      dest[prop] = clone(source[prop]);\n    } else {\n      dest[prop] = source[prop];\n    }\n  }\n  return dest;\n};\n","const domObjects = {};\nconst win = require('./window').window;\n\nfunction blank () {}\n\ndomObjects.document           = win.document;\ndomObjects.DocumentFragment   = win.DocumentFragment   || blank;\ndomObjects.SVGElement         = win.SVGElement         || blank;\ndomObjects.SVGSVGElement      = win.SVGSVGElement      || blank;\ndomObjects.SVGElementInstance = win.SVGElementInstance || blank;\ndomObjects.Element            = win.Element            || blank;\ndomObjects.HTMLElement        = win.HTMLElement        || domObjects.Element;\n\ndomObjects.Event        = win.Event;\ndomObjects.Touch        = win.Touch || blank;\ndomObjects.PointerEvent = (win.PointerEvent || win.MSPointerEvent);\n\nmodule.exports = domObjects;\n","const win        = require('./window');\nconst browser    = require('./browser');\nconst is         = require('./is');\nconst domObjects = require('./domObjects');\n\nconst domUtils = {\n  nodeContains: function (parent, child) {\n    while (child) {\n      if (child === parent) {\n        return true;\n      }\n\n      child = child.parentNode;\n    }\n\n    return false;\n  },\n\n  closest: function (element, selector) {\n    while (is.element(element)) {\n      if (domUtils.matchesSelector(element, selector)) { return element; }\n\n      element = domUtils.parentNode(element);\n    }\n\n    return null;\n  },\n\n  parentNode: function (node) {\n    let parent = node.parentNode;\n\n    if (is.docFrag(parent)) {\n      // skip past #shado-root fragments\n      while ((parent = parent.host) && is.docFrag(parent)) {\n        continue;\n      }\n\n      return parent;\n    }\n\n    return parent;\n  },\n\n  matchesSelector: function (element, selector) {\n    // remove /deep/ from selectors if shadowDOM polyfill is used\n    if (win.window !== win.realWindow) {\n      selector = selector.replace(/\\/deep\\//g, ' ');\n    }\n\n    return element[browser.prefixedMatchesSelector](selector);\n  },\n\n  // Test for the element that's \"above\" all other qualifiers\n  indexOfDeepestElement: function (elements) {\n    let deepestZoneParents = [];\n    let dropzoneParents = [];\n    let dropzone;\n    let deepestZone = elements[0];\n    let index = deepestZone? 0: -1;\n    let parent;\n    let child;\n    let i;\n    let n;\n\n    for (i = 1; i < elements.length; i++) {\n      dropzone = elements[i];\n\n      // an element might belong to multiple selector dropzones\n      if (!dropzone || dropzone === deepestZone) {\n        continue;\n      }\n\n      if (!deepestZone) {\n        deepestZone = dropzone;\n        index = i;\n        continue;\n      }\n\n      // check if the deepest or current are document.documentElement or document.rootElement\n      // - if the current dropzone is, do nothing and continue\n      if (dropzone.parentNode === dropzone.ownerDocument) {\n        continue;\n      }\n      // - if deepest is, update with the current dropzone and continue to next\n      else if (deepestZone.parentNode === dropzone.ownerDocument) {\n        deepestZone = dropzone;\n        index = i;\n        continue;\n      }\n\n      if (!deepestZoneParents.length) {\n        parent = deepestZone;\n        while (parent.parentNode && parent.parentNode !== parent.ownerDocument) {\n          deepestZoneParents.unshift(parent);\n          parent = parent.parentNode;\n        }\n      }\n\n      // if this element is an svg element and the current deepest is\n      // an HTMLElement\n      if (deepestZone instanceof domObjects.HTMLElement\n          && dropzone instanceof domObjects.SVGElement\n          && !(dropzone instanceof domObjects.SVGSVGElement)) {\n\n        if (dropzone === deepestZone.parentNode) {\n          continue;\n        }\n\n        parent = dropzone.ownerSVGElement;\n      }\n      else {\n        parent = dropzone;\n      }\n\n      dropzoneParents = [];\n\n      while (parent.parentNode !== parent.ownerDocument) {\n        dropzoneParents.unshift(parent);\n        parent = parent.parentNode;\n      }\n\n      n = 0;\n\n      // get (position of last common ancestor) + 1\n      while (dropzoneParents[n] && dropzoneParents[n] === deepestZoneParents[n]) {\n        n++;\n      }\n\n      const parents = [\n        dropzoneParents[n - 1],\n        dropzoneParents[n],\n        deepestZoneParents[n],\n      ];\n\n      child = parents[0].lastChild;\n\n      while (child) {\n        if (child === parents[1]) {\n          deepestZone = dropzone;\n          index = i;\n          deepestZoneParents = [];\n\n          break;\n        }\n        else if (child === parents[2]) {\n          break;\n        }\n\n        child = child.previousSibling;\n      }\n    }\n\n    return index;\n  },\n\n  matchesUpTo: function (element, selector, limit) {\n    while (is.element(element)) {\n      if (domUtils.matchesSelector(element, selector)) {\n        return true;\n      }\n\n      element = domUtils.parentNode(element);\n\n      if (element === limit) {\n        return domUtils.matchesSelector(element, selector);\n      }\n    }\n\n    return false;\n  },\n\n  getActualElement: function (element) {\n    return (element instanceof domObjects.SVGElementInstance\n      ? element.correspondingUseElement\n      : element);\n  },\n\n  getScrollXY: function (relevantWindow) {\n    relevantWindow = relevantWindow || win.window;\n    return {\n      x: relevantWindow.scrollX || relevantWindow.document.documentElement.scrollLeft,\n      y: relevantWindow.scrollY || relevantWindow.document.documentElement.scrollTop,\n    };\n  },\n\n  getElementClientRect: function (element) {\n    const clientRect = (element instanceof domObjects.SVGElement\n      ? element.getBoundingClientRect()\n      : element.getClientRects()[0]);\n\n    return clientRect && {\n      left  : clientRect.left,\n      right : clientRect.right,\n      top   : clientRect.top,\n      bottom: clientRect.bottom,\n      width : clientRect.width  || clientRect.right  - clientRect.left,\n      height: clientRect.height || clientRect.bottom - clientRect.top,\n    };\n  },\n\n  getElementRect: function (element) {\n    const clientRect = domUtils.getElementClientRect(element);\n\n    if (!browser.isIOS7 && clientRect) {\n      const scroll = domUtils.getScrollXY(win.getWindow(element));\n\n      clientRect.left   += scroll.x;\n      clientRect.right  += scroll.x;\n      clientRect.top    += scroll.y;\n      clientRect.bottom += scroll.y;\n    }\n\n    return clientRect;\n  },\n\n  getPath: function (element) {\n    const path = [];\n\n    while (element) {\n      path.push(element);\n      element = domUtils.parentNode(element);\n    }\n\n    return path;\n  },\n\n  trySelector: value => {\n    if (!is.string(value)) { return false; }\n\n    // an exception will be raised if it is invalid\n    domObjects.document.querySelector(value);\n    return true;\n  },\n};\n\nmodule.exports = domUtils;\n","const is           = require('./is');\nconst domUtils     = require('./domUtils');\nconst pointerUtils = require('./pointerUtils');\nconst pExtend      = require('./pointerExtend');\n\nconst { window }   = require('./window');\nconst { contains } = require('./arr');\n\nconst elements = [];\nconst targets  = [];\n\n// {\n//   type: {\n//     selectors: ['selector', ...],\n//     contexts : [document, ...],\n//     listeners: [[listener, capture, passive], ...]\n//   }\n//  }\nconst delegatedEvents = {};\nconst documents       = [];\n\nconst supportsOptions = (() => {\n  let supported = false;\n\n  window.document.createElement('div').addEventListener('test', null, {\n    get capture () { supported = true; },\n  });\n\n  return supported;\n})();\n\nfunction add (element, type, listener, optionalArg) {\n  const options = getOptions(optionalArg);\n  let elementIndex = elements.indexOf(element);\n  let target = targets[elementIndex];\n\n  if (!target) {\n    target = {\n      events: {},\n      typeCount: 0,\n    };\n\n    elementIndex = elements.push(element) - 1;\n    targets.push(target);\n  }\n\n  if (!target.events[type]) {\n    target.events[type] = [];\n    target.typeCount++;\n  }\n\n  if (!contains(target.events[type], listener)) {\n    element.addEventListener(type, listener, supportsOptions? options : !!options.capture);\n    target.events[type].push(listener);\n  }\n}\n\nfunction remove (element, type, listener, optionalArg) {\n  const options = getOptions(optionalArg);\n  const elementIndex = elements.indexOf(element);\n  const target = targets[elementIndex];\n\n  if (!target || !target.events) {\n    return;\n  }\n\n  if (type === 'all') {\n    for (type in target.events) {\n      if (target.events.hasOwnProperty(type)) {\n        remove(element, type, 'all');\n      }\n    }\n    return;\n  }\n\n  if (target.events[type]) {\n    const len = target.events[type].length;\n\n    if (listener === 'all') {\n      for (let i = 0; i < len; i++) {\n        remove(element, type, target.events[type][i], options);\n      }\n      return;\n    }\n    else {\n      for (let i = 0; i < len; i++) {\n        if (target.events[type][i] === listener) {\n          element.removeEventListener(`on${type}`, listener, supportsOptions? options : !!options.capture);\n          target.events[type].splice(i, 1);\n\n          break;\n        }\n      }\n    }\n\n    if (target.events[type] && target.events[type].length === 0) {\n      target.events[type] = null;\n      target.typeCount--;\n    }\n  }\n\n  if (!target.typeCount) {\n    targets.splice(elementIndex, 1);\n    elements.splice(elementIndex, 1);\n  }\n}\n\nfunction addDelegate (selector, context, type, listener, optionalArg) {\n  const options = getOptions(optionalArg);\n  if (!delegatedEvents[type]) {\n    delegatedEvents[type] = {\n      selectors: [],\n      contexts : [],\n      listeners: [],\n    };\n\n    // add delegate listener functions\n    for (const doc of documents) {\n      add(doc, type, delegateListener);\n      add(doc, type, delegateUseCapture, true);\n    }\n  }\n\n  const delegated = delegatedEvents[type];\n  let index;\n\n  for (index = delegated.selectors.length - 1; index >= 0; index--) {\n    if (delegated.selectors[index] === selector\n        && delegated.contexts[index] === context) {\n      break;\n    }\n  }\n\n  if (index === -1) {\n    index = delegated.selectors.length;\n\n    delegated.selectors.push(selector);\n    delegated.contexts .push(context);\n    delegated.listeners.push([]);\n  }\n\n  // keep listener and capture and passive flags\n  delegated.listeners[index].push([listener, !!options.capture, options.passive]);\n}\n\nfunction removeDelegate (selector, context, type, listener, optionalArg) {\n  const options = getOptions(optionalArg);\n  const delegated = delegatedEvents[type];\n  let matchFound = false;\n  let index;\n\n  if (!delegated) { return; }\n\n  // count from last index of delegated to 0\n  for (index = delegated.selectors.length - 1; index >= 0; index--) {\n    // look for matching selector and context Node\n    if (delegated.selectors[index] === selector\n        && delegated.contexts[index] === context) {\n\n      const listeners = delegated.listeners[index];\n\n      // each item of the listeners array is an array: [function, capture, passive]\n      for (let i = listeners.length - 1; i >= 0; i--) {\n        const [fn, capture, passive] = listeners[i];\n\n        // check if the listener functions and capture and passive flags match\n        if (fn === listener && capture === !!options.capture && passive === options.passive) {\n          // remove the listener from the array of listeners\n          listeners.splice(i, 1);\n\n          // if all listeners for this interactable have been removed\n          // remove the interactable from the delegated arrays\n          if (!listeners.length) {\n            delegated.selectors.splice(index, 1);\n            delegated.contexts .splice(index, 1);\n            delegated.listeners.splice(index, 1);\n\n            // remove delegate function from context\n            remove(context, type, delegateListener);\n            remove(context, type, delegateUseCapture, true);\n\n            // remove the arrays if they are empty\n            if (!delegated.selectors.length) {\n              delegatedEvents[type] = null;\n            }\n          }\n\n          // only remove one listener\n          matchFound = true;\n          break;\n        }\n      }\n\n      if (matchFound) { break; }\n    }\n  }\n}\n\n// bound to the interactable context when a DOM event\n// listener is added to a selector interactable\nfunction delegateListener (event, optionalArg) {\n  const options = getOptions(optionalArg);\n  const fakeEvent = {};\n  const delegated = delegatedEvents[event.type];\n  const [eventTarget] = (pointerUtils.getEventTargets(event));\n  let element = eventTarget;\n\n  // duplicate the event so that currentTarget can be changed\n  pExtend(fakeEvent, event);\n\n  fakeEvent.originalEvent = event;\n  fakeEvent.preventDefault = preventOriginalDefault;\n\n  // climb up document tree looking for selector matches\n  while (is.element(element)) {\n    for (let i = 0; i < delegated.selectors.length; i++) {\n      const selector = delegated.selectors[i];\n      const context = delegated.contexts[i];\n\n      if (domUtils.matchesSelector(element, selector)\n          && domUtils.nodeContains(context, eventTarget)\n          && domUtils.nodeContains(context, element)) {\n\n        const listeners = delegated.listeners[i];\n\n        fakeEvent.currentTarget = element;\n\n        for (let j = 0; j < listeners.length; j++) {\n          const [fn, capture, passive] = listeners[j];\n\n          if (capture === !!options.capture && passive === options.passive) {\n            fn(fakeEvent);\n          }\n        }\n      }\n    }\n\n    element = domUtils.parentNode(element);\n  }\n}\n\nfunction delegateUseCapture (event) {\n  return delegateListener.call(this, event, true);\n}\n\nfunction preventOriginalDefault () {\n  this.originalEvent.preventDefault();\n}\n\nfunction getOptions (param) {\n  return is.object(param)? param : { capture: param };\n}\n\nmodule.exports = {\n  add,\n  remove,\n\n  addDelegate,\n  removeDelegate,\n\n  delegateListener,\n  delegateUseCapture,\n  delegatedEvents,\n  documents,\n\n  supportsOptions,\n\n  _elements: elements,\n  _targets: targets,\n};\n","module.exports = function extend (dest, source) {\n  for (const prop in source) {\n    dest[prop] = source[prop];\n  }\n  return dest;\n};\n","const {\n  resolveRectLike,\n  rectToXY,\n} = require('./rect');\n\nmodule.exports = function (target, element, action) {\n  const actionOptions = target.options[action];\n  const actionOrigin = actionOptions && actionOptions.origin;\n  const origin = actionOrigin || target.options.origin;\n\n  const originRect = resolveRectLike(origin, target, element, [target && element]);\n\n  return rectToXY(originRect) || { x: 0, y: 0 };\n};\n","module.exports = (x, y) =>  Math.sqrt(x * x + y * y);\n","const extend = require('./extend');\nconst win    = require('./window');\n\nconst utils = {\n  warnOnce: function (method, message) {\n    let warned = false;\n\n    return function () {\n      if (!warned) {\n        win.window.console.warn(message);\n        warned = true;\n      }\n\n      return method.apply(this, arguments);\n    };\n  },\n\n  // http://stackoverflow.com/a/5634528/2280888\n  _getQBezierValue: function (t, p1, p2, p3) {\n    const iT = 1 - t;\n    return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3;\n  },\n\n  getQuadraticCurvePoint: function (startX, startY, cpX, cpY, endX, endY, position) {\n    return {\n      x:  utils._getQBezierValue(position, startX, cpX, endX),\n      y:  utils._getQBezierValue(position, startY, cpY, endY),\n    };\n  },\n\n  // http://gizma.com/easing/\n  easeOutQuad: function (t, b, c, d) {\n    t /= d;\n    return -c * t*(t-2) + b;\n  },\n\n  copyAction: function (dest, src) {\n    dest.name  = src.name;\n    dest.axis  = src.axis;\n    dest.edges = src.edges;\n\n    return dest;\n  },\n\n  is         : require('./is'),\n  extend     : extend,\n  hypot      : require('./hypot'),\n  getOriginXY: require('./getOriginXY'),\n};\n\nextend(utils, require('./arr'));\nextend(utils, require('./domUtils'));\nextend(utils, require('./pointerUtils'));\nextend(utils, require('./rect'));\n\nmodule.exports = utils;\n","const scope   = require('../scope');\nconst utils   = require('./index');\n\nconst finder = {\n  methodOrder: [ 'simulationResume', 'mouseOrPen', 'hasPointer', 'idle' ],\n\n  search: function (pointer, eventType, eventTarget) {\n    const pointerType = utils.getPointerType(pointer);\n    const pointerId = utils.getPointerId(pointer);\n    const details = { pointer, pointerId, pointerType, eventType, eventTarget };\n\n    for (const method of finder.methodOrder) {\n      const interaction = finder[method](details);\n\n      if (interaction) {\n        return interaction;\n      }\n    }\n  },\n\n  // try to resume simulation with a new pointer\n  simulationResume: function ({ pointerType, eventType, eventTarget }) {\n    if (!/down|start/i.test(eventType)) {\n      return null;\n    }\n\n    for (const interaction of scope.interactions) {\n      let element = eventTarget;\n\n      if (interaction.simulation && interaction.simulation.allowResume\n          && (interaction.pointerType === pointerType)) {\n        while (element) {\n          // if the element is the interaction element\n          if (element === interaction.element) {\n            return interaction;\n          }\n          element = utils.parentNode(element);\n        }\n      }\n    }\n\n    return null;\n  },\n\n  // if it's a mouse or pen interaction\n  mouseOrPen: function ({ pointerId, pointerType, eventType }) {\n    if (pointerType !== 'mouse' && pointerType !== 'pen') {\n      return null;\n    }\n\n    let firstNonActive;\n\n    for (const interaction of scope.interactions) {\n      if (interaction.pointerType === pointerType) {\n        // if it's a down event, skip interactions with running simulations\n        if (interaction.simulation && !utils.contains(interaction.pointerIds, pointerId)) { continue; }\n\n        // if the interaction is active, return it immediately\n        if (interaction.interacting()) {\n          return interaction;\n        }\n        // otherwise save it and look for another active interaction\n        else if (!firstNonActive) {\n          firstNonActive = interaction;\n        }\n      }\n    }\n\n    // if no active mouse interaction was found use the first inactive mouse\n    // interaction\n    if (firstNonActive) {\n      return firstNonActive;\n    }\n\n    // find any mouse or pen interaction.\n    // ignore the interaction if the eventType is a *down, and a simulation\n    // is active\n    for (const interaction of scope.interactions) {\n      if (interaction.pointerType === pointerType && !(/down/i.test(eventType) && interaction.simulation)) {\n        return interaction;\n      }\n    }\n\n    return null;\n  },\n\n  // get interaction that has this pointer\n  hasPointer: function ({ pointerId }) {\n    for (const interaction of scope.interactions) {\n      if (utils.contains(interaction.pointerIds, pointerId)) {\n        return interaction;\n      }\n    }\n  },\n\n  // get first idle interaction with a matching pointerType\n  idle: function ({ pointerType }) {\n    for (const interaction of scope.interactions) {\n      // if there's already a pointer held down\n      if (interaction.pointerIds.length === 1) {\n        const target = interaction.target;\n        // don't add this pointer if there is a target interactable and it\n        // isn't gesturable\n        if (target && !target.options.gesture.enabled) {\n          continue;\n        }\n      }\n      // maximum of 2 pointers per interaction\n      else if (interaction.pointerIds.length >= 2) {\n        continue;\n      }\n\n      if (!interaction.interacting() && (pointerType === interaction.pointerType)) {\n        return interaction;\n      }\n    }\n\n    return null;\n  },\n};\n\nmodule.exports = finder;\n","const win        = require('./window');\nconst isWindow   = require('./isWindow');\n\nconst is = {\n  array   : () => {},\n\n  window  : thing => thing === win.window || isWindow(thing),\n\n  docFrag : thing => is.object(thing) && thing.nodeType === 11,\n\n  object  : thing => !!thing && (typeof thing === 'object'),\n\n  function: thing => typeof thing === 'function',\n\n  number  : thing => typeof thing === 'number'  ,\n\n  bool    : thing => typeof thing === 'boolean' ,\n\n  string  : thing => typeof thing === 'string'  ,\n\n  element: thing => {\n    if (!thing || (typeof thing !== 'object')) { return false; }\n\n    const _window = win.getWindow(thing) || win.window;\n\n    return (/object|function/.test(typeof _window.Element)\n      ? thing instanceof _window.Element //DOM2\n      : thing.nodeType === 1 && typeof thing.nodeName === 'string');\n  },\n\n  plainObject: thing => is.object(thing) && thing.constructor.name === 'Object',\n};\n\nis.array = thing => (is.object(thing)\n  && (typeof thing.length !== 'undefined')\n  && is.function(thing.splice));\n\nmodule.exports = is;\n","module.exports = (thing) => !!(thing && thing.Window) && (thing instanceof thing.Window);\n","function pointerExtend (dest, source) {\n  for (const prop in source) {\n    const prefixedPropREs = module.exports.prefixedPropREs;\n    let deprecated = false;\n\n    // skip deprecated prefixed properties\n    for (const vendor in prefixedPropREs) {\n      if (prop.indexOf(vendor) === 0 && prefixedPropREs[vendor].test(prop)) {\n        deprecated = true;\n        break;\n      }\n    }\n\n    if (!deprecated && typeof source[prop] !== 'function') {\n      dest[prop] = source[prop];\n    }\n  }\n  return dest;\n}\n\npointerExtend.prefixedPropREs = {\n  webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/,\n};\n\nmodule.exports = pointerExtend;\n","const hypot         = require('./hypot');\nconst browser       = require('./browser');\nconst dom           = require('./domObjects');\nconst domUtils      = require('./domUtils');\nconst domObjects    = require('./domObjects');\nconst is            = require('./is');\nconst pointerExtend = require('./pointerExtend');\n\nconst pointerUtils = {\n  copyCoords: function (dest, src) {\n    dest.page = dest.page || {};\n    dest.page.x = src.page.x;\n    dest.page.y = src.page.y;\n\n    dest.client = dest.client || {};\n    dest.client.x = src.client.x;\n    dest.client.y = src.client.y;\n\n    dest.timeStamp = src.timeStamp;\n  },\n\n  setCoordDeltas: function (targetObj, prev, cur) {\n    targetObj.page.x    = cur.page.x    - prev.page.x;\n    targetObj.page.y    = cur.page.y    - prev.page.y;\n    targetObj.client.x  = cur.client.x  - prev.client.x;\n    targetObj.client.y  = cur.client.y  - prev.client.y;\n    targetObj.timeStamp = cur.timeStamp - prev.timeStamp;\n\n    // set pointer velocity\n    const dt = Math.max(targetObj.timeStamp / 1000, 0.001);\n\n    targetObj.page.speed   = hypot(targetObj.page.x, targetObj.page.y) / dt;\n    targetObj.page.vx      = targetObj.page.x / dt;\n    targetObj.page.vy      = targetObj.page.y / dt;\n\n    targetObj.client.speed = hypot(targetObj.client.x, targetObj.page.y) / dt;\n    targetObj.client.vx    = targetObj.client.x / dt;\n    targetObj.client.vy    = targetObj.client.y / dt;\n  },\n\n  isNativePointer: function  (pointer) {\n    return (pointer instanceof dom.Event || pointer instanceof dom.Touch);\n  },\n\n  // Get specified X/Y coords for mouse or event.touches[0]\n  getXY: function (type, pointer, xy) {\n    xy = xy || {};\n    type = type || 'page';\n\n    xy.x = pointer[type + 'X'];\n    xy.y = pointer[type + 'Y'];\n\n    return xy;\n  },\n\n  getPageXY: function (pointer, page) {\n    page = page || {};\n\n    // Opera Mobile handles the viewport and scrolling oddly\n    if (browser.isOperaMobile && pointerUtils.isNativePointer(pointer)) {\n      pointerUtils.getXY('screen', pointer, page);\n\n      page.x += window.scrollX;\n      page.y += window.scrollY;\n    }\n    else {\n      pointerUtils.getXY('page', pointer, page);\n    }\n\n    return page;\n  },\n\n  getClientXY: function (pointer, client) {\n    client = client || {};\n\n    if (browser.isOperaMobile && pointerUtils.isNativePointer(pointer)) {\n      // Opera Mobile handles the viewport and scrolling oddly\n      pointerUtils.getXY('screen', pointer, client);\n    }\n    else {\n      pointerUtils.getXY('client', pointer, client);\n    }\n\n    return client;\n  },\n\n  getPointerId: function (pointer) {\n    return is.number(pointer.pointerId)? pointer.pointerId : pointer.identifier;\n  },\n\n  setCoords: function (targetObj, pointers, timeStamp) {\n    const pointer = (pointers.length > 1\n                     ? pointerUtils.pointerAverage(pointers)\n                     : pointers[0]);\n\n    const tmpXY = {};\n\n    pointerUtils.getPageXY(pointer, tmpXY);\n    targetObj.page.x = tmpXY.x;\n    targetObj.page.y = tmpXY.y;\n\n    pointerUtils.getClientXY(pointer, tmpXY);\n    targetObj.client.x = tmpXY.x;\n    targetObj.client.y = tmpXY.y;\n\n    targetObj.timeStamp = is.number(timeStamp) ? timeStamp :new Date().getTime();\n  },\n\n  pointerExtend: pointerExtend,\n\n  getTouchPair: function (event) {\n    const touches = [];\n\n    // array of touches is supplied\n    if (is.array(event)) {\n      touches[0] = event[0];\n      touches[1] = event[1];\n    }\n    // an event\n    else {\n      if (event.type === 'touchend') {\n        if (event.touches.length === 1) {\n          touches[0] = event.touches[0];\n          touches[1] = event.changedTouches[0];\n        }\n        else if (event.touches.length === 0) {\n          touches[0] = event.changedTouches[0];\n          touches[1] = event.changedTouches[1];\n        }\n      }\n      else {\n        touches[0] = event.touches[0];\n        touches[1] = event.touches[1];\n      }\n    }\n\n    return touches;\n  },\n\n  pointerAverage: function (pointers) {\n    const average = {\n      pageX  : 0,\n      pageY  : 0,\n      clientX: 0,\n      clientY: 0,\n      screenX: 0,\n      screenY: 0,\n    };\n\n    for (const pointer of pointers) {\n      for (const prop in average) {\n        average[prop] += pointer[prop];\n      }\n    }\n    for (const prop in average) {\n      average[prop] /= pointers.length;\n    }\n\n    return average;\n  },\n\n  touchBBox: function (event) {\n    if (!event.length && !(event.touches && event.touches.length > 1)) {\n      return;\n    }\n\n    const touches = pointerUtils.getTouchPair(event);\n    const minX = Math.min(touches[0].pageX, touches[1].pageX);\n    const minY = Math.min(touches[0].pageY, touches[1].pageY);\n    const maxX = Math.max(touches[0].pageX, touches[1].pageX);\n    const maxY = Math.max(touches[0].pageY, touches[1].pageY);\n\n    return {\n      x: minX,\n      y: minY,\n      left: minX,\n      top: minY,\n      width: maxX - minX,\n      height: maxY - minY,\n    };\n  },\n\n  touchDistance: function (event, deltaSource) {\n    const sourceX = deltaSource + 'X';\n    const sourceY = deltaSource + 'Y';\n    const touches = pointerUtils.getTouchPair(event);\n\n\n    const dx = touches[0][sourceX] - touches[1][sourceX];\n    const dy = touches[0][sourceY] - touches[1][sourceY];\n\n    return hypot(dx, dy);\n  },\n\n  touchAngle: function (event, prevAngle, deltaSource) {\n    const sourceX = deltaSource + 'X';\n    const sourceY = deltaSource + 'Y';\n    const touches = pointerUtils.getTouchPair(event);\n    const dx = touches[1][sourceX] - touches[0][sourceX];\n    const dy = touches[1][sourceY] - touches[0][sourceY];\n    const angle = 180 * Math.atan2(dy , dx) / Math.PI;\n\n    return  angle;\n  },\n\n  getPointerType: function (pointer) {\n    return is.string(pointer.pointerType)\n      ? pointer.pointerType\n      : is.number(pointer.pointerType)\n        ? [undefined, undefined,'touch', 'pen', 'mouse'][pointer.pointerType]\n          // if the PointerEvent API isn't available, then the \"pointer\" must\n          // be either a MouseEvent, TouchEvent, or Touch object\n          : /touch/.test(pointer.type) || pointer instanceof domObjects.Touch\n            ? 'touch'\n            : 'mouse';\n  },\n\n  // [ event.target, event.currentTarget ]\n  getEventTargets: function (event) {\n    const path = is.function(event.composedPath) ? event.composedPath() : event.path;\n\n    return [\n      domUtils.getActualElement(path ? path[0] : event.target),\n      domUtils.getActualElement(event.currentTarget),\n    ];\n  },\n};\n\nmodule.exports = pointerUtils;\n","const { window } = require('./window');\n\nconst vendors = ['ms', 'moz', 'webkit', 'o'];\nlet lastTime = 0;\nlet request;\nlet cancel;\n\nfor (let x = 0; x < vendors.length && !window.requestAnimationFrame; x++) {\n  request = window[vendors[x] + 'RequestAnimationFrame'];\n  cancel = window[vendors[x] +'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\n}\n\nif (!request) {\n  request = function (callback) {\n    const currTime = new Date().getTime();\n    const timeToCall = Math.max(0, 16 - (currTime - lastTime));\n    const id = setTimeout(function () { callback(currTime + timeToCall); },\n                          timeToCall);\n\n    lastTime = currTime + timeToCall;\n    return id;\n  };\n}\n\nif (!cancel) {\n  cancel = function (id) {\n    clearTimeout(id);\n  };\n}\n\nmodule.exports = {\n  request,\n  cancel,\n};\n","const extend = require('./extend');\nconst is = require('./is');\nconst {\n  closest,\n  parentNode,\n  getElementRect,\n} = require('./domUtils');\n\nconst rectUtils = {\n  getStringOptionResult: function (value, interactable, element) {\n    if (!is.string(value)) {\n      return null;\n    }\n\n    if (value === 'parent') {\n      value = parentNode(element);\n    }\n    else if (value === 'self') {\n      value = interactable.getRect(element);\n    }\n    else {\n      value = closest(element, value);\n    }\n\n    return value;\n  },\n\n  resolveRectLike: function (value, interactable, element, functionArgs) {\n    value = rectUtils.getStringOptionResult(value, interactable, element) || value;\n\n    if (is.function(value)) {\n      value = value.apply(null, functionArgs);\n    }\n\n    if (is.element(value)) {\n      value = getElementRect(value);\n    }\n\n    return value;\n  },\n\n  rectToXY: function (rect) {\n    return  rect && {\n      x: 'x' in rect ? rect.x : rect.left,\n      y: 'y' in rect ? rect.y : rect.top,\n    };\n  },\n\n  xywhToTlbr: function (rect) {\n    if (rect && !('left' in rect && 'top' in rect)) {\n      rect = extend({}, rect);\n\n      rect.left   = rect.x || 0;\n      rect.top    = rect.y || 0;\n      rect.right  = rect.right   || (rect.left + rect.width);\n      rect.bottom = rect.bottom  || (rect.top + rect.height);\n    }\n\n    return rect;\n  },\n\n  tlbrToXywh: function (rect) {\n    if (rect && !('x' in rect && 'y' in rect)) {\n      rect = extend({}, rect);\n\n      rect.x      = rect.left || 0;\n      rect.top    = rect.top  || 0;\n      rect.width  = rect.width  || (rect.right  - rect.x);\n      rect.height = rect.height || (rect.bottom - rect.y);\n    }\n\n    return rect;\n  },\n};\n\nmodule.exports = rectUtils;\n","const win = module.exports;\nconst isWindow = require('./isWindow');\n\nfunction init (window) {\n  // get wrapped window if using Shadow DOM polyfill\n\n  win.realWindow = window;\n\n  // create a TextNode\n  const el = window.document.createTextNode('');\n\n  // check if it's wrapped by a polyfill\n  if (el.ownerDocument !== window.document\n      && typeof window.wrap === 'function'\n    && window.wrap(el) === el) {\n    // use wrapped window\n    window = window.wrap(window);\n  }\n\n  win.window = window;\n}\n\nif (typeof window === 'undefined') {\n  win.window     = undefined;\n  win.realWindow = undefined;\n}\nelse {\n  init(window);\n}\n\nwin.getWindow = function getWindow (node) {\n  if (isWindow(node)) {\n    return node;\n  }\n\n  const rootNode = (node.ownerDocument || node);\n\n  return rootNode.defaultView || rootNode.parentWindow || win.window;\n};\n\nwin.init = init;\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}